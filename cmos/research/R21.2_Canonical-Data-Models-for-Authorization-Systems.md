Canonical Data Models for Authorization Systems: A Report for OODS Foundry
Part 1: Executive Summary & Final Recommendation
1.1 Central Hypothesis Confirmed
This report confirms the mission's central hypothesis: Authorization is a highly complex, infrastructure-level domain that, while canonical, is not suitable for implementation as a simple "trait." The foundational Role-Based Access Control (RBAC) model, colloquially termed the "Core 5" (User, Role, Permission, and their two junction tables) , represents a universal starting point. This model has seen high convergence across open-source and enterprise systems. However, analysis reveals that this naive "Core 5" model is structurally insufficient for a multi-tenant Software-as-a-Service (SaaS) platform like OODS Foundry.   

1.2 The Multi-Tenant SaaS Imperative
The report's primary finding is the identification of a distinct, canonical SaaS RBAC model. The critical feature of this model is the replacement of the simple User_Role junction table with a Membership (or UserOrganizationRole) entity. This Membership table is designed to link a User to an Organization with a specific Role within that organization's context. This pattern is the essential integration point required for the OODS User and Organization core objects.   

1.3 Final Recommendation: Authorization as a Domain Extension Pack
The inherent complexity of authorization does not end with multi-tenancy. Requirements for hierarchical roles , advanced permission storage formats (such as JSON-based policies) , and the inevitable evolution toward Attribute-Based Access Control (ABAC)  and Relationship-Based Access Control (ReBAC)  make this domain a poor fit for a core trait. Forcing authorization into a trait would pollute the core User and Organization objects with significant, specialized, and evolving infrastructural concerns.   

Therefore, the definitive recommendation is that Authorization must be encapsulated as a separate Authorization domain, delivered via the OODS Foundry Extension Pack system.

1.4 Report Structure
This report is structured thematically to build the case for this recommendation.

Part 2 analyzes the canonical data models, tracing the evolution from the basic NIST standard to the essential multi-tenant SaaS pattern.

Part 3 explores advanced implementation patterns (hierarchies, JSON policies, ABAC/ReBAC) that demonstrate the domain's complexity, justifying the "extension pack" decision.

Part 4 provides the complete, formal v1.0 Canonical Data Model Specification for the proposed authz extension pack.

Part 2: The Canonical Data Models: From Theory to SaaS
2.1 The "Core 5": NIST Standard & Open Source Convergence
The foundation of modern authorization is the Role-Based Access Control model standardized by the National Institute of Standards and Technology (NIST). This model is defined by three primary sets of entities: Users (U), Roles (R), and Permissions (P). The relationships between them form the basis of the model:   

User-Role Assignment: A many-to-many relationship assigning users to roles.

Role-Permission Authorization: A many-to-many relationship assigning permissions to roles.

This theoretical model translates directly into a "Core 5" relational database schema:

users (or subjects)

roles

permissions (or operations on objects )   

user_roles (junction table)

role_permissions (junction table)

This exact 5-table pattern is demonstrably canonical across all major open-source web frameworks. The difficulty of correctly implementing authorization has, as predicted by the mission context, led to near-total convergence on this pattern.   

Django (django.contrib.auth): Implements this model almost perfectly, with one significant semantic confusion. Django's Group model  is its Role entity—a collection of users  that is also assigned permissions. The resulting schema consists of auth_user, auth_group (as Role), auth_permission, auth_user_groups (the User-Role junction), and auth_group_permissions (the Role-Permission junction).   

Laravel (Spatie/laravel-permission): This popular library provides a textbook implementation of the "Core 5" model. It creates roles, permissions, role_has_permissions (Role-Permission junction), and model_has_roles (a polymorphic User-Role junction).   

.NET: The pattern is identical, consisting of Roles, Permissions, Users, and the mapping tables RolePermission and UserRole.   

Ruby on Rails: While simple implementations use a single role column on the users table , any system requiring multiple roles per user defaults to the "Core 5" relational model.   

The following table demonstrates this convergence by comparing the two most popular open-source frameworks.

Canonical Entity	Django (django.contrib.auth)	Spatie/Laravel (laravel-permission)
User	auth_user	users (or any model via HasRoles trait)
Role	auth_group	roles
Permission	auth_permission	permissions
User-Role Junction	auth_user_groups	model_has_roles
Role-Permission Junction	auth_group_permissions	role_has_permissions
2.2 The SaaS Imperative: The Membership Pattern
The "Core 5" model analyzed above is critically flawed for OODS Foundry. Its user_roles junction is global. A user assigned the "Admin" role is an admin everywhere. This is untenable in a multi-tenant system where a user must be able to act as an "Admin" in their own organization and a "Viewer" in another.   

The canonical solution, converged upon by multi-tenant SaaS platforms, is to add the organization_id (i.e., tenant_id) to the junction table. The user_roles table is replaced by a memberships or user_organization_roles table. This entity is the formal integration contract linking the OODS User and Organization core traits to the Role entity defined within the authorization system.

Evidence for this Membership pattern is extensive:

SQL Schema Example: The "Ultimate Guide to Multi-Tenant SaaS Data Modeling" provides a perfect SQL schema for this: CREATE TABLE Membership (id, role, user_id, organization_id,...). This table explicitly links the user, organization, and their role within that organization.   

NoSQL Schema Example: A tutorial on multi-tenant RBAC in MongoDB  defines four core models: User, Company (as Tenant), Ticket (as Resource), and Membership. The Membership model contains a user reference and a company reference, creating the exact same linkage.   

PaaS Community Patterns: Community-driven multi-tenant RBAC solutions for platforms like Supabase are built around this same concept: linking a user_id to an organization_id or group_id  via a group_user table that assigns roles.   

Identity Provider (IdP) Documentation: Modern IdP documentation (e.g., Clerk, Frontegg) emphasizes "Role Scoping" as a key principle, where roles and permissions are assigned per tenant.   

The Membership table is the single most important entity for the OODS Authorization extension pack. The following table outlines its canonical schema.

Column Name	Data Type	Foreign Key (References)	Description
id	uuid	(Primary Key)	Unique identifier for the membership record.
user_id	uuid	core.users(id)	Integration Point: Links to the core User object.
organization_id	uuid	core.organizations(id)	Integration Point: Links to the core Organization object.
role_id	uuid	authz.roles(id)	Integration Point: Links to the Role defined in this extension pack.
created_at	timestamptz		
updated_at	timestamptz		
Index			UNIQUE(user_id, organization_id, role_id)
2.3 The Role vs. Group Distinction
A common implementation pitfall is the conflation of "Groups" and "Roles". This distinction is critical for a canonical model.   

A Group is a collection of Users. It is a management-plane concept used to organize subjects (e.g., "Engineering Team," "Marketing Department").   

A Role is a collection of Permissions. It is an authorization-plane concept used to define privileges (e.g., "Admin," "Editor," "Viewer").   

Platforms diverge on this:

Conflated (Django): Django's auth_group model  serves as both a Group (it holds users) and a Role (it is assigned permissions), creating semantic confusion.   

Separate (Keycloak, Azure): More robust systems model these as separate concepts. Keycloak documentation explicitly states, "Use groups to manage users" and "Use composite roles to manage applications and services". In Azure, roles can be assigned to users or groups.   

The Membership pattern (Section 2.2) is a Role assignment model. It does not explicitly model "Groups" of users, which is an acceptable simplification for a v1.0. The OODS model must be precise in its naming: the authz.roles table holds permissions. A future authz.groups feature (which would allow assigning a role to a group of users) can be a v2.0 addition.

Part 3: Advanced Patterns & The Case for an Extension Pack
The analysis of the canonical multi-tenant model in Part 2 is sufficient for a basic system, but it does not capture the full complexity of the authorization domain. The existence of advanced, well-established patterns for hierarchy, storage, and contextual logic is the primary justification for encapsulating this domain as an extension pack rather than a simple trait.

3.1 Advanced Model: Hierarchical Roles
A common requirement is for roles to inherit permissions from other roles (e.g., an "Admin" inherits all permissions from "Editor," which inherits from "Viewer"). This exposes a classic database performance trade-off: optimizing for simple writes versus simple reads. In an authorization system, read performance is paramount, as permissions are checked on nearly every request, while the role hierarchy is modified rarely.   

Pattern 1: Adjacency List (Simple Write, Complex Read)

Schema: This model is implemented with a simple parent_role_id column on the roles table  or, more robustly, a dedicated junction table: role_hierarchy (parent_role_id, child_role_id).   

Write Performance: Excellent. Adding a new sub-role is a single INSERT into the junction table.   

Read Performance: Poor. To find all permissions for a user, the application must execute a recursive SQL query (using a Common Table Expression) or a complex, multi-level JOIN to traverse the hierarchy. This is computationally expensive and scales poorly under high read load.   

Pattern 2: Nested Set Model (Complex Write, Simple Read)

Schema: This model removes the parent_role_id in favor of two integer columns on the roles table: lft and rgt. A node's descendants are defined as all nodes whose lft/rgt values fall within its own lft/rgt range.   

Write Performance: Extremely poor. Adding or deleting a single node can require recalculating and rewriting the lft and rgt values for a significant portion of the tree.   

Read Performance: Exceptionally fast. To get all roles in a hierarchy (and thus all their permissions), the application executes a single, non-recursive query: SELECT... WHERE node.lft BETWEEN parent.lft AND parent.rgt.   

For OODS Foundry, the recommended v1.0 approach is the Adjacency List model. The implementation complexity of the Nested Set model introduces significant development overhead and risk. The read-performance cost of the Adjacency List can be effectively mitigated at the application layer by heavily caching the resolved permission sets for each role.

3.2 Advanced Storage: Relational Junctions vs. JSON Policy Documents
The choice of how to store permissions is a critical design decision that dictates the system's flexibility.

Pattern 1: Relational Junction (The "Core 5" Model): This is the pattern used by Spatie/Laravel  and Django. A role_permissions junction table links role.id to permission.id. This is simple, normalized, and easy to query for administrative UIs ("show me all roles with this permission"). Its major drawback is inflexibility; it cannot represent conditions ("...only on resource X") or "Deny" rules.   

Pattern 2: JSON Policy Document (The AWS/ABAC Model): This pattern, canonized by AWS IAM, removes the role_permissions junction table. Instead, a Role is linked to a Policy object, which is stored as a JSON or JSONB document.   

This JSON policy defines the permission as a rule, not just a row :   

Effect: "Allow" or "Deny"

Action: A list of operations (e.g., s3:GetObject)

Resource: A list of resources (e.g., ARNs) the action applies to

Condition: An optional block of attribute-based logic (e.g., {"StringEquals": {"aws:SourceIp": "..."}})

This model is infinitely flexible and natively supports "Deny" rules, resource-scoping, and attribute-based conditions, effectively merging RBAC and ABAC. Furthermore, with modern databases like PostgreSQL, querying JSONB columns using a GIN index can be significantly faster for permission checks than the multi-table JOIN required by the relational model.   

The v1.0 OODS specification should use the Relational Junction model for its simplicity. The JSON Policy pattern is functionally an ABAC system and provides a clear and powerful evolutionary path for v2.0.

3.3 The Inevitable Evolution: ABAC & ReBAC
The existence of ABAC and ReBAC is the ultimate justification for isolating authorization in an extension pack. These models solve problems that pure RBAC cannot.

Model 1: Attribute-Based Access Control (ABAC)

The Problem: Pure RBAC suffers from "role explosion". If a system needs to restrict access by location, it must create duplicative roles: "Editor (USA)," "Editor (EMEA)," "Editor (APAC)," etc.   

The Solution: ABAC adds context to the decision. Instead of asking "Does User A have Role X?", it asks, "Does User A, with attributes (department: 'Sales', location: 'USA'), have a policy that allows 'edit' on a resource with attributes (sensitivity: 'public') during a time (9-5)?".   

Data Model: The primary challenge is storing the attributes. While the Entity-Attribute-Value (EAV) model is an option , it has notoriously poor query performance. The modern, canonical approach is to use JSONB columns on the users and resource tables. AWS, for example, implements ABAC by allowing policies to reference "tags" (key-value attributes) on principals and resources.   

Model 2: Relationship-Based Access Control (ReBAC)

The Concept: ReBAC, canonized by the Google Zanzibar paper , is the most modern paradigm. It generalizes RBAC and ABAC. Permissions are not assigned; they are derived from a graph of relationships between entities.   

Example: "A user can edit a document if they have an 'editor' relationship with the document" OR "if they have a 'member' relationship with a 'team' that has an 'owner' relationship with the 'folder' that contains the document."

Data Model: The data model is not a set of tables, but a set of stored "tuples," which represent the edges of the graph: object#relation@user.   

document:foo#editor@user:alice

folder:bar#parent@document:foo (Hierarchy/Containment)

group:eng#member@user:bob

folder:bar#viewer@group:eng#member (A "userset rewrite")

RBAC as a Subset: A traditional RBAC User_Role assignment is simply one type of tuple: role:admin#grant@user:bob. ReBAC is a true superset of RBAC. Auth0's Fine-Grained Authorization (FGA) is a commercial implementation of this Zanzibar model.   

The evolution from RBAC to ABAC to ReBAC proves that Authorization is not a static "check-box" feature. It is a complex, evolving, infrastructure-level service. Building it as an isolated extension pack (interfacing via the Membership table) is the only architectural pattern that allows OODS Foundry to upgrade its authorization logic (e.g., from relational RBAC to a ReBAC engine) in the future without re-architecting the core User and Organization objects.

Part 4: OODS Foundry: Specification & Scope Definition
4.1 Final Recommendation: A Domain Extension Pack
Based on the preceding analysis, the recommendation is definitively to create an Authorization (or authz) domain extension pack.

This decision is based on three primary arguments:

Domain Complexity: The patterns for hierarchical roles (Part 3.1) and advanced permission storage (Part 3.2), coupled with the inevitable evolution to ABAC and ReBAC (Part 3.3), prove the domain is vastly more complex than a simple trait. Systems like Spring Security ACL require a minimum of four dedicated tables just to handle object-level permissions, demonstrating the sheer infrastructural weight.   

Separation of Concerns: The User and Organization core traits should not be concerned with the implementation of authorization. They only need a mechanism to query what role(s) a user has within an organization. The Membership table  provides a perfect, loosely-coupled interface between the core traits and the authz extension pack.   

Evolution & Scalability: The "extension pack" model allows the authz domain to evolve independently. OODS Foundry can ship v1.0 with the canonical RBAC model specified below, and a future v2.0 can introduce a full ABAC/JSON policy engine without any breaking changes to the core User or Organization traits.

4.2 Canonical Data Model Specification: authz Extension v1.0 (SQL DDL)
The following SQL DDL represents the v1.0 canonical data model for the authz extension pack. This schema synthesizes the report's findings:

It implements the "Core 5"  but names entities precisely (roles, permissions, role_permissions).   

It replaces the naive user_roles table with the SaaS-canonical memberships table , which serves as the integration point.   

It implements the pragmatic v1.0 solution for hierarchies: an role_hierarchy adjacency list junction table.   

It uses the simple, canonical relational model for permission storage.   

SQL
-- This schema assumes a separate 'core' schema exists for OODS core traits
-- like 'core.users' and 'core.organizations'.

CREATE SCHEMA IF NOT EXISTS authz;

--
-- TABLE 1: authz.roles
-- Defines the abstract roles (collections of permissions).
-- e.g., "Admin", "Editor", "Viewer"
--
CREATE TABLE authz.roles (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name text NOT NULL,
    description text,
    
    -- A unique constraint on 'name' ensures no duplicate roles.
    -- For v1.0, roles are global. A future version could make
    -- roles tenant-defined via an organization_id foreign key.
    UNIQUE(name) 
);

--
-- TABLE 2: authz.permissions
-- Defines the discrete, atomic permissions in the system.
-- e.g., "document:create", "document:read", "user:invite"
--
CREATE TABLE authz.permissions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- 'name' is the canonical string for the permission.
    -- e.g., "document:create"
    name text NOT NULL,
    description text,
    
    -- Optional: Grouping for UI purposes, e.g., "Document", "User"
    resource_type text, 
    
    UNIQUE(name)
);

--
-- TABLE 3: authz.role_permissions
-- Junction table for the many-to-many relationship: Role <-> Permission
-- This is the canonical relational (non-JSON) storage pattern.
--
CREATE TABLE authz.role_permissions (
    role_id uuid NOT NULL REFERENCES authz.roles(id) ON DELETE CASCADE,
    permission_id uuid NOT NULL REFERENCES authz.permissions(id) ON DELETE CASCADE,
    
    -- This composite primary key prevents duplicate entries.
    PRIMARY KEY (role_id, permission_id)
);

--
-- TABLE 4: authz.memberships
-- This is the *CRITICAL* multi-tenant junction table.
-- It replaces the naive 'user_roles' table.
-- It links a User, an Organization, and a Role.
--
CREATE TABLE authz.memberships (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- INTEGRATION POINT 1: Foreign key to the core User trait.
    user_id uuid NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,
    
    -- INTEGRATION POINT 2: Foreign key to the core Organization trait.
    organization_id uuid NOT NULL REFERENCES core.organizations(id) ON DELETE CASCADE,
    
    -- INTEGRATION POINT 3: Foreign key to the Role defined in this pack.
    role_id uuid NOT NULL REFERENCES authz.roles(id) ON DELETE CASCADE,
    
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    
    -- A user can have multiple roles in one org, but not the *same* role twice.
    UNIQUE(user_id, organization_id, role_id)
);

--
-- TABLE 5: authz.role_hierarchy
-- Implements the Adjacency List pattern for role inheritance.
--
CREATE TABLE authz.role_hierarchy (
    parent_role_id uuid NOT NULL REFERENCES authz.roles(id) ON DELETE CASCADE,
    child_role_id uuid NOT NULL REFERENCES authz.roles(id) ON DELETE CASCADE,
    
    PRIMARY KEY (parent_role_id, child_role_id),
    
    -- Prevent circular dependencies
    CHECK (parent_role_id <> child_role_id)
);
4.3 Extension Pack Scope Definition (authz v1.0)
Purpose: The authz extension pack provides a canonical, multi-tenant Role-Based Access Control system for OODS Foundry.

In-Scope:

Management of Roles (authz.roles).

Management of Permissions (authz.permissions).

Mapping Permissions to Roles (authz.role_permissions).

Mapping Users to Organizations with specific Roles (authz.memberships). This is the primary API for linking core traits.

Management of simple role hierarchies (authz.role_hierarchy).

Providing a service API to resolve a user's effective permissions for a given organization (e.g., get_permissions(user_id, organization_id)).

Out-of-Scope (Future Evolution):

v1.0 is NOT ABAC: The v1.0 model does not include storage or policy evaluation for dynamic user, resource, or environment attributes. This is a v2.0 feature.   

v1.0 is NOT ReBAC: The v1.0 model is not a graph-based tuple system. It is a classic, relational RBAC implementation.   

v1.0 is NOT Object-Level ACLs: The v1.0 model does not provide for per-object permissions (e.g., "Alice can edit document:123 but not document:456"). This is a far more complex model (see Spring ACL ) and should be a separate extension or v3.0.   

v1.0 is NOT User Groups: Does not include the concept of Groups (collections of users). Roles are assigned directly to users via the Membership table.   


stackoverflow.com
Best Role-Based Access Control (RBAC) database model [closed] - Stack Overflow
Opens in a new window

amrelsher07.medium.com
Implementing Role-Based Access Control (RBAC) with Claims Transformation in .NET Core
Opens in a new window

medium.com
Designing a Role-Based Access Control (RBAC) System: A Scalable Approach | by Rohit
Opens in a new window

spatie.be
Basic Usage | laravel-permission - Spatie
Opens in a new window

permit.io
Implement Multi-Tenancy Role-Based Access Control (RBAC) in ...
Opens in a new window

flightcontrol.dev
Ultimate guide to multi-tenant SaaS data modeling - Flightcontrol
Opens in a new window

clerk.com
How to Design a Multi-Tenant SaaS Architecture - Clerk
Opens in a new window

researchgate.net
(PDF) Improve Query Performance On Hierarchical Data. Adjacency ...
Opens in a new window

docs.aws.amazon.com
Policies and permissions in AWS Identity and Access Management ...
Opens in a new window

osohq.com
RBAC vs ABAC: main differences and which one you should use - Oso
Opens in a new window

authzed.com
An Introduction to Google Zanzibar and Relationship-Based ...
Opens in a new window

ibm.com
What Is Role-Based Access Control (RBAC)? - IBM
Opens in a new window

en.wikipedia.org
Role-based access control - Wikipedia
Opens in a new window

tsapps.nist.gov
The NIST Model for Role Based Access Control: Towards a Unified Standard
Opens in a new window

pathlock.com
Role-Based Access Control (RBAC): A Comprehensive Guide - Pathlock
Opens in a new window

csrc.nist.gov
Role-based Access Control - NIST Computer Security Resource Center
Opens in a new window

docs.oasis-open.org
Core and hierarchical role based access control (RBAC) profile of XACML v2.0 - OASIS Open
Opens in a new window

docs.djangoproject.com
User authentication in Django
Opens in a new window

medium.com
Managing User Permissions and Roles in Django: A Hands-On Guide | by Farad Alam
Opens in a new window

docs.djangoproject.com
django.contrib.auth | Django documentation | Django
Opens in a new window

opentechschool.github.io
Database — Django 101 Tutorial - OpenTechSchool
Opens in a new window

stackoverflow.com
How does Django make tables relating to user,auth,group,session and so on with very first migration? - Stack Overflow
Opens in a new window

github.com
spatie/laravel-permission: Associate users with roles and permissions - GitHub
Opens in a new window

medium.com
Building a Secure API with Laravel: Role-Based Access Control using Spatie Permissions
Opens in a new window

spatie.be
Introduction | laravel-permission - Spatie
Opens in a new window

drawsql.app
Database schema for Laravel Permission - DrawSQL
Opens in a new window

medium.com
Implementing Role-Based Access Control (RBAC) in Rails: A Comprehensive Guide | by Sumit Sah | Medium
Opens in a new window

hibbard.eu
Authentication with Devise and CanCanCan in Rails 8 - James Hibbard
Opens in a new window

permit.io
Best Practices for Multi-Tenant Authorization - Permit.io
Opens in a new window

github.com
Custom claims for multi tenancy and user roles · supabase · Discussion #1148 - GitHub
Opens in a new window

github.com
point-source/supabase-tenant-rbac: A template for ... - GitHub
Opens in a new window

stackoverflow.com
Group vs role (Any real difference?) - Stack Overflow
Opens in a new window

frontegg.com
What Is Role-Based Access Control (RBAC)? A Complete Guide - Frontegg
Opens in a new window

keycloak.org
Server Administration Guide - Keycloak
Opens in a new window

learn.microsoft.com
What is Azure role-based access control (Azure RBAC)? | Microsoft Learn
Opens in a new window

docs.oracle.com
4 Role-Based Access Control - Oracle Fusion Applications Security Guide
Opens in a new window

blog.stackademic.com
Designing a Flexible Role-Based Access Control (RBAC) System for ...
Opens in a new window

stackoverflow.com
Hierarchical Data Models: Adjacency List vs. Nested Sets - Stack Overflow
Opens in a new window

medium.com
The Nested Set Model: A Comprehensive Guide | by Ayushtiwari ...
Opens in a new window

medium.com
Comparing Query Performance in PostgreSQL: JSONB vs Join Queries | by Sruthi Ganesh
Opens in a new window

reddit.com
Using a JSONB column versus a join table : r/PostgreSQL - Reddit
Opens in a new window

developer.okta.com
Role-Based Access Control - Authorization - Okta Developer
Opens in a new window

okta.com
RBAC vs. ABAC: Definitions & When to Use - Okta
Opens in a new window

splunk.com
RBAC vs. ABAC: Role-Based & Attribute-Based Access Control Compared | Splunk
Opens in a new window

citrix.com
ABAC vs. RBAC: What's the difference? – Citrix Blogs
Opens in a new window

material.security
RBAC vs ABAC: Identity Security
Opens in a new window

cerbos.dev
3 Most Common Authorization Designs for SaaS Products - Cerbos
Opens in a new window

reddit.com
EAV or JSON : r/PostgreSQL - Reddit
Opens in a new window

leapcell.io
Storing Dynamic Attributes - Sparse Columns, EAV, and JSONB ...
Opens in a new window

razsamuel.com
PostgreSQL JSONB vs. EAV: Which is Better for Storing Dynamic Data? - Raz Samuel Blog -
Opens in a new window

frontegg.com
ABAC (Attribute-Based Access Control): Guide and Examples - Frontegg
Opens in a new window

docs.aws.amazon.com
Define permissions based on attributes with ABAC authorization - AWS Documentation
Opens in a new window

en.wikipedia.org
Relationship-based access control - Wikipedia
Opens in a new window

aserto.com
How Google Drive models authorization: A look into Zanzibar - Aserto
Opens in a new window

research.google
Zanzibar: Google's Consistent, Global Authorization System
Opens in a new window

osohq.com
Authorization Academy - Relationship-Based Access Control (ReBAC) - Oso
Opens in a new window

docs.fga.dev
Modeling Roles and Permissions | Auth0 Fine-Grained Authorization ...
Opens in a new window

docs.spring.io
Domain Object Security (ACLs) :: Spring Security