An Enterprise Blueprint for Multi-Brand Theming: A Unified Architecture for 2025
I. Executive Summary: A Unified Architecture for Multi-Brand Theming in 2025
The challenge of managing multiple brand identities across a suite of digital products has become a primary driver for innovation in design system architecture. As of 2024–2025, a definitive set of best practices has emerged, enabling enterprises to achieve unprecedented scale, consistency, and efficiency. This report details a unified architectural blueprint for implementing multi-brand, multi-theme design systems using a modern, standards-compliant technology stack. The core thesis is a cohesive workflow where design tokens, specified in the W3C Design Tokens Community Group (DTCG) format, serve as the single source of truth. These tokens are then processed through a sophisticated build pipeline powered by Style Dictionary v4, which transforms them into standard CSS custom properties. Finally, these properties are consumed by Tailwind CSS v4's innovative CSS-first architecture, enabling a highly efficient, scalable, and maintainable system that fully decouples presentation from component logic.   

This architecture is built upon a series of key recommendations that address the entire lifecycle of a design token, from conception to implementation. First, it advocates for a multi-tiered token architecture—comprising Global, Brand, and Semantic layers—as the foundational structure for managing complexity. Second, it resolves the common debate between "Brand-Scoped Alias Tokens" and "CSS Variable Chaining" by demonstrating their synergistic relationship within a single pipeline. Third, it mandates the use of the OKLCH color space for creating perceptually uniform, mathematically sound, and inherently more accessible color systems. Fourth, it champions a "tokens-only" theming strategy, a strict architectural contract that ensures components remain entirely unaware of brand or theme context, thus maximizing reusability and minimizing maintenance. Finally, it establishes the necessity of automated, Git-based workflows to eliminate the persistent and costly problem of drift between design artifacts in Figma and their implementation in code.

Adopting this unified architecture provides significant strategic business value. It transforms the design system from a simple style guide into a powerful operational lever. By systematizing brand and theme variations, organizations can dramatically accelerate the time-to-market for new products, white-label platforms, and regional variants, reducing launch cycles from months to hours. This approach systematically reduces technical debt by ensuring that changes cascade predictably across all products, and it fosters deep cross-functional alignment by establishing design tokens as the lingua franca between design, engineering, and product teams.   

II. Architectural Crossroads: Variable Chaining vs. Brand-Scoped Alias Tokens
A foundational decision in architecting a multi-brand system is how to manage the relationship between a component's role and a brand's specific visual style. This often leads to a debate between two powerful concepts: brand-scoped alias tokens and CSS variable chaining. However, a modern, automated pipeline reveals that these are not competing strategies but rather two sequential and complementary stages of a single, robust theming process.

Defining the Concepts
To understand their interplay, it is essential to define each concept within its specific context: the token source and the compiled output.

Brand-Scoped Alias Tokens
This is an architectural pattern applied within the design token source files, typically DTCG-compliant JSON. In this model, a semantic token, which describes the purpose of a style (e.g., color.background.primary), does not hold a raw value. Instead, it acts as an alias, pointing to a different, brand-specific primitive token (e.g., {color.brand.alpha.blue.500} or {color.brand.beta.green.500}). The build tool resolves this alias based on the brand context being compiled. This strategy centralizes design intent within the token structure itself, making the system's logic explicit and manageable at the source. The alias acts as a stable name for a UI role, while its value is a variable pointer to a brand's specific palette.   

CSS Variable Chaining
This is an implementation technique executed in the browser using native CSS custom properties. In this pattern, a semantic CSS variable is defined by referencing another CSS variable (e.g., --semantic-bg-primary: var(--brand-primary-500);). The browser resolves this chain at runtime. Theming is achieved by redefining the base variables (e.g., --brand-primary-500) within a new scope, such as a data attribute on the <html> element ([data-brand="beta"]). This allows the entire UI to change instantly without altering the CSS applied to individual components. The component's styling remains constant (background-color: var(--semantic-bg-primary);), while the underlying value it resolves to is dynamic.   

Comparative Analysis and Recommendation
The critical realization is that these two concepts operate at different stages of the design-to-code pipeline. Alias tokens exist in the pre-compiled source of truth, defining the architectural relationships. CSS variable chaining is the compiled output that makes those relationships dynamic in the browser. A build tool like Style Dictionary is the engine that translates the former into the latter. An alias like {color.brand.alpha.blue.500} in a JSON file is transformed by Style Dictionary into a CSS value like var(--color-brand-alpha-blue-500).   

Therefore, the optimal architecture does not choose one over the other; it uses them in concert. A multi-level aliasing strategy within the DTCG source files is used to generate a corresponding multi-level chain of CSS custom properties. This hybrid approach provides maximum flexibility and maintainability. A brand refresh, for instance, might only require changing the raw color values in a single brand primitive file. The alias structure ensures this change correctly propagates through the semantic layer and into the compiled CSS, updating all components without requiring any code changes at the component level. This creates a system that is both highly expressive at the source and highly performant at runtime.   

The following table clarifies the distinct roles and characteristics of each concept within this unified workflow.

Feature	Brand-Scoped Alias Tokens (Source)	CSS Variable Chaining (Output)
Definition	A token that references the value of another token.	A CSS custom property whose value is another custom property via var().
Where it Lives	DTCG/JSON source files, managed in a code repository.	Compiled CSS stylesheets, loaded by the browser.
How it's Defined	Using reference syntax, e.g., "$value": "{path.to.another.token}".	Using CSS var() function, e.g., property: var(--another-variable);.
Key Advantage	Encapsulates design intent and relationships in a single source of truth.	Enables real-time theme switching in the browser with zero JavaScript re-renders.
Role in Theming	Defines the architectural mapping between semantic roles and brand-specific values at build time.	Implements the dynamic switching mechanism that allows the browser to resolve the correct values at runtime.

Export to Sheets
III. A Multi-Layered Token Architecture for Enterprise Scale
To effectively manage the complexity of a multi-brand system, a structured, multi-layered token architecture is non-negotiable. The most robust and widely adopted model follows a three-tier structure that separates raw values from their semantic application, often conceptualized as "WHAT, HOW, and WHERE". This layered approach is the foundation for achieving true "tokens-only" theming, where components are entirely decoupled from brand and theme logic.   

Defining the Tiers
Each tier in the architecture serves a distinct purpose, creating a clear hierarchy of design decisions that cascade from abstract to specific.

Tier 1: Global (Core) Primitives
This is the bedrock of the design system. Global primitives represent the absolute, brand-agnostic foundational values that are shared across all brands and themes. These tokens define the system's underlying structure and rhythm and should never be altered on a per-brand basis. Their stability ensures a consistent structural experience, even when the surface-level branding changes dramatically.   

Examples:

Spacing: A numeric scale for margins, padding, and gaps (e.g., space.100: 0.25rem, space.200: 0.5rem).

Typography: Foundational scales for font sizes (e.g., font.size.100: 0.75rem, font.size.200: 0.875rem).

Structure: Values for border radii, border widths, and layout constraints (e.g., radius.sm: 4px, border.width.100: 1px).

Tier 2: Brand Primitives
This tier contains the raw values that define each brand's unique visual identity. These tokens are organized into distinct collections, typically in separate files or directories for each brand. This layer is where the specific color palettes, font families, and other brand-defining characteristics are stored. While the names of the tokens within each brand's collection may be consistent (e.g., blue.500), their values will differ to reflect the brand's style guide.

Examples:

Brand Alpha Palette: color.brand.alpha.blue.500: oklch(58% 0.17 260)

Brand Beta Palette: color.brand.beta.green.500: oklch(65% 0.15 150)

Brand Alpha Typography: font.family.brand.alpha.heading: "Inter", sans-serif

Brand Beta Typography: font.family.brand.beta.heading: "Roboto Slab", serif

Tier 3: Semantic (Alias/Theme) Tokens
This is the most critical layer for enabling theming and ensuring system scalability. Semantic tokens provide context and describe the purpose or role of a value in the UI, rather than its literal value. They act as a crucial mapping layer, connecting abstract UI roles to specific primitive values from the Global and Brand tiers. A strict architectural rule must be enforced: components should only ever consume tokens from this semantic tier. This layer is also where theme variations like light, dark, and high-contrast modes are defined, by having a single semantic token point to different primitives based on the active theme.   

Examples:

color.background.primary (The main background color for the application shell).

color.text.default (The standard color for body text).

color.border.interactive (The border color for clickable elements like buttons).

font.family.body (The font family for all body copy).

Structuring for Brand → Theme Layering
The power of this architecture is realized in how the semantic layer functions as a dynamic switchboard. A single semantic token, such as color.background.primary, will have multiple definitions that alias different primitive tokens based on the combination of the active brand and theme.

This logic is resolved during the build process. For example, when building the theme for "Brand Alpha, Dark Mode," the build configuration would instruct the system to resolve the semantic tokens using Brand Alpha's primitives and the dark mode mapping.

Example Resolution Logic:

Context: Brand Alpha, Light Mode

color.background.primary resolves to {color.brand.alpha.neutral.0} (e.g., white).

Context: Brand Alpha, Dark Mode

color.background.primary resolves to {color.brand.alpha.neutral.1000} (e.g., near-black).

Context: Brand Beta, Light Mode

color.background.primary resolves to {color.brand.beta.neutral.100} (e.g., an off-white).

Context: Brand Beta, Dark Mode

color.background.primary resolves to {color.brand.beta.neutral.900} (e.g., a dark charcoal).

Achieving "Tokens-Only" Theming
The "tokens-only" theming strategy is the ultimate outcome of this layered architecture. It establishes a strict contract: components are completely unaware of the concepts of "brand" or "theme." A button component, for example, only ever requests color.background.interactive and color.text.on-interactive. It has no conditional logic such as if (theme === 'dark') or if (brand === 'beta').   

This decoupling is achieved by externalizing all theming logic into the token pipeline and the application's root. The build process generates separate CSS files for each brand/theme combination (e.g., brand-alpha-light.css, brand-beta-dark.css). The application is then responsible for either loading the single correct CSS file or, more commonly, loading all of them and toggling a data-brand and data-theme attribute on the <html> element. This activates the appropriate CSS rule block, which redefines the values of the semantic CSS variables globally.

The component's style (background-color: var(--color-background-interactive)) never changes. Only the value that this variable resolves to is altered externally. This complete separation of concerns dramatically reduces component complexity, eliminates redundant component variations (e.g., ButtonDark, ButtonBrandBeta), and makes the entire system vastly easier to maintain and scale.   

IV. Implementation Blueprint: DTCG Tokens and Style Dictionary v4
Translating the multi-layered token architecture into a functional build pipeline requires a well-organized file structure and a powerful, dynamic build script. Style Dictionary v4, with its support for modern JavaScript features and the DTCG specification, is the ideal tool for this task.

Recommended Directory Structure
A logical directory structure is essential for managing the different token tiers and brands. The following structure separates concerns cleanly and is easily parsable by a build script, drawing inspiration from established patterns.   

tokens/
├── core/
│   ├── space.json
│   ├── radius.json
│   └── typography-scale.json
├── brands/
│   ├── alpha/
│   │   ├── base.json          # Core brand palette (light mode default)
│   │   ├── dark.json          # Dark mode overrides
│   │   ├── hc.json            # High-contrast mode overrides
│   │   └── typography.json
│   └── beta/
│       ├── base.json
│       ├── dark.json
│       ├── hc.json
│       └── typography.json
└── semantic/
    ├── color.json             # Semantic color aliases
    └── typography.json        # Semantic typography aliases
In this model:

core/ holds the Tier 1 global primitives.

brands/<brand-name>/ holds the Tier 2 brand-specific primitives, further subdivided by theme (mode). The base.json file contains the default (typically light mode) values, while dark.json and hc.json contain only the values that need to be overridden for those themes.

semantic/ holds the Tier 3 semantic aliases, which reference tokens from both the core and brands directories.

Crafting DTCG-Compliant Token Files
All token files should adhere to the W3C Design Tokens Community Group (DTCG) specification. This ensures interoperability with a growing ecosystem of tools and establishes a clear, standardized format. The key properties are $value, $type, and $description. Style Dictionary v4 supports this format out of the box, though it's important not to mix the legacy format (e.g., value) with the DTCG format (e.g., $value) within a single build process.   

Example: tokens/brands/alpha/base.json (Brand Primitive)

JSON

{
  "color": {
    "brand": {
      "alpha": {
        "primary": {
          "500": {
            "$type": "color",
            "$value": "oklch(0.65 0.18 265)",
            "$description": "Brand Alpha's primary interactive color."
          }
        },
        "neutral": {
          "0": { "$type": "color", "$value": "oklch(0.99 0.01 240)" },
          "1000": { "$type": "color", "$value": "oklch(0.15 0.01 240)" }
        }
      }
    }
  }
}
Example: tokens/semantic/color.json (Semantic Alias)

JSON

{
  "color": {
    "background": {
      "primary": {
        "$type": "color",
        "$value": "{color.brand.alpha.neutral.0}",
        "$description": "The primary background color for the application shell."
      }
    },
    "action": {
      "primary": {
        "default": {
          "$type": "color",
          "$value": "{color.brand.alpha.primary.500}",
          "$description": "Default background for primary buttons."
        }
      }
    }
  }
}
Configuring Style Dictionary v4 for Multi-Brand Output (sd.config.mjs)
Style Dictionary v4 introduces several key improvements, including first-class support for ES Modules in configuration, a class-based instantiation (new StyleDictionary()), and async methods for building platforms (buildPlatform()). A dynamic build script is the key to handling a multi-brand, multi-theme setup. The script should programmatically generate a Style Dictionary configuration for each unique combination of brand and theme, then run the build process for each one.   

The power of this approach lies in the strategic use of Style Dictionary's include and source arrays. The include array should contain the foundational tokens (core and base brand tokens), while the source array should contain the more specific overrides (theme-specific brand tokens and semantic tokens). Style Dictionary performs a deep merge, where files in source take precedence over files in include, allowing for a clean and predictable layering of styles.   

Code Sample: A Complete sd.config.mjs
The following is a complete, functional ES Module script for Style Dictionary v4. It discovers brands and themes from the directory structure and generates a separate CSS file for each, wrapped in the appropriate data- attribute selectors.

JavaScript

import StyleDictionary from 'style-dictionary';
import { readdirSync } from 'fs';

const brands = readdirSync('./tokens/brands');
const themes = ['light', 'dark', 'hc']; // Define our supported themes

// Custom format for CSS variables with data-attribute scoping
StyleDictionary.registerFormat({
  name: 'css/variables-themed',
  formatter: function({ dictionary, options }) {
    const selector = `[data-brand="${options.brand}"][data-theme="${options.theme}"]`;
    const header = `/*\n * BRAND: ${options.brand}\n * THEME: ${options.theme}\n * Do not edit directly, this file is auto-generated.\n */\n`;
    const variables = dictionary.allTokens
     .map(token => `  --${token.name}: ${token.value};`)
     .join('\n');
    
    return `${header}${selector} {\n${variables}\n}`;
  }
});

// Main build function
async function run() {
  for (const brand of brands) {
    for (const theme of themes) {
      console.log(`\nBuilding: Brand '${brand}', Theme '${theme}'`);

      const config = {
        // The 'include' array forms the base. Core tokens are always included.
        // The base brand tokens are also included as a foundation.
        include: [
          `tokens/core/**/*.json`,
          `tokens/brands/${brand}/base.json`
        ],
        // The 'source' array provides the overrides.
        // Theme-specific brand tokens (e.g., dark.json) override the base.
        // Semantic tokens are last to map roles to the resolved primitives.
        source: [
          `tokens/brands/${brand}/${theme === 'light'? 'base' : theme}.json`,
          `tokens/semantic/**/*.json`
        ],
        platforms: {
          css: {
            transformGroup: 'css',
            buildPath: 'build/css/themes/',
            prefix: 'semantic', // Prefix for variable names, e.g., --semantic-color-background-primary
            files: [{
              destination: `${brand}-${theme}.css`,
              format: 'css/variables-themed',
              options: {
                brand: brand,
                theme: theme
              }
            }]
          }
        }
      };

      const sd = new StyleDictionary(config);
      // buildPlatform is now an async method in v4
      await sd.buildPlatform('css');
    }
  }
  console.log('\nBuild complete!');
}

run();
This script automates the entire process. When executed, it will generate files like build/css/themes/alpha-light.css, build/css/themes/alpha-dark.css, build/css/themes/beta-light.css, etc., each containing the correctly resolved and scoped CSS custom properties for that specific context.

V. Integration with Tailwind CSS v4: A CSS-First Approach
With a complete set of themed CSS custom properties generated by Style Dictionary, the next step is to integrate them into a front-end application using Tailwind CSS v4. The framework's new CSS-first configuration model provides a streamlined and powerful way to consume these variables, acting as a thin binding layer between the design system's tokens and Tailwind's utility-class engine.   

Consuming Style Dictionary Output
There are two primary strategies for loading the generated CSS theme files into an application.

Dynamic Loading: The application's root component or entry point can dynamically inject a <link> tag pointing to the correct CSS file (e.g., /themes/brand-alpha-dark.css) based on the current context (e.g., subdomain, user preference). This method is efficient as it only loads the necessary styles, but it can cause a brief flash of unstyled content (FOUC) if the theme switch happens after the initial page load.

Attribute Scoping (Recommended): All generated theme files are imported into the main application stylesheet. Since each file's content is wrapped in a specific selector like [data-brand="alpha"][data-theme="dark"], only the rules matching the attributes on the <html> tag will be active. The application then simply toggles these attributes to switch themes. This is the most common and flexible approach, providing instant, FOUC-free theme switching at the cost of a slightly larger initial CSS payload.   

Leveraging the @theme Directive
A paradigm shift in Tailwind CSS v4 is the ability to configure the framework directly within a CSS file using directives, primarily @theme. This eliminates the need for a complex tailwind.config.js file for most theming tasks.   

A common misconception is to have Style Dictionary generate a Tailwind-specific @theme block. This creates an undesirable tight coupling, violating the principle that the token pipeline should remain platform-agnostic. The superior architectural pattern is to separate these concerns:

Style Dictionary's Role: Generate standard, framework-agnostic CSS custom properties. Its job is to be the single source of truth for the design system's values.

Tailwind's Role: Consume these standard CSS properties. The @theme block in the application's main CSS file acts as a lightweight "adapter" or "binding layer." It maps Tailwind's conceptual utilities (e.g., the primary color) to the semantic CSS variables provided by the design system (e.g., var(--semantic-color-action-primary-default)).

This separation ensures that the design system's token output can be consumed by any project, whether it uses Tailwind or not, while allowing the Tailwind project to leverage its powerful utility-first workflow.

Code Sample: tailwind.css Configuration and Component Markup
The following code demonstrates the complete integration, showing how the generated theme files and the @theme directive work together to power a themed component.

app.css (Main Application Stylesheet)

CSS

/* 1. Import Tailwind's base, components, and utilities */
@import "tailwindcss";

/* 2. Import all the generated theme files from Style Dictionary.
      The attribute scoping within each file ensures only one theme is active at a time. */
@import "./build/css/themes/*.css";

/* 3. Use the @theme directive to create the adapter layer.
      This tells Tailwind to create utilities like 'bg-primary', 'text-primary', etc.,
      and instructs them to use the value from our semantic CSS variable. */
@theme {
  /* Map semantic color tokens to Tailwind's color scale */
  --color-primary: var(--semantic-color-action-primary-default);
  --color-secondary: var(--semantic-color-action-secondary-default);
  --color-danger: var(--semantic-color-feedback-negative-default);
  
  /* Map semantic text color tokens */
  --color-text-body: var(--semantic-color-text-default);
  --color-text-muted: var(--semantic-color-text-subtle);
  --color-text-on-primary: var(--semantic-color-text-on-primary);

  /* Map semantic background tokens */
  --color-background-body: var(--semantic-color-background-primary);
  --color-background-surface: var(--semantic-color-background-secondary);

  /* Map core spacing tokens to Tailwind's spacing scale */
  --spacing-1: var(--core-space-100);
  --spacing-2: var(--core-space-200);
  --spacing-3: var(--core-space-300);
  /*...and so on */
}
This configuration, inspired by patterns from , creates a clean and maintainable bridge between the two systems.   

Component Markup Example
With the above setup, a developer can build components using standard Tailwind utilities, completely abstracted from the underlying theming mechanism.

HTML

<!DOCTYPE html>
<html lang="en">
  <body data-brand="alpha" data-theme="light" class="bg-background-body text-text-body">
    
    <div class="p-4 bg-background-surface rounded-lg">
      <h1 class="text-lg font-bold">Welcome to Brand Alpha</h1>
      <p class="mt-2 text-text-muted">This component is styled using semantic tokens.</p>
      
      <button class="mt-4 px-4 py-2 bg-primary text-text-on-primary rounded-md">
        Primary Action
      </button>
    </div>

  </body>
</html>
When the application logic changes the attributes to data-brand="beta" and data-theme="dark", the browser will automatically apply the corresponding CSS variable definitions. The bg-primary utility will now resolve to Brand Beta's primary color for dark mode, and the component will re-theme itself instantly, without any changes to its markup or styles.

VI. Advanced Color Systems: OKLCH Palettes and Perceptual Guardrails
Modern design systems demand a more sophisticated approach to color than traditional RGB or HSL models can provide. The adoption of the OKLCH color space is a critical best practice for 2025, offering a foundation for creating perceptually uniform, accessible, and mathematically predictable color palettes. By combining OKLCH with perceptual difference metrics like Delta E 2000, teams can establish automated "guardrails" to enforce quality and consistency.

Constructing a Perceptually Uniform Palette with OKLCH
The OKLCH color model is designed to align with how humans perceive color, providing several key advantages over its predecessors :   

Perceptually Uniform Lightness (L): Unlike HSL, where a 50% lightness value for yellow appears dramatically brighter than for blue, the L channel in OKLCH is predictable. A change in L corresponds to a predictable change in perceived lightness, regardless of hue. This is revolutionary for accessibility and for programmatically generating themes.

Consistent Hue (H): Adjusting Lightness (L) or Chroma (C, i.e., colorfulness/saturation) does not cause unexpected shifts in hue, a common problem in other color spaces.

Smoother Gradients: Gradients interpolated in OKLCH space avoid the "muddy gray" midpoints often seen in RGB gradients, resulting in more vibrant and natural transitions.

Wide Gamut Support: OKLCH can express colors outside the standard sRGB gamut, allowing designs to leverage the richer, more vivid colors available on modern displays (like Display P3).   

A robust workflow for creating an OKLCH-based palette involves using specialized tools like oklch.com, atmos.style, or oklch-palette.vercel.app. The process is as follows:   

Define Brand Anchor Colors: Start by defining the key anchor colors for a brand (e.g., primary, secondary, accent) in the OKLCH space. Focus on getting the desired Hue (H) and a target Chroma (C).

Generate Scales by Manipulating Lightness: With the H and C values established, programmatically generate a full tonal palette (e.g., from shade 50 to 950) by varying only the L channel. This ensures that every color in the blue scale, for example, has the exact same hue and a similar level of colorfulness, with only the perceived lightness changing.

Gamut Correction: As L and C are adjusted, some colors may fall outside the target sRGB or P3 gamut. Tools will automatically "clip" or map these colors back into the nearest in-gamut equivalent, typically by reducing chroma until the color is displayable.

Implementing ΔL (Lightness) and ΔC (Chroma) Guardrails
While OKLCH provides a superior foundation, ensuring that color combinations are effective requires measuring the perceptual difference between them. The standard for this is the Delta E 2000 (CIEDE2000) formula, which calculates a single number representing the perceived difference between two colors. A ΔE value of ~1.0 is the just-noticeable difference, while values above 2-3 are readily apparent.   

The Delta E calculation is composed of three components: ΔL* (difference in lightness), ΔC* (difference in chroma), and ΔH* (difference in hue). These individual components are more powerful than the combined ΔE value for establishing design system guardrails. They allow for the creation of objective, automatable rules that replace subjective design feedback.   

Human perception of color difference is non-linear and context-dependent. A small numerical change in a dark, low-chroma color may be imperceptible, while the same numerical change in a bright, saturated color is obvious. Metrics like CIEDE2000 are designed to model this complex perceptual reality. By integrating these calculations into the design system's CI/CD pipeline, it becomes possible to enforce quality automatically. For example, a script can run whenever token files are changed, calculating the ΔL* and ΔC* between key color pairs and failing the build if they don't meet predefined thresholds. This transforms quality assurance from a manual, subjective process into an automated, data-driven one.   

Here are practical guardrails that can be implemented:

Interaction State Feedback: To ensure interactive elements provide clear feedback, enforce a minimum lightness difference between states.

Rule: The ΔL* between a button's default and hover state backgrounds must be at least 10.

Rationale: This guarantees a visible change in brightness upon interaction, which is a primary accessibility cue.

Visual Hierarchy: To differentiate between elements of varying importance, use chroma as a lever.

Rule: The ΔC* between a primary action button and a secondary action button must be at least 15.

Rationale: This ensures the primary button is perceptually more colorful and attention-grabbing, reinforcing its role in the visual hierarchy.

Readability of Muted Text: To prevent text from becoming illegible, set a minimum lightness difference against its background.

Rule: The ΔL* between color.text.subtle and color.background.primary must be at least 30.

Rationale: This complements standard contrast ratio checks (like WCAG or APCA) by ensuring a baseline level of perceptual lightness separation, preventing low-contrast text that might technically pass a ratio test but is still difficult to read.

By codifying these perceptual rules, a design system can proactively prevent common aesthetic and accessibility issues, ensuring a higher level of quality and consistency across all brands and themes.   

VII. Ensuring Universal Access: High-Contrast Theming and Forced-Colors Mode
A truly robust enterprise design system must prioritize accessibility not as an add-on, but as a core architectural principle. This involves creating dedicated high-contrast themes and, critically, ensuring full compatibility with operating system-level features like Windows High Contrast Mode, known in CSS as forced-colors mode.

Building an Accessible High-Contrast (HC) Theme
Beyond standard light and dark themes, a dedicated high-contrast (HC) theme should be a standard offering. This is not the same as forced-colors mode; rather, it is an author-defined theme that users can select within the application. It provides an experience that meets or exceeds enhanced accessibility standards.

This theme should be defined as another variation within each brand's token set (e.g., theme="hc"). Its implementation follows the same architectural pattern as light and dark modes, but with specific constraints on its palette:

Minimal Palette: The theme should use a very limited set of colors, typically pure black, pure white, and a single, highly saturated accent color (e.g., a bright yellow or blue) for interactive elements and focus indicators.

Enhanced Contrast: All text-on-background combinations must meet or exceed the WCAG 2.1 AAA contrast ratio of 7:1 for normal text and 4.5:1 for large text. This provides a significantly more readable experience for users with moderate visual impairments.   

Clear Focus States: Focus indicators must be extremely prominent, using thick, solid outlines in the accent color.

Mapping Semantic Tokens to CSS System Colors for forced-colors
The forced-colors media feature detects when a user has enabled an OS-level high-contrast mode. In this mode, the browser discards most of the author's specified colors and replaces them with a user-chosen, limited palette to ensure readability. Properties like background-image, box-shadow, and text-shadow are also forcibly removed.   

Simply allowing the browser to apply its default mappings can lead to a broken or confusing UI, as semantic distinctions are lost. For example, a subtle gray border and a primary blue button border might both be rendered as simple black, losing the visual cue of interactivity.

The best practice is to use the @media (forced-colors: active) media query to create a dedicated style block. Within this block, the semantic CSS variables generated by Style Dictionary are redefined to use standardized CSS System Color keywords. This allows the design system to map its semantic roles to the corresponding roles in the user's forced-color theme, preserving the UI's structure and intent. The prefers-color-scheme media query can even be nested inside to differentiate between light-on-dark and dark-on-light high-contrast themes.   

The following table provides a clear, actionable mapping from common semantic token roles to their appropriate CSS System Color keywords. This mapping is essential for ensuring a usable and respectful experience for users who rely on high-contrast modes.

Semantic Token Role	Example CSS Variable	forced-colors System Color	Purpose
Default Page Text	--semantic-color-text-default	CanvasText	For standard body text on the main background.
Default Page Background	--semantic-color-background-primary	Canvas	For the primary background of the application window.
Interactive Element Text	--semantic-color-text-interactive	ButtonText	For text on buttons and other interactive controls.
Interactive Element Border	--semantic-color-border-interactive	ButtonBorder	For the border of buttons and clickable elements.
Link Text	--semantic-color-text-link	LinkText	For all hyperlink text.
Visited Link Text	--semantic-color-text-link-visited	VisitedText	For hyperlinks that have been visited.
Selected Item Background	--semantic-color-background-selected	Highlight	For the background of selected text or items in a list.
Selected Item Text	--semantic-color-text-on-selected	HighlightText	For text that appears on top of a selected item's background.
Disabled Element Text	--semantic-color-text-disabled	GrayText	For text on disabled or inactive UI elements.

Export to Sheets
Accessibility & Contrast Test Matrix
To ensure that every brand and theme combination is fully accessible, a formal testing plan is required. This matrix serves as a comprehensive checklist, forcing the team to validate critical color pairings against multiple accessibility standards. It moves accessibility from a vague goal to a set of quantifiable, verifiable criteria. The inclusion of APCA (Accessible Perceptual Contrast Algorithm) scores provides a forward-looking metric that better aligns with human perception, even though it is not yet part of a formal WCAG recommendation.   

UI Element / Token Pairing	WCAG 2.1 AA (Pass/Fail)	WCAG 2.1 AAA (Pass/Fail)	APCA Lc Score (Target > Lc 60)	forced-colors Behavior (Verified)
text-default on background-primary	Pass	Pass	> Lc 75	Maps to CanvasText on Canvas
text-subtle on background-primary	Pass	Fail	> Lc 45	Maps to CanvasText on Canvas
text-on-primary on action-primary-default	Pass	Pass	> Lc 60	Maps to ButtonText on ButtonFace
border-interactive on background-primary	3:1 Pass (Non-text)	N/A	> Lc 30	Maps to ButtonBorder on Canvas
text-link on background-primary	Pass	Pass	> Lc 75	Maps to LinkText on Canvas
icon-default on background-primary	3:1 Pass (Non-text)	N/A	> Lc 30	Maps to CanvasText on Canvas

Export to Sheets
VIII. Systemizing Motion: A Minimalist Token Set for UI Animation
Motion, when used effectively, is a critical component of user experience, providing feedback, guiding attention, and expressing brand personality. However, without a systematic approach, animation can quickly become inconsistent, distracting, or even inaccessible. A modern design system must include motion tokens to provide a shared language for animation, just as it does for color and typography. The goal is to establish a minimal but effective set of tokens that covers the majority of UI animation needs without creating unnecessary complexity.   

Defining a Core Set of Duration and Easing Tokens
A lean and maintainable motion system can be built upon two core concepts: duration and easing.

Duration Scale: A simple, t-shirt-sized scale provides a limited but versatile palette for animation timing. This prevents arbitrary values and encourages consistency. A common and effective scale includes three to four options.   

duration.fast: 100ms - 150ms (for micro-interactions like hover states or toggle switches)

duration.moderate: 250ms - 300ms (for small components entering/exiting, like tooltips or dropdowns)

duration.slow: 400ms - 500ms (for large surface transitions, like modals or side panels)

Easing Curves: Easing defines the rate of change of an animation, giving it a natural, physical feel. Instead of using raw cubic-bezier() values, the system should provide semantic tokens that describe the purpose of the transition. The three fundamental curves cover most UI use cases :   

ease.in (Accelerate): Starts slow and ends fast. Ideal for elements exiting the screen, as the acceleration gives a sense of departure.

ease.out (Decelerate): Starts fast and ends slow. This is the most common curve for UI, used for elements entering the screen. The deceleration provides a gentle arrival and allows the user's eye to settle.

ease.in-out (Standard): Starts slow, accelerates, then slows down at the end. Best for elements that are moving from one point to another within the viewport, as it provides a smooth start and finish.

Semantic Naming and Application Guidelines
To elevate the motion system, it is best practice to classify motion by its intent, a model popularized by systems like Google's Material Design. A two-axis classification system based on Pace (derived from the duration scale) and Character provides clear guidance for designers and developers.   

Productive Motion: This character is for quick, efficient, and subtle transitions used in high-frequency, utilitarian components. It prioritizes responsiveness over flourish. It typically pairs moderate or fast durations with a standard ease-in-out or ease-out curve.

Use Cases: Toggling a switch, opening a dropdown menu, showing a tooltip.

Expressive Motion: This character is for more pronounced, significant moments in the user journey. It uses slightly longer durations and more emphasized easing curves to draw attention and create a more engaging, brand-aligned experience.

Use Cases: Opening a modal dialog, full-page transitions, or hero animations.

This semantic framework helps ensure that motion is applied meaningfully. It prevents expressive, slow animations from being used on a simple checkbox, which would feel sluggish, and ensures that significant transitions are given the appropriate visual weight. The system should also include guidance for reduced motion, respecting the prefers-reduced-motion media query by disabling or cross-fading animations for users who are sensitive to motion.   

Table 5: Minimal Motion Token Set
The following table provides a concrete, ready-to-use set of motion tokens that forms the basis of a robust and scalable motion system. It includes both primitive values and semantic combinations, along with clear guidance on their intended application.

Token Name	Value	Intended Use Case
Duration Primitives		
motion.duration.fast	150ms	Micro-interactions (e.g., hover, toggle).
motion.duration.moderate	300ms	Small component transitions (e.g., dropdown, tooltip).
motion.duration.slow	500ms	Large surface transitions (e.g., modal, side panel).
Easing Primitives		
motion.easing.accelerate	cubic-bezier(0.4, 0, 1, 1)	For elements exiting the screen permanently.
motion.easing.decelerate	cubic-bezier(0, 0, 0.2, 1)	For elements entering the screen. The most common UI curve.
motion.easing.standard	cubic-bezier(0.4, 0, 0.2, 1)	For elements moving from point to point within the screen.
Semantic Combinations		
motion.transition.productive	300ms cubic-bezier(0, 0, 0.2, 1)	Default transition for most interactive UI components.
motion.transition.expressive	500ms cubic-bezier(0.4, 0, 0.2, 1)	Transition for large, significant UI moments.

Export to Sheets
IX. Bridging the Gap: Detecting and Mitigating Figma-to-Code Drift
One of the most persistent challenges in maintaining a design system is "drift"—the gradual and often unintentional divergence between the design source of truth in Figma and the implemented components in code. An effective multi-brand system must address this challenge head-on with robust governance, automated workflows, and proactive detection strategies.

Establishing a Single Source of Truth (SSoT)
While design work is authored in tools like Figma, the canonical single source of truth for design tokens must be a set of version-controlled files (e.g., JSON) within a Git repository. Figma serves as the user-friendly authoring environment, but the structured data in Git is what feeds the build pipeline and is consumed by engineering. This distinction is critical; treating Figma as the SSoT creates a dependency on its proprietary format and API, whereas a Git-based SSoT is tool-agnostic, auditable, and integrates seamlessly with development workflows.   

Automated Workflows and Tooling
Manual handoffs are the primary cause of drift. The key to mitigation is a fully automated, bidirectional (or at least one-way-from-design) synchronization pipeline.

Tokens Studio for Figma: This plugin is the essential bridge between the design environment and the code repository. It allows designers to manage a complex, multi-tiered token architecture (including aliasing, themes, and modes) directly within Figma. Its most powerful feature is the ability to sync token changes directly to a specified Git repository (e.g., GitHub, GitLab), automatically creating a new branch and a pull request. This action becomes the trigger for the entire automation pipeline.   

CI/CD Pipeline (e.g., GitHub Actions): A robust CI/CD pipeline should be configured to act on these token-related pull requests. A typical workflow includes:

Trigger: A push is made to the tokens branch (e.g., feat/update-brand-colors) by Tokens Studio.

Validation: A job runs to lint the JSON files and validate them against the DTCG schema.

Build: The style-dictionary build command is executed, generating all platform-specific outputs (CSS, JS, etc.).

Visual Review: The generated assets are used to build a preview deployment of the component library (e.g., Storybook). This preview is automatically posted as a comment on the pull request, allowing reviewers to see the exact visual impact of the token changes.

Publish: Upon merging the pull request to the main branch, a final job automatically versions and publishes the updated token package to a registry (e.g., npm, AWS CodeArtifact).

Common Pitfalls and Governance
Automation must be paired with clear governance to prevent misuse and maintain system integrity. Common pitfalls include:

Detached Values: Designers applying hardcoded color or spacing values in Figma instead of using the established variables.   

Undocumented Changes: One-off adjustments made directly in component code that are not reflected back in the token SSoT.

Inconsistent Naming: The creation of new, ad-hoc tokens that do not follow the established architectural conventions.   

A formal governance process is required, where any proposed change to the token system (addition, modification, or deprecation) must be submitted, reviewed by a cross-functional "design system council," and then implemented through the automated pipeline.

Strategies for Proactive Drift Detection
While a strong workflow prevents most drift, automated checks are necessary to catch what slips through. These checks should be integrated directly into the CI pipeline to act as a safety net.

Token Snapshot Testing: This technique involves creating a "snapshot" of the expected token values for a given build. On every pull request that modifies component code, a CI job can run the Style Dictionary build and compare the resulting token object against the committed snapshot. If there is a mismatch (e.g., a developer manually changed a value in a component file), the test fails, forcing the developer to either revert their change or formally update the token SSoT.

Static Analysis (Linting): Custom linting rules are a powerful tool for enforcing best practices at the code level. Implement custom ESLint or Stylelint rules that flag the use of magic numbers and hardcoded values (e.g., hex codes like #FFF or pixel values like 16px) within component styling files. When a developer attempts to commit code with a hardcoded value, the linter will fail, instructing them to use the appropriate CSS variable derived from a design token.

Automated Visual Regression Testing: This is the ultimate and most effective strategy for drift detection. Using a service like Chromatic (for Storybook) or Percy, a pixel-perfect screenshot is taken of every component in every state for every brand and theme. On each pull request, a new set of screenshots is generated and compared against the baseline from the main branch. Any visual deviation, no matter how small—whether caused by a token error, a CSS regression, or an incorrect token application—is flagged for manual review. This provides the highest possible confidence that the design intent is perfectly preserved in the final coded implementation, effectively eliminating visual drift.

X. Conclusion and Strategic Recommendations
The architecture detailed in this report represents a holistic and forward-looking approach to building and maintaining multi-brand design systems. By integrating a standards-based token format (DTCG), a powerful transformation engine (Style Dictionary v4), and a modern front-end framework (Tailwind CSS v4), organizations can construct a UI infrastructure that is scalable, maintainable, and highly efficient. The core principle of this unified architecture is the strict separation of concerns, achieved through a multi-layered token structure and a "tokens-only" theming strategy. This ensures that brand and theme logic are fully decoupled from component implementation, enabling rapid development and consistent user experiences across a diverse product portfolio.

Furthermore, the integration of advanced color science with OKLCH, the implementation of perceptual difference guardrails, and a rigorous approach to accessibility through dedicated high-contrast themes and forced-colors mode support, elevates the system beyond mere visual consistency to one of true quality and inclusivity. The long-term vision for this architecture is one of future-proof adaptability. Because it is founded on platform-agnostic tokens and standard web technologies, the system is not tied to any single front-end framework. It can evolve to support new platforms—from native mobile to emerging realities like AR/VR and voice interfaces—simply by adding new transforms and formats to the Style Dictionary pipeline, without altering the core design decisions.   

For an organization seeking to implement this system, the following actionable recommendations provide a clear path forward:

Establish a Formal Token Architecture: Before writing any code, collaboratively define and document a multi-tiered token structure (Global, Brand, Semantic). Run workshops with both designers and developers to agree on a clear and scalable naming convention.   

Adopt a Git-Based Single Source of Truth: Designate a Git repository as the canonical home for all design token JSON files. Configure tools like Tokens Studio to push changes from Figma directly to this repository, initiating the automated workflow.

Implement a Dynamic Build Pipeline with Style Dictionary v4: Invest in creating a dynamic sd.config.mjs build script that can iterate through all brand and theme combinations, generating a complete set of scoped CSS custom properties as its primary output.

Enforce a "Tokens-Only" Component Contract: Mandate that all components consume styles exclusively from the semantic token layer. Prohibit any brand- or theme-specific logic within component code. Use static analysis and code reviews to enforce this critical boundary.

Integrate with Tailwind CSS v4 via an Adapter Layer: Use Tailwind's @theme directive to create a lightweight mapping between the design system's semantic CSS variables and Tailwind's utility classes. Avoid generating Tailwind-specific syntax from Style Dictionary.

Automate Quality and Drift Detection: Integrate static analysis (linting for hardcoded values), token snapshot tests, and comprehensive visual regression testing into the CI/CD pipeline. Make these checks mandatory for merging code to proactively prevent design-to-code drift.

Prioritize a Data-Driven Approach to Color and Accessibility: Build color palettes in the OKLCH color space. Codify perceptual difference guardrails (ΔL*, ΔC*) as automated checks in the build process. Implement and test a full accessibility suite, including a high-contrast theme and forced-colors mode support, using a formal test matrix.


Sources used in the report

designsystemscollective.com
The Evolution of Design System Tokens: A 2025 Deep Dive into Next-Generation Figma Structures | by Claus Nisslmüller UX & Brand Designer
Opens in a new window

southleft.com
Building Multi-Brand Design Systems: The Developer's Perspective | Southleft, LLC
Opens in a new window

designsystemscollective.com
Style Dictionary Is the Design-Tech Bridge I Was Always Missing | by Martin Metodiev • Mev
Opens in a new window

medium.com
Multi-Brand Theming in a Single Codebase: A Step-by-Step Guide | by Vivek Malhan
Opens in a new window

thedesignsystem.guide
Design tokens - The Design System Guide
Opens in a new window

help.figma.com
Update 1: Tokens, variables, and styles – Figma Learn - Help Center
Opens in a new window

medium.com
You don't know CSS: Variables + Theming | by Bryce Snyder | Medium
Opens in a new window

developer.mozilla.org
Using CSS custom properties (variables) - MDN
Opens in a new window

css-tricks.com
CSS Custom Properties Guide
Opens in a new window

alwaystwisted.com
Creating Multiple Themes with Style Dictionary | Always Twisted
Opens in a new window

reddit.com
3-tier design token system : r/DesignSystems - Reddit
Opens in a new window

youtube.com
What are design tokens and aliasing? - YouTube
Opens in a new window

medium.com
Design Tokens: Building Your Foundation (Part 2) | by Maciej Balasiński | Medium
Opens in a new window

thesigma.co
How to Build a Multi-Brand Design System with Tokens - Sigma ...
Opens in a new window

m3.material.io
Design tokens – Material Design 3
Opens in a new window

github.com
vic-k-7/styled: Multi branded styled components + style dictionary - GitHub
Opens in a new window

terrazzo.app
DTCG Tokens - Terrazzo
Opens in a new window

designtokens.fyi
DTCG - designtokens.fyi
Opens in a new window

cobalt-ui.pages.dev
tokens.json Manifest - Cobalt
Opens in a new window

styledictionary.com
Design Tokens Community Group | Style Dictionary
Opens in a new window

github.com
Version 4 documentation · Issue #1279 · style-dictionary/style-dictionary - GitHub
Opens in a new window

tokens.studio
Style Dictionary V4 release plans | Tokens Studio
Opens in a new window

app.codemod.com
styledictionary/4/instantiating-style-dictionary - Codemod Registry
Opens in a new window

github.com
style-dictionary/style-dictionary: A build system for creating cross-platform styles. - GitHub
Opens in a new window

styledictionary.com
Design Tokens - Style Dictionary
Opens in a new window

tailwindcss.com
Tailwind CSS v4.0
Opens in a new window

wawand.co
Blog: Multiple Portals, One Codebase: Scalable Theming with Tailwind v4 | Wawandco
Opens in a new window

tailwindcss.com
Functions and directives - Core concepts - Tailwind CSS
Opens in a new window

simonswiss.com
Tailwind CSS v4: Multi-Theme Strategy | simonswiss
Opens in a new window

tailwindcss.com
Theme variables - Core concepts - Tailwind CSS
Opens in a new window

github.com
[v4] Best method to use CSS variables for multiple themes? · tailwindlabs tailwindcss · Discussion #15600 - GitHub
Opens in a new window

evilmartians.com
OKLCH in CSS: why we moved from RGB and HSL - Evil Martians
Opens in a new window

opentutordesignschool.com
Unlocking Vibrant Web Design: A Deep Dive into OKLCH Colors
Opens in a new window

desktopofsamuel.com
OKLCH, explained for designers | Samuel Wong — Hong Kong UI/UX Designer
Opens in a new window

oklch.fyi
OKLCH Color Picker, Generator and Converter – Create Unique and Uniform Color Palettes for Your App
Opens in a new window

oklch-palette.vercel.app
OKLCH Color Picker & Converter
Opens in a new window

atmos.style
LCH and OKLCH color tool | Create accessible color palettes - Atmos.style
Opens in a new window

oklch.com
OKLCH Color Picker & Converter
Opens in a new window

viewsonic.com
What Is Delta E? And Why Is It Important for Color Accuracy? - ViewSonic Library
Opens in a new window

printing.org
Dissecting Delta E and the Mathematical Difference Between Colors
Opens in a new window

zschuessler.github.io
Delta E 101
Opens in a new window

lovibond.com
Delta L*C*h* colour difference - Lovibond
Opens in a new window

xrite.com
Tolerancing Part 3: Color Space vs. Color Tolerance - X-Rite
Opens in a new window

pac.gr
A Guide to Understanding Color Communication Part 3
Opens in a new window

programmingdesignsystems.com
Perceptually uniform color spaces - Programming Design Systems
Opens in a new window

arxiv.org
[1211.5556] Improving Perceptual Color Difference using Basic Color Terms - arXiv
Opens in a new window

danielleszafir.com
Modeling Color Difference for Visualization Design - Danielle Szafir
Opens in a new window

uxdesign.cc
Designing a scalable and accessible color system for your design system - UX Collective
Opens in a new window

nightingaledvs.com
Creating a Design System to Prevent Problematic Colour Pairings - Nightingale
Opens in a new window

goodpractices.design
Colour contrast | Design good practices
Opens in a new window

section508.gov
Accessibility Bytes No. 2: Color Contrast - Section508.gov
Opens in a new window

cssence.com
Forced Colors Mode strategies - CSSence.com
Opens in a new window

developer.mozilla.org
forced-colors - CSS - MDN - Mozilla
Opens in a new window

contrast.tools
Contrast tools
Opens in a new window

git.apcacontrast.com
APCA in a Nutshell
Opens in a new window

github.com
The missing introduction to APCA - GitHub
Opens in a new window

typefully.com
WCAG 3 and APCA | Dan Hollick - Typefully
Opens in a new window

designsystemscollective.com
Not Just Colors and Fonts: Why Motion Tokens Belong in Every Modern Design System
Opens in a new window

spectrum.adobe.com
Design tokens - Spectrum, Adobe's design system
Opens in a new window

carbondesignsystem.com
Motion - Carbon Design System
Opens in a new window

fluent2.microsoft.design
Motion - Fluent 2 Design System
Opens in a new window

seeds.sproutsocial.com
Motion - Sprout Social's Seeds
Opens in a new window

m3.material.io
Motion – Material Design 3
Opens in a new window

m3.material.io
Easing and duration – Material Design 3
Opens in a new window

reddit.com
What are you using to sync Figma with the rest of the design system? - Reddit
Opens in a new window

thedesignsystem.guide
Managing multi-brand design systems
Opens in a new window

docs.tokens.studio
Style Dictionary + SD Transforms - Tokens Studio for Figma
Opens in a new window

intodesignsystems.medium.com
Design Tokens Workflow in Figma — A practical guide | by Into D