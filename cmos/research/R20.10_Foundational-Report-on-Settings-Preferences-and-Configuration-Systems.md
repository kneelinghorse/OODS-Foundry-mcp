The Canonical Data Model: A Foundational Report on Settings, Preferences, and Configuration Systems
I. Executive Summary and Strategic Recommendations
A. Mission Objective and Core Findings
This report analyzes and documents the canonical data model for Settings, Preferences, and Configuration (S/P/C) systems, synthesizing patterns from over 20 representative platforms, including feature management systems, SaaS applications, and infrastructure configuration tools.

The primary finding of this analysis is that a single, monolithic "canonical model" to manage all configuration is an anti-pattern. The requirements for user-facing preferences (e.g., theme, language), critical enterprise settings (e.g., SSO, security policy), and dynamic feature flags (e.g., gradual rollouts) are fundamentally divergent.

B. The "Three-Service" Canonical Model (Strategic Recommendation)
Attempting to build one system to solve all configuration use cases will result in a solution that is complex, non-performant, brittle, and insecure. The true canonical solution is a federated architecture comprising distinct, specialized services, each optimized for its specific problem domain.

We recommend a federated architecture composed of three distinct services:

The User Preference Service: Manages user-specific, high-read-frequency, low-stakes settings (e.g., theme, language, timezone, notification preferences). The canonical storage pattern for this service is a JSONB column adjacent to the user record, offering flexibility and high performance.   

The Enterprise Configuration Service: Manages high-stakes, low-velocity, hierarchically-scoped settings (e.g., SSO, billing rules, security policies, role-based access control). The canonical model for this service is relational, emphasizing deep auditing, strong typing, and rigid-hierarchy overrides.   

The Feature Management Service: Manages dynamic, high-velocity, real-time feature flags and rollouts. The canonical model is a specialized, high-speed evaluation engine that operates on a "Context" object, optimized for complex targeting rules rather than simple storage.   

C. Rationale for the Federated Model
The conclusion that a federated model is the only viable canonical solution is based on the contradictory nature of the requirements:

Observation: The research shows vastly different requirements. User preferences are dynamic, numerous, and bound to a user. Enterprise settings are structured, auditable, and bound to an organization or repository. Feature flags are high-speed evaluation rules that change daily.   

Contradiction: A single data model cannot efficiently serve all three. A simple key-value store like HashiCorp Consul is ideal for service discovery but is untyped and too simple for application configuration. A rigid relational model for SSO  is too slow and inflexible for dynamic user preferences. A JSONB blob for user preferences  lacks the per-field auditing and strict schema required for enterprise security settings.   

Synthesis: Therefore, attempting to build one "canonical system" to store all configuration will fail. The only "canonical" answer is to acknowledge these different domains and build specialized services. These services can be unified at the API gateway or in a client-side SDK, but their backend models must remain distinct and optimized. This report will define the canonical model for each of these three services.

D. Key Pillars of the Canonical Model
This report is structured around four key pillars that emerged from the analysis:

The "Context" Primitive: The universal data model for targeting and scoping, replacing rigid, fixed hierarchies.

JSON Schema: The "lingua franca" for configuration, used for both data validation and automatic UI generation.

JSONB over EAV: The definitive and non-negotiable storage pattern for dynamic, user-facing preference data.

The Channel x Event-Type Matrix: The canonical taxonomy for all modern notification preference systems.

II. The Canonical Model for General Configuration and Preferences
The smallest indivisible unit of configuration is a single setting or "parameter." The maturity of a configuration system can be measured by how it defines, types, and validates this base unit.

A. The Base Unit: From Key-Value to Typed Parameters
Level 0: The Untyped Key-Value Model The simplest form of configuration storage is a basic key-value store, epitomized by tools like HashiCorp Consul.   

Data Model: A key (string) and a value (an opaque string or blob).

Namespacing: Keys often use / as a delimiter to create a pseudo-hierarchy (e.g., customer/service_area/12345). However, this is merely a convention; the system treats it as a single flat key.   

Weakness: This model is simple but brittle. It pushes all responsibility for type casting (e.g., converting "true" to a boolean) and validation to the client application. This is a common source of bugs, such as when a client expects a number but receives a string, leading to type coercion errors.   

Level 1: The Typed Parameter Model The baseline for a true configuration system is the introduction of explicit types. The Firebase Remote Config model is a canonical example.   

Data Model: The system stores a parameters map. Each key in this map points to a parameter object, which contains a defaultValue (which itself is an object containing a value) and a valueType.   

Supported Types: The valueType is explicitly defined in the schema. Supported types are typically String, Boolean, Number, and JSON.   

Significance: By explicitly defining a type in the schema, the system moves validation from the client to the configuration service itself. This is the first and most important step in preventing configuration-related bugs and establishing a contract with consumers.

B. Advanced Validation: The "Level 2" Model (Schema-Driven)
The next level of maturity is to move beyond simple primitive types to complex, semantic validation.

Data Model: AWS AppConfig formalizes this "Level 1" model by introducing Validators. A validator provides a "syntactic or semantic check" to ensure configuration data is correct before it can be deployed.   

The JSON_SCHEMA Validator: The most powerful and standard pattern is the JSON_SCHEMA validator. The AppConfig API allows a user to attach a validator of Type: "JSON_SCHEMA" and provide the full schema definition as the Content.   

Significance: This is a critical architectural pattern. A JSON_SCHEMA  can replace and formalize the simple valueType of Firebase. Instead of valueType: "Number", a JSON Schema can define a much richer rule: { "type": "number", "minimum": 0, "maximum": 100 }. This provides semantic validation at the system level.   

C. Constrained Configuration (The "Level 3" Model)
As an alternative to writing full JSON Schemas, some platforms provide "batteries-included" constraints for common use cases. AWS AppConfig's internal schema for feature flags (AWS.AppConfig.FeatureFlags) demonstrates this by supporting first-class constraints like Regular Expression, Enum, Minimum, and Maximum for String, Number, and array types. This simplifies the process for developers who need common validation patterns without the complexity of writing a full JSON Schema.   

D. Canonical Configuration Schema (Synthesized)
Based on this analysis, the following JSON Schema represents a canonical definition for a single configuration item. This schema is designed to be stored in a "configuration catalog" database.

JSON
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "CanonicalConfigurationDefinition",
  "description": "Defines a single configuration item in the catalog, including its type, default, and validation rules.",
  "type": "object",
  "properties": {
    "key": {
      "type": "string",
      "description": "The unique, machine-readable key (e.g., 'ui.theme.dark_mode').",
      "pattern": "^[a-z0-9_\\.:]+$"
    },
    "namespace": {
      "type": "string",
      "description": "A grouping for the key (e.g., 'billing', 'ui.themes')."
    },
    "description": {
      "type": "string",
      "description": "A human-readable description of what this setting controls."
    },
    "valueType": {
      "type": "string",
      "description": "The simple primitive type of the value (Firebase-style).",
      "enum": ["string", "number", "boolean", "json", "enum"]
    },
    "defaultValue": {
      "type": ["string", "number", "boolean", "object", "array"],
      "description": "The hard-coded default value for this setting."
    },
    "metadata": {
      "type": "object",
      "description": "Metadata to control UI generation and visibility.",
      "properties": {
        "visibility": {
          "enum": ["user", "team", "org", "system"],
          "description": "Defines the scope this setting is intended for."
        },
        "ui_label": {
          "type": "string",
          "description": "The label for this setting in an auto-generated admin UI."
        },
        "ui_helper_text": {
          "type": "string",
          "description": "Helper text for the admin UI."
        }
      }
    },
    "validationSchema": {
      "type": "object",
      "description": "A full JSON Schema (AWS AppConfig-style) for advanced validation."
    },
    "enum_values": {
      "type": "array",
      "items": { "type": "string" },
      "description": "If valueType is 'enum', this provides the list of valid values."
    }
  },
  "required":
}

E. Configuration Type System Maturity Model
The following table provides an actionable maturity model for selecting a configuration validation strategy.

Level	Approach	Example Platform(s)	Pros	Cons
Level 0	Untyped Key-Value	
HashiCorp Consul 

Dead simple, fast, flexible.	
No type safety, brittle, pushes all validation to clients, high risk of bugs.

Level 1	Simple Typed Parameters	
Firebase Remote Config 

Basic type safety (string, number, bool), prevents simple coercion bugs.	Cannot enforce semantic rules (e.g., min/max, regex, enums).
Level 2	JSON Schema Validation	
AWS AppConfig 

Extremely powerful, industry-standard, provides full syntactic and semantic validation.	More complex to author, requires JSON Schema expertise, slight overhead.
Level 3	First-Class Constraints	
AWS AppConfig (Feature Flags) 

"Batteries-included," easy to use for common cases (enums, min/max).	Platform-specific, less flexible or standard than full JSON Schema.
  
III. The Hierarchical Scoping Model: From Tenancy to Context
Configuration is rarely global. It must be scoped to different entities, such as users, teams, and organizations. The evolution of this scoping model is one of the most significant findings of this report.

A. Baseline: Single-Tenant and Basic Multi-Tenancy
Most modern Software-as-a-Service (SaaS) applications are multi-tenant. The most common and foundational pattern for data isolation is "Shared Database, Shared Schema," where a tenant_id column is added to every data table. When applied to configuration, a tenant_settings table with a tenant_id foreign key represents the most basic form of Organization-level scoping.   

B. Advanced Pattern: Hierarchical Precedence (The Salesforce Model)
Enterprise-grade systems require a more complex, multi-layered hierarchy of overrides. The Salesforce model provides a canonical example of this "classic" approach.

Data Model: The system starts with Organization-Wide Defaults (OWD), which set the baseline access and configuration for all users.   

Precedence Chain: This baseline can then be overridden at multiple, fixed levels. The explicit hierarchy is: organization, profile (a group of users), or user.   

Resolution Logic: To resolve a setting for a given user, the system must query for a value at each level in a specific order of precedence, a "precedence chain":

Does a User-level setting exist? If yes, return.

Does a Profile/Team-level setting exist? If yes, return.

Does an Organization-level setting exist? If yes, return.

Return the Global Default.

Weakness: This model is powerful but rigid. The hierarchy (user > profile > org) is hard-coded into the database schema and the application's query logic. If a new business entity, such as "Project," is introduced, the entire model, database, and all queries must be changed to accommodate it. This rigidity is its primary weakness.

C. The Unified "Context" Primitive (The Modern Solution)
Modern feature management platforms have converged on a more flexible and powerful primitive that replaces this rigid hierarchy: the Context.

Data Model: LaunchDarkly explicitly defines the "Context" as the modern replacement for its legacy "User" object. A Context is a generic data object that represents any entity involved in an evaluation.   

Key Components:

kind: A string that defines the type of entity, such as user, organization, device, or application.   

key: A unique identifier for the entity of that kind (e.g., a database ID).   

attributes: A flat map of custom key-value pairs (e.g., email, plan, region, gymMember: true).   

Multi-Kind Contexts: A single Context can represent multiple kinds simultaneously, capturing complex relationships like a "user" within an "organization".   

The adoption of the Context primitive fundamentally changes the problem of scoping.

The "classic" model  treats scoping as a hierarchical database lookup (e.g., COALESCE(user_setting, org_setting)).   

The "modern" model  treats scoping as a rule evaluation problem.   

The classic "User > Org > Global" precedence chain is not discarded; it is simply re-implemented as an ordered list of rules within a feature flag's targeting engine:

Rule 1 (User Scope): IF context.kind == "user" AND context.key == "user-123" THEN serve variation_A.

Rule 2 (Org Scope): IF context.kind == "organization" AND context.key == "org-abc" THEN serve variation_B.

Fallthrough (Global Scope): Serve variation_C.

This rule-evaluation logic is identical to that of a feature flag. This leads to a critical conclusion: hierarchical configuration scoping and feature flag targeting are the same problem. The Context primitive is the canonical data model that solves both simultaneously, replacing the rigid, hard-coded hierarchy with a flexible, ordered rule-evaluation engine.

D. Platform Case Studies: Enterprise Configuration Models
Stripe (Configuration as Capabilities): Stripe's model is a masterclass in domain-specific configuration. The Account object  has a settings sub-object for dashboard display and payout schedules. The v2 Accounts API  abstracts this further. An account has Configurations (e.g., customer, merchant, recipient) that define its persona. Each Configuration then has Capabilities (e.g., card_payments, transfers) that define what it can do. This is a "config-driven-capability" model where the configuration defines the account's entire feature set.   

GitHub/Slack (Configuration as Policy): These platforms model organization-level configuration as policy and access control. GitHub's code security configurations are defined at the enterprise level and then attached to specific repositories. This is a "policy attachment" model. Slack uses SCIM schemas for Users and Groups  to define org-level attributes, which are then used for provisioning and access control.   

E. Configuration Scoping and Resolution Models
Model	Description	Resolution Logic	Example Platforms
Simple Tenancy	A tenant_id column on all tables.	SELECT * FROM settings WHERE tenant_id =?	
Basic SaaS Apps 

Rigid Hierarchy (OWD)	Hard-coded precedence chain (e.g., User, Profile, Org).	COALESCE(user_setting, team_setting, org_setting, global_default)	
Salesforce 

Context-Rule-Based	Flexible, ordered rule evaluation against a Context object.	for rule in rules: if rule.matches(context): return rule.value	
LaunchDarkly 

Policy Attachment	Centralized definitions are explicitly linked to resources.	SELECT * FROM config WHERE id = repo.attached_config_id	
GitHub 

  
IV. Domain Deep Dive: Feature Flag (FF) Systems
Analysis of market-leading platforms like LaunchDarkly , Unleash , and Split.io  reveals a highly convergent data model for feature management. This model is built for high-speed evaluation against a Context.   

A. The Canonical Feature Flag Data Model
A feature flag is composed of two primary structures: the top-level flag definition and its per-environment configurations.

Top-Level Flag (FeatureFlag): Defines the flag itself.

key: (string) The unique, machine-readable key (e.g., alternate.page).   

name: (string) The human-readable name.   

kind: (string) The type of flag. boolean is standard. multivariate is used for string, number, or JSON variations.   

variations: (array) An array of the possible values this flag can serve. For a boolean, this is typically [{value: true}, {value: false}].   

tags: (array) Metadata for organizing flags.   

defaults: (object) An object specifying the onVariation (index) and offVariation (index) to serve by default.   

Environment-Specific Configuration (FlagEnvironment): A flag has a distinct configuration for each environment (e.g., "production," "staging"). This is the core of the evaluation engine.   

on: (boolean) The master on/off switch for this flag in this environment.   

targets: (array) A list of individual context keys (e.g., user-key-123) to serve a specific variation. This is for explicit, individual targeting.   

rules: (array) An ordered list of targeting rules. This list is the core of the engine.   

fallthrough: (object) The "default rule" that is applied if no targets or rules match a given context.   

offVariation: (integer) The index of the variation to serve if on: false.   

B. The Targeting Engine: Rules, Clauses, and Matchers
A "Rule" defines who gets a specific variation.

LaunchDarkly Model: A rule contains one or more clauses. A clause is a simple object: { attribute, op, values, contextKind, negate }. A common example is targeting users with a specific email domain: attribute: "email", op: "endsWith", values: [".edu"].   

Split.io Model: A rule has a condition which is composed of matchers. A matcher has a type (e.g., in_segment, equals), an attribute to check, and a value to check against.   

The underlying concept is identical: a rule is a boolean expression evaluated against the attributes of the Context object. The canonical model is IF (clauses) THEN SERVE (variation | rollout).

C. Rollout and Evaluation Logic
Percentage Rollouts: The fallthrough rule  is often used for percentage-based rollouts. The LaunchDarkly rollout object contains a variations array, where each entry has a variation (index) and a weight. A critical detail is that this weight is an integer up to 100,000, not 100. This allows for rollouts with a 0.001% granularity (e.g., weight: 1), which is essential for high-traffic "canary" testing.   

Gradual/Timed Rollouts: Complex rollouts (e.g., "10% on Monday, 20% on Tuesday") are handled in two ways:

Declarative: Using time as a targetable attribute. Split.io allows rules to target system time.   

Orchestrated: An external script or CI/CD job  makes scheduled PATCH requests to the flag's API endpoint, programmatically updating the defaultRule or rollout weights over time.   

D. The "Lite" Model: Firebase Remote Config
Firebase Remote Config provides an alternative, parameter-centric model for feature flagging.

Data Model: The LaunchDarkly model is Flag -> Environment -> Rule -> Context. The flag is the center of the universe. Firebase's model is Template -> Parameter -> Condition. The parameter is the center of the universe.   

Structure:

A single template contains a top-level parameters map and a top-level conditions list.   

Each parameter has a defaultValue and a conditionalValues map.   

The conditionalValues map's keys are the names of the conditions defined elsewhere (e.g., welcome_message.conditionalValues.tenPercent.value = "Welcome").   

The conditions are defined separately with a name and an expression (e.g., name: "android_english", expression: "app.id == 'com.example' && device.language == 'en'" ).   

Architectural Implication: The Firebase model  is simpler for "config-as-code," as all parameters and conditions for an app exist in a single, versioned template. The LaunchDarkly model  is more powerful for team-based management, as the lifecycle and targeting of each flag can be managed individually.   

E. Feature Flag Platform Model Comparison
Platform	Core Object	Targeting Model	Context Model	Rollout Granularity	Key Differentiator
LaunchDarkly	
FlagEnvironment 

Ordered rules with clauses 

Context object, multi-kind 

0.001% (1/100,000) 

Most powerful Context model, treating scoping and targeting as one.
Unleash	
Feature (with environments) 

activationStrategies per environment	Unleash Context (user, session, remoteAddress)	0-100%	
Open-source , SDK-first evaluation, privacy-focused.

Split.io	
Feature flag definition 

Ordered rules with matchers 

TrafficType (e.g., 'user', 'account') 

0-100%	
Strong integration with event tracking  for experiment metrics.

Firebase RC	
Parameter 

conditionalValues map pointing to shared conditions 

Implicit (app.id, app.version, userProperty) 

0-100% (Percentage rule) 

Simple, unified template for all config ; parameter-centric.

  
V. Domain Deep Dive: Notification Preference Taxonomy
Notification preferences are a specialized, user-facing subset of configuration. Analysis of platform documentation and system design guides reveals a universal two-axis model.

A. A Taxonomy of Notification Preferences (The Two-Axis Model)
A robust preference system must allow users to control what they are notified about and where they are notified.

Axis 1: Channel (The "Where"): This represents the medium of delivery. The canonical channels are:

In-app messages (modals, banners, or in-app inboxes)    

Push notifications (to mobile or web clients)    

Email    

SMS    

Axis 2: Category/Event Type (The "What"): This represents the business-domain-specific type of notification. The Android operating system's NotificationChannel system is a key insight, as it forces developers to "create a channel for each type of notification you need to send". These types map to business logic, with common examples being:   

Transactional (e.g., order confirmations, receipts)    

Promotional (e.g., marketing, discounts)    

Social (e.g., mentions, comments)

System-generated alerts (e.g., password resets)    

A simple list of booleans is insufficient. A user must be able to opt-out of "Promotional" push notifications while still receiving "Transactional" push notifications.

B. Canonical Preference Schema (Proposed)
The canonical data model for storing these preferences is a nested JSON object, which is perfectly suited for a JSONB column (see Section VI). This model provides global, per-channel, and fine-grained controls.

JSON
{
  "version": 1,
  "global_opt_out_all": false,
  "channels": {
    "email": { "enabled": true, "global_opt_out": false },
    "push": { "enabled": true, "global_opt_out": false },
    "sms": { "enabled": false, "global_opt_out": true }
  },
  "categories": {
    "transactional": {
      "description": "Order confirmations, receipts, and account alerts.",
      "channels": {
        "email": { "enabled": true, "locked": true },
        "push": { "enabled": true, "locked": false },
        "sms": { "enabled": true, "locked": false }
      }
    },
    "promotional": {
      "description": "Marketing, new features, and special offers.",
      "channels": {
        "email": { "enabled": true, "locked": false },
        "push": { "enabled": false, "locked": false },
        "sms": { "enabled": false, "locked": true }
      }
    },
    "social_mentions": {
      "description": "When someone @mentions you in a comment.",
      "channels": {
        "email": { "enabled": true, "locked": false },
        "push": { "enabled": true, "locked": false }
      }
    }
  }
}
This schema is powerful because it allows for:

A top-level global_opt_out_all.

A per-channel global opt-out (e.g., "no push notifications ever").

Default on/off status at the finest-grained level (category x channel).

A locked attribute. This is a critical system-level control, allowing the platform to enforce policy (e.g., "you must receive transactional emails," or "we will never send promotional SMS").   

C. Implementation Architecture (The Filter Pattern)
The notification preference object is not queried by the sender of the notification. Instead, it is used as a filter by a centralized notification service.   

This "preference-as-a-filter" model is the canonical architecture :   

An upstream service (e.g., OrdersService) fires an event: POST /send {userId, eventType: "transactional", content: "..."}.   

The central NotificationService receives this request.

It first fetches the UserPreference object for that userId from the database.   

It then evaluates the object: "For eventType=transactional, which channels are enabled and not globally disabled?"

It finds email: { enabled: true }, push: { enabled: true }, sms: { enabled: true }.

It enqueues three separate jobs: one for the email sender, one for the push sender, and one for the SMS sender.   

If the event had been eventType: "promotional", the service would have evaluated the preferences and discarded the push and sms jobs, enqueuing only the email job.

VI. Implementation Architecture: Storage, Evolution, and Integration
The data models defined above must be implemented in a physical architecture. This involves selecting a storage pattern, planning for schema evolution, and integrating with ancillary systems like secrets managers and UIs.

A. Storage Pattern Analysis: The "JSONB vs. EAV" Debate
A critical decision, especially for the User Preference Service, is how to store dynamic, evolving settings like the notification preferences schema.

The Anti-Pattern (EAV): The Entity-Attribute-Value (EAV) model, which stores each setting as a separate row (e.g., user_id, setting_key, setting_value), is a common temptation. This model is a definitive anti-pattern. Analysis of relational theory shows EAV is not normalized. It "breaks SQL's support for constraints" because the setting_value column must be a generic type (e.g., VARCHAR) to support all possible values, making it impossible to enforce a NOT NULL constraint, a foreign key, or even a simple number type. Queries to reconstruct a user's settings require complex, non-performant "pivot" operations and are a "mess". It is "bogus from a relational perspective".   

The Contender (Normalized Columns): The traditional relational approach is to add a new column for each setting (e.g., theme, language). This is the correct model for a fixed set of preferences. It is, however, completely unsuitable for dynamic, evolving settings. Adding a new notification preference category would require an ALTER TABLE command, which is a high-cost, blocking database schema migration  and an unacceptable bottleneck for application development.   

The Canonical Pattern (JSONB): The modern, definitive solution is the JSONB column type in PostgreSQL. This stores a binary, indexed, and queryable JSON document in a single database column.   

Flexibility: It perfectly stores the complex, nested notification preference schema. A new notification category can be added to the JSON document without any database schema migration.   

Performance: JSONB is "very easy for Postgres to read and write". Multiple attributes can be updated in a single atomic write operation, which is far more efficient than EAV's multiple-row updates.   

Queryability: Unlike a simple text blob, JSONB is queryable. An application can "just ask Postgres for the field directly" , and GIN indexes can be used for high-speed queries on the document's contents.   

Conclusion: For the User Preference Service, the canonical pattern is a user_preferences table with a user_id (foreign key) and a preferences (JSONB) column. For the Enterprise Configuration Service, a traditional, normalized relational model with explicit columns and foreign keys remains superior due to its strong referential integrity and auditability.

B. Schema Evolution and Migration
Configuration schemas are not static; they evolve. This evolution can break clients if not managed correctly.   

The Problem: A "seemingly innocent modification," like adding a new field to an API response, can crash existing clients that are not prepared to handle it. Similarly, changing the default behavior of an existing setting can cause "chaos" for users who relied on the old behavior.   

Pattern 1: Data Schema Versioning (Client-Side): For JSONB blobs, the standard pattern is to include a version field inside the document. The application code is responsible for reading this version and running an in-memory migration before using the data.   

Example: if (prefs.version == 1) { prefs.new_feature = true; prefs.version = 2; }

Pattern 2: API & Config Schema Versioning (Server-Side): For configuration served via API, formal compatibility rules are required. Confluent's schema registry defines the formal types: BACKWARD, FORWARD, and FULL compatibility.   

The Golden Rule: For configuration systems, the non-negotiable rule is BACKWARD compatibility. This ensures that an application built with a previous version of the configuration can still execute without recompilation on a later version.   

How to achieve BACKWARD compatibility :   

Adding a new setting is safe if it has a defaultValue that preserves the old, existing behavior.

Never change the data type or semantic meaning of an existing setting.

To deprecate a setting, add a new one with the desired behavior, have clients migrate to the new key, and remove the old one in a future major version.

C. Ancillary System Integration
Configuration systems do not exist in a vacuum. Their integration with secrets managers and UIs is critical.

Secrets Management (The Critical "DON'T"): Developers are often tempted to use configuration systems like Consul KV  or AWS AppConfig to store secrets (API keys, database passwords). This is a critical anti-pattern.   

The Canonical Pattern: Configuration systems must be integrated with, but separate from, dedicated secrets managers like AWS Secrets Manager  or HashiCorp Vault.   

Architecture: The configuration should store a reference to the secret (e.g., the ARN of the AWS Secrets Manager secret), not the secret value itself. The application, upon startup, reads the config, gets the secret's ARN, and then makes a separate, authenticated, and audited call to the secrets manager to fetch the sensitive value. This separates high-read-velocity, low-security configuration from low-velocity, high-security, rotatable secrets.   

Schema-Driven UI Generation (The "Force Multiplier"): This is a powerful, emergent pattern that unifies the entire configuration lifecycle.

In Section II, JSON_SCHEMA was established as the canonical model for validating configuration data.   

Libraries like react-jsonschema-form (RJSF)  and JSONForms  are designed to "declaratively build and customize web forms" directly from a JSON Schema.   

The Unified Workflow: A platform team can create a single source-of-truth artifact: the configuration.json_schema. This one file can then be used to:

Validate the configuration data in the CI/CD pipeline and before deployment (via AWS AppConfig).   

Automatically generate a "Settings" page in the admin UI, complete with correct input types, labels, helper text, and validation errors.   

Generate "safe" TypeScript types for the client application, ensuring type safety from the backend to the frontend. This "schema-driven" workflow is the pinnacle of a mature configuration system, as it reduces developer effort, eliminates entire classes of bugs, and ensures consistency from the database to the UI.   

VII. Conclusion: Summary of Convergent Patterns and Anti-Patterns
This analysis of configuration, preference, and feature management systems reveals a clear set of convergent design patterns and high-risk anti-patterns.

A. Key Convergent Patterns (The "Do" List)
DO adopt a federated "Three-Service" model (User Preferences, Enterprise Configuration, Feature Management) to avoid a monolithic anti-pattern that fails to serve any use case well.

DO standardize on the Context primitive  as the unified data model for scoping, segmentation, and targeting, replacing rigid, hard-coded hierarchies.   

DO use JSONB as the non-negotiable storage pattern for dynamic, user-facing preferences. Its flexibility, performance, and queryability are unmatched.   

DO leverage JSON_SCHEMA as the "lingua franca" for your configuration. Use it as a single source of truth for validation  and automatic UI generation.   

DO model notification preferences on the two-axis Channel  x Event-Type  matrix, and implement system-level lock overrides for policy enforcement.   

DO follow a Git-based, CI-driven, "config-as-code" workflow. Manually editing dynamic configuration in production is a high-risk anti-pattern.   

B. Identified Anti-Patterns (The "Don't" List)
DON'T use the Entity-Attribute-Value (EAV) model for preference storage. It is relationally "bogus" , breaks all type-safety and data-integrity constraints, and results in poor performance.   

DON'T store secrets (API keys, database passwords, certs) in your configuration system. Store references to a dedicated secrets manager  and fetch them at runtime.   

DON'T change the default behavior or data type of an existing configuration key. This breaks backward compatibility and causes "chaos". Add a new key and deprecate the old one.   

DON'T build a single, monolithic system. The requirements for user themes and enterprise SSO settings are fundamentally different and demand specialized, federated solutions.

DON'T use untyped key-value strings. This pushes type-coercion logic to all clients and is a primary source of production bugs. Enforce types at the system level.   

C. Final Recommendations
The provided canonical models, architectural patterns, and anti-patterns form a comprehensive blueprint for designing a modern, scalable, and safe configuration platform. We recommend using these models to design a federated "Three-Service" platform, with the Context primitive serving as the foundational data model for all targeting and the JSON_SCHEMA serving as the foundational tool for validation and integration.


reddit.com
Should I save user preference as JSON or individual columns? : r/PostgreSQL - Reddit
Opens in a new window

razsamuel.com
PostgreSQL JSONB vs. EAV: Which is Better for Storing Dynamic Data? - Raz Samuel Blog -
Opens in a new window

help.salesforce.com
Set Your Internal Organization-Wide Sharing Defaults - Salesforce Help
Opens in a new window

docs.github.com
Configurations - GitHub Docs
Opens in a new window

launchdarkly.com
Contexts | LaunchDarkly | Documentation
Opens in a new window

launchdarkly.com
Feature flags | LaunchDarkly | Documentation
Opens in a new window

docs.stripe.com
The Account object | Stripe API Reference - Stripe Documentation
Opens in a new window

developer.hashicorp.com
Consul key/value (KV) store overview - HashiCorp Developer
Opens in a new window

groups.google.com
Key-value (KV) best practices - Google Groups
Opens in a new window

tedspence.com
API Design: Backwards Compatibility | by Ted Spence | tedspence.com
Opens in a new window

firebase.google.com
Remote Config Parameters and Conditions - Firebase
Opens in a new window

firebase.google.com
Remote Config Templates and Versioning - Firebase
Opens in a new window

docs.aws.amazon.com
Validator - AWS AppConfig - AWS Documentation
Opens in a new window

medium.com
AWS AppConfig Deep Dive | By Joud W. Awad - Medium
Opens in a new window

docs.aws.amazon.com
Creating a configuration profile in AWS AppConfig - AWS AppConfig
Opens in a new window

flightcontrol.dev
Ultimate guide to multi-tenant SaaS data modeling - Flightcontrol
Opens in a new window

medium.com
Complete Guide to Multi-Tenant Architecture | by Seetharamugn - Medium
Opens in a new window

medium.com
Multi-Tenancy Database Patterns with examples in Go | by Rost Glukhov - Medium
Opens in a new window

learn.microsoft.com
Multi-tenancy - EF Core - Microsoft Learn
Opens in a new window

s2-labs.com
Organization Wide Default (OWD) in Salesforce - S2 Labs
Opens in a new window

help.salesforce.com
Manage Custom Settings Data - Salesforce Help
Opens in a new window

launchdarkly.github.io
Struct Context | LaunchDarkly Dotnet Client SDK
Opens in a new window

launchdarkly.com
Targeting rules | LaunchDarkly | Documentation
Opens in a new window

docs.stripe.com
Accounts | Stripe API Reference
Opens in a new window

docs.stripe.com
Accounts v2 API | Stripe Documentation
Opens in a new window

docs.slack.dev
SCIM API reference | Slack Developer Docs
Opens in a new window

learn.microsoft.com
Automate User provisioning into Slack with Microsoft Entra ID
Opens in a new window

docs.getunleash.io
Clone a feature flag - Unleash Documentation
Opens in a new window

docs.split.io
Events Overview - Split API
Opens in a new window

docs.getunleash.io
Get a single feature flag - Unleash Documentation
Opens in a new window

docs.getunleash.io
Get all features in a project | Unleash Documentation
Opens in a new window

help.split.io
Define feature flag treatments and targeting - Harness Documentation - Split.io
Opens in a new window

help.split.io
Target with custom attributes – Split Help Center - Harness Documentation
Opens in a new window

developer.harness.io
Define feature flag treatments and targeting - Harness Developer Hub
Opens in a new window

firebase.google.com
Modify Remote Config programmatically - Firebase
Opens in a new window

github.com
RemoteConfig condition names invalid via the Admin SDK but not console #2535 - GitHub
Opens in a new window

docs.getunleash.io
Unleash architecture overview | Unleash Documentation
Opens in a new window

userpilot.com
10+ Notification Types For Engaging Users in SaaS - Userpilot
Opens in a new window

userlist.com
In-app Notifications: The Complete Guide for SaaS - Userlist
Opens in a new window

suprsend.com
Ultimate Guide to SaaS In-App Notifications and In-App Inboxes - with Implementation Codes - SuprSend
Opens in a new window

medium.com
Decoding In-App Notifications and App Inboxes: Your Ultimate Guide to Grasping SAAS In-App… - Medium
Opens in a new window

notificationapi.com
Notification Service Design | The Ultimate Guide with Diagrams - NotificationAPI
Opens in a new window

designgurus.io
Designing a Notification System
Opens in a new window

developer.android.com
Create and manage notification channels | Views - Android Developers
Opens in a new window

medium.com
Designing a Scalable Notification System: A Deep Dive | by Rahul Garg - Medium
Opens in a new window

algomaster.io
Design Scalable Notification Service | System Design - AlgoMaster.io
Opens in a new window

stackoverflow.com
EAV modelled database schema to store settings, is this the correct way? - Stack Overflow
Opens in a new window

stackoverflow.com
Users table to Users and User Preferences. Is this normalized? - Stack Overflow
Opens in a new window

reddit.com
EAV or JSON : r/PostgreSQL - Reddit
Opens in a new window

en.wikipedia.org
Schema migration - Wikipedia
Opens in a new window

docs.evolveum.com
Comparing JSONB and EAV model for extensions - Evolveum Docs
Opens in a new window

medium.com
Avoiding Production Disasters: A Guide to Versioning and Backward Compatibility Testing | by Mona M. Abd El-Rahman - Medium
Opens in a new window

learn.microsoft.com
Azure Cosmos DB design pattern: Schema Versioning - Code Samples | Microsoft Learn
Opens in a new window

docs.confluent.io
Schema Evolution and Compatibility for Schema Registry on Confluent Platform
Opens in a new window

learn.microsoft.com
NET API changes that affect compatibility - Microsoft Learn
Opens in a new window

stackoverflow.com
What are some concrete use-cases for Consul's Key-Value store? - Stack Overflow
Opens in a new window

docs.aws.amazon.com
AWS Secrets Manager best practices
Opens in a new window

reddit.com
HashiCorp Vault vs AWS Secrets Manager : r/devops - Reddit
Opens in a new window

cheatsheetseries.owasp.org
Secrets Management - OWASP Cheat Sheet Series
Opens in a new window

docs.aws.amazon.com
Understanding validators - AWS AppConfig
Opens in a new window

github.com
rjsf-team/react-jsonschema-form: A React component for building Web forms from JSON Schema. - GitHub
Opens in a new window

jsonforms.io
JSON Forms: More forms. Less code.
Opens in a new window

jsonforms.io
UI Schema - JSON Forms
Opens in a new window

docs.meshery.io
Schema-Driven UI Development in Meshery
Opens in a new window

medium.com
Manage & Monitor Consul KV Changes | by Rosemary Wang - Medium
Opens in a new window

dev.to
Secret Management in DevOps: Vault vs AWS Secrets Manager - DEV Community
Opens in a new window

launchdarkly.com
Using the LaunchDarkly REST API
