Analysis of the Canonical Data Model for Address and Location Systems
Executive Summary: Recommendation for a Core 'Addressable' Trait
This report presents a comprehensive analysis of the Address and Location data model, a domain identified as a top canonical schema with 80-90% coverage across enterprise applications. The primary objective was to determine whether this domain's data model is sufficiently universal and complex to warrant implementation as a core trait (Addressable) within the OODS Foundry, or if it should remain a simple schema pattern.

Definitive Recommendation: The Address/Location model is formally recommended for implementation as a core trait, Addressable.

The initial hypothesis that the domain is both universal and complex is strongly confirmed. However, the analysis reveals that the complexity is not merely in the convergence of common fields but is threefold, originating from three distinct axes:

Structural Complexity (Internationalization): The common six-field address model (e.g., line1, city, state, zip) is a US-centric, lossy abstraction. A true canonical representation must support divergent global formats, such as the granular UK Postcode Address File (PAF)  or the largest-to-smallest, block-based system used in Japan. As demonstrated by the Universal Postal Union (UPU) S42 standard, a global address system is a meta-model of components and templates, not a single static schema.   

Lifecycle Complexity (Validation & Enrichment): A stored address is not static; it exists on a lifecycle from unvalidated user input to a validated, corrected, and enriched entity. Validation services, such as the Google Address Validation API, return a rich, complex metadata object—including deliverability verdicts, component-level corrections, and flags like isResidential or isBusiness. A simple schema pattern has no standard mechanism for storing this critical operational data.   

Compositional Complexity (Multi-Role): The ubiquitous "billing vs. shipping" pattern  is a foundational requirement for e-commerce, user profiles, and organization management. This is fundamentally a compositional problem, representing a 1:N "role-based" relationship between an entity (like a Customer) and multiple Address objects. This pattern maps directly to the OODS trait composition model.   

A simple schema pattern would abdicate all three axes of complexity to every individual OODS consumer, resulting in massive fragmentation and duplicated effort. A core Addressable trait abstracts this complexity, providing a robust, standardized, and reliable interface. This encapsulates the core promise of the OODS Foundry.

Part I: Analysis of the Universal Address Model
1.1 Deconstructing the 'Simple' Address: Core Field Convergence
Analysis of major e-commerce, logistics, and payment platforms reveals an immediate and powerful "de facto" standard for an address. This model, consisting of approximately six fields, represents the baseline for the vast majority of simple implementations and forms the public's mental model of an "address."

Stripe: The Stripe API consistently defines its address object—used for Customers, Shipping, and Terminal Locations—with six core, nullable fields: city, country (ISO 3166-1 alpha-2), line1, line2, postal_code, and state.   

Shopify: The MailingAddress interface in Shopify's API mirrors this structure with: address1, address2, city, zip (postal code), countryCode (ISO 3166), and provinceCode (state).   

PayPal (Braintree): Braintree's Address object shows high convergence but with semantic differences, using street_address (for line 1), extended_address (for line 2), locality (for city), region (for state), postal_code, and country_code_alpha2.   

Schema.org: The PostalAddress object, a key standard for semantic web data, reinforces this pattern with streetAddress, addressLocality (city), addressRegion (state), postalCode, and addressCountry.   

USPS: The United States Postal Service's own web validation APIs are built around this model, requesting Address1, Address2, City, State, and Zip5.   

This overwhelming convergence is the primary argument for a simple schema pattern. However, this convergence is an illusion of simplicity. The semantics of these fields are already divergent and ambiguous. For example, Stripe's line1 is defined as "street, PO Box, or company name" , while Braintree provides a separate company field. Similarly, the USPS defines Address2 specifically as the "secondary unit designator, such as apartment (APT) or suite (STE) number" , while many platforms use it as a generic overflow line. This ambiguity in the "simple" model is its primary failure point.   

Table 1: Cross-Platform Field Convergence Matrix

Logical Component	Stripe (address)	Shopify (MailingAddress)	PayPal/Braintree (Address)	Schema.org (PostalAddress)	USPS (AddressValidateRequest)
Street Line 1	line1	address1	street_address	streetAddress	Address1
Street Line 2	line2	address2	extended_address	extendedAddress	Address2
City/Locality	city	city	locality	addressLocality	City
State/Region	state	provinceCode	region	addressRegion	State
Postal Code	postal_code	zip	postal_code	postalCode	Zip5
Country	country	countryCode	country_code_alpha2	addressCountry	(N/A - US Implicit)
1.2 The Internationalization Challenge: When Simple Models Fail
The "simple" six-field model is fundamentally US/UK-centric and breaks down completely when faced with global address formats. These formats differ not only in their required fields but also in their fundamental order and structure. This represents the first major axis of complexity.

The Universal Postal Union (UPU), the international governing body for postal standards, does not define a single, flat schema. Instead, its S42 standard defines "International postal address components and templates". The UPU S42 standard is a meta-model: it provides a "common list of international name and address elements" and a "template language" for each member country to construct its valid address format from those components. This means a truly canonical address system is not a static data structure but an engine capable of interpreting these templates—a non-obvious and significant source of complexity.   

Shopify's engineering team, when solving this problem, arrived at the same conclusion. Their solution involved creating "formats to describe addresses per country" stored in a central database, which are used to "dynamically reorder the fields" of an address form based on the selected country. They also created a list of keys for field labels (e.g., postal_code vs. zip vs. pincode) to handle translation. This metadata about an address's structure is a core part of the canonical model.   

Specific examples of divergence include:

Japan: Japanese addresses are written largest-to-smallest. The components are entirely different from the US model, consisting of Prefecture (administrative area), City/Ward, District, Block number (chome), Sub-block number (banchi), and House number (go). Google's own API for Japan removed the locality (City) field and forces this information into the unstructured address lines, proving that the simple six-field model is a lossy, forced-fit compromise.   

United Kingdom: The Royal Mail Postcode Address File (PAF) is highly structured and granular. Instead of two ambiguous line fields, it defines distinct components like Sub Building Name, Building Name, Building Number, Dependent Thoroughfare Name, Thoroughfare Name, Double Dependent Locality, Dependent Locality, and Post Town.   

Germany: The format is street-name before house-number (e.g., "Röntgenstr. 9").   

The line1/line2 pattern is thus revealed as a poor abstraction. It is not granular enough to capture the discrete components of the UK PAF  and too rigidly structured to handle the Japanese block-based system, which is often just concatenated into line1.   

Table 2: International Format Divergence Example

Logical Component	US Standard (USPS)	UK Standard (PAF)	Japan Standard (SAP)
Primary Admin Unit	
State 

(N/A - uses Post Town)	
Prefecture 

Secondary Admin Unit	
City 

Post Town 

City / Ward 

Tertiary Admin Unit	(N/A)	
Dependent Locality 

District 

Street/Thoroughfare	
Address1 (Street Name) 

Thoroughfare Name 

Block/Sub-block 

Premise Identifier	
Address1 (House Num) 

Building Number 

House Number 

Sub-Premise Identifier	
Address2 (Apt/Suite) 

Sub Building Name 

(Often in building name)
Postal Code	
Zip5+Zip4 

Postcode 

Postal code 

Ordering	Smallest-to-Largest	Smallest-to-Largest	
Largest-to-Smallest 

  
1.3 From Input to Deliverability: The Validation and Metadata Layer
The second axis of complexity is the data lifecycle. A stored address is not just user input; it exists on a spectrum of states: unvalidated -> validated -> corrected -> enriched. A canonical model must capture this state.

Address validation is not a simple "yes/no" boolean. The Google Address Validation API, a canonical example, accepts an address and returns a ValidationResult object. This object contains a deeply nested structure that is far more complex than the input:   

verdict: An object containing critical flags like addressComplete, hasUnconfirmedComponents, hasInferredComponents, and hasReplacedComponents.   

address: A new Address object containing the corrected and formatted components.   

geocode: The latitude/longitude coordinates.   

metadata: An object with crucial deliverability flags: business, poBox, and residential.   

uspsData: CASS-specific data for US addresses.   

This enrichment metadata is a core part of the address's value. Services like Smarty return "up to 55 powerful data points" with a verified address, including delivery readiness, residential or business, and vacant or inactive addresses. Ekata's AVS confirms this, checking against a database to validate and standardize components.   

This process creates a critical data modeling decision. Overwriting user input with the corrected address is risky. A far better pattern is to store the original user input and this associated AddressMetadata object. A simple schema pattern has no standardized place to store this metadata, whereas a trait can manage this relationship explicitly.

1.4 Postal vs. Physical: The Geocoding (Lat/Lng) Pattern
The query correctly distinguishes between postal addresses (for mail deliverability) and physical locations (for map coordinates). The research confirms these are two different, though often linked, concepts. A valid postal address (e.g., a PO Box) may not have a geocode, and a valid geocode (e.g., a location in a park) may not have a postal address.

Google's documentation explicitly differentiates its Geocoding API (converts address to lat/lng) from its Address Validation API (confirms deliverability).   

Analysis of data models reveals two patterns for storing latitude and longitude:

Pattern 1: Bundled (Geocode is an Attribute of Address): Salesforce's Address object, for example, directly includes Latitude and Longitude fields.   

Pattern 2: Separate (Geocode is an Associated Entity): Database design discussions highlight the trade-offs of a separate table for geolocations, balancing normalization and performance.   

Bundling them (Pattern 1) "pollutes" the postal address model, forcing null values for non-physical locations like PO Boxes. The analysis from Section 1.3 provides a superior solution: the geocode is a result of the validation and enrichment process.

Therefore, the canonical Address schema should not contain latitude and longitude. This keeps the model pure and focused on deliverability. The AddressMetadata schema is the correct location to store the associated geocode that is returned by the validation provider, as seen in Google's ValidationResult.   

Part II: Architectural Determination: Trait vs. Pattern
2.1 Modeling Multi-Address Systems (Billing, Shipping, Home)
The third axis of complexity is compositional. Nearly all systems, from e-commerce to user profiles, must support multiple addresses for a single entity (e.g., Customer, Organization) and distinguish them by role.

The distinction between a billing and shipping address is critical for business operations. The billing address is used for payment verification and fraud prevention, while the shipping address is for physical delivery. While often the same, 16% of mobile sites have "severe issues" implementing this distinction, leading to friction and abandonment.   

API and database patterns show a clear consensus on modeling this as a 1:N composition:

API Patterns: Stripe's Customer object has a primary address (implicitly billing) and a separate shipping object, which contains its own address object. Shopify's API exposes two distinct signals, billingAddress and shippingAddress, both of which are instances of the MailingAddress interface.   

Database Patterns: Database design articles strongly advocate for normalization. The optimal solution is a many-to-many relationship using a "join table" (e.g., Customer_Address_Link) with fields like customer_id, address_id, and address_type ('billing', 'shipping', 'home', etc.).   

This normalized "join table" pattern is precisely what the OODS Foundry's composition model is designed to implement. The Address is a reusable, immutable Value Object. The Customer is an Entity. The Addressable trait, when applied to Customer, manages this 1:N relationship. The address_type (or "role") becomes the key in the trait's compositional map.   

This leads to a powerful abstraction. The trait's interface should not be hard-coded (e.g., getBillingAddress()). Instead, it should be generic: getAddress(role: "billing") and setAddress(role: "shipping", address: Address). This allows consumers to define any role they need ("billing," "shipping," "physical," "warehouse," "return") while standardizing the pattern of composition.

2.2 The Case for a Simple Schema Pattern
To ensure a robust decision, the alternative—a simple schema pattern—must be considered. The argument for this approach rests on the high convergence identified in Section 1.1. The "simple" 6-field model is so common that it is "good enough" for 80-90% of use cases.   

A simple, non-binding JSON schema would be easy to understand, implement, and adopt. Consumers would not be locked into a complex trait and could implement their own validation, internationalization, and storage logic as needed.

This argument, however, is a strategic trap. It mistakes commonality for simplicity. This approach forces every single OODS consumer to solve the exact same complex problems on their own, leading to:

Dozens of custom-built, fragile parsers for Japanese addresses.   

Inconsistent storage of validation metadata, or (more likely) the complete loss of it.   

Fragmented, non-standard implementations of the "billing vs. shipping" composition.   

This outcome is precisely the platform-wide fragmentation and duplicated logic that the OODS Foundry was created to prevent.

2.3 The Case for a Core 'Addressable' Trait
The Address model is a prime candidate for a core trait because its complexity is high, universal, and—most importantly—abstractable. A trait is the only mechanism that can encapsulate the behavior required to manage this complexity, not just the data.

The Addressable trait is justified by its ability to abstract all three axes of complexity:

Abstracting Structural Complexity (Internationalization): A simple schema cannot solve the international format problem. An Addressable trait can. It encapsulates this complexity by providing behavior, such as a getFormattedAddress(role: string, locale: string) method. This logic would be implemented once inside the trait, leveraging the template-based model (UPU S42, Shopify) to correctly render an address for any country.   

Abstracting Lifecycle Complexity (Validation & Metadata): A simple schema cannot store the rich metadata from validation. An Addressable trait can. It standardizes the relationship between an Address and its AddressMetadata. It would provide a behavior like validateAddress(role: string): Promise<AddressMetadata>, providing a standard interface for a complex, asynchronous lifecycle and abstracting the specific provider (Google, USPS, etc.).   

Abstracting Compositional Complexity (Multi-Role): A simple schema cannot enforce a standard pattern for multi-address roles. An Addressable trait is the OODS-native implementation of this 1:N normalized pattern. It provides the getAddress(role) and setAddress(role) methods, standardizing the "billing vs. shipping" problem for all entities in the Foundry.   

Part III: Proposed Canonical Model Specifications
The following specifications define the canonical schemas and trait interface for the Addressable model.

3.1 Specification: The Canonical Address Schema
This schema is a pragmatic hybrid. It supports the common 6-field model but uses semantically flexible names (administrativeArea, locality) to better accommodate international concepts. Its key innovation is the formatTemplateKey field, which "unlocks" the correct formatting and rendering logic for international addresses, connecting the simple data to the complex behavior encapsulated in the trait.

Table 3: Proposed Canonical Address Schema Definition (Value Object)

Field Name	Type	Description	Validation Rules (Example)	Sources
countryCode	string	The 2-letter ISO 3166-1 alpha-2 country code.	required, len(2), uppercase	
postalCode	string	The postal code, ZIP code, or pincode.	nullable, string	
administrativeArea	string	The top-level administrative division. (e.g., State, Province, Prefecture, Region).	nullable, string	
locality	string	The city, town, village, or post town.	nullable, string	
addressLine1	string	The primary address line. (e.g., Street + House Number, PO Box, or Japanese Block).	nullable, string	
addressLine2	string	The secondary address line. (e.g., Apartment, Suite, Unit, Building Name).	nullable, string	
addressLine3	string	An optional, additional address line for complex addresses. (e.g., C/O, Dependent Locality).	nullable, string	
organizationName	string	The company or organization name at this address.	nullable, string	
formatTemplateKey	string	A key (e.g., "JP", "GB-PAF", "US-PR") referencing a UPU S42-style format template. Used by the trait to render forms and format labels.	nullable, string	
  
3.2 Specification: The Canonical AddressMetadata Schema
This schema captures the results of the validation and enrichment lifecycle. It is designed to be associated with, but separate from, the Address value object, and is derived primarily from the Google Address Validation API response.   

Table 4: Proposed AddressMetadata Schema Definition

Field Name	Type	Description	Sources
validationStatus	enum	The deliverability status. (unvalidated, valid, invalid, partial_valid).	
validationTimestamp	datetime	The UTC timestamp of the last validation attempt.	(Logical)
validationProvider	string	The service that provided the validation (e.g., "google-av", "usps").	(Logical)
isResidential	boolean	(Nullable) True if the address is confirmed residential.	
isBusiness	boolean	(Nullable) True if the address is confirmed commercial.	
isPOBox	boolean	(Nullable) True if the address is a PO Box.	
validationFlags	Map<string, boolean>	Key-value pairs for validation results. (e.g., hasUnconfirmedComponents: true, hasInferredComponents: false, hasSpellCorrectedComponents: true).	
correctedAddress	Address	(Nullable) The corrected/standardized Address object, if one was returned by the provider.	
geocode	object	(Nullable) The geocode (lat/lng) associated with this validated address. (Schema: { latitude: double, longitude: double, precision: enum }).	
  
3.3 Specification: The Addressable Trait Interface
This specification defines the OODS Foundry "contract" that an entity (like Customer or Organization) implements. It standardizes the compositional pattern (Section 2.1) and provides the behaviors to manage internationalization (Section 1.2) and validation (Section 1.3).

Trait: Addressable

Conceptual Internal Data Structure:

addresses: Map<string (role), AddressableEntry>

AddressableEntry: { address: Address, metadata: AddressMetadata, isDefault: boolean }

Methods (The "Contract"):

setAddress(role: string, address: Address, isDefault: boolean = false): void

Purpose: Adds or updates an address for a specific role (e.g., setAddress("billing", {...})). Implements the normalized 1:N composition pattern.   

getAddress(role: string): AddressableEntry | undefined

Purpose: Retrieves the address and its metadata for a specific role.

removeAddress(role: string): boolean

Purpose: Removes an address for a specific role.

getAddresses(roles?: string): Map<string, AddressableEntry>

Purpose: Returns all addresses or a filtered subset.

getDefaultAddress(role?: string): AddressableEntry | undefined

Purpose: Gets the default address, or the default for a specific role (e.g., "default shipping").

validateAddress(role: string): Promise<AddressMetadata>

Purpose: Triggers validation for a specific address. This method contains the abstracted logic to call an external API , receive the result, and update the metadata property of the AddressableEntry.   

getFormattedAddress(role: string, locale?: string): string

Purpose: Returns a postal-service-ready formatted address string. This method contains the abstracted logic to use the formatTemplateKey from the Address schema  to correctly order and format the components.   

Part IV: Final Recommendation and Implementation Path
4.1 Definitive Recommendation: Address as a Core Trait
The initial hypothesis is strongly confirmed. Address/Location is ubiquitous and exhibits deep, non-obvious complexity.

A simple schema pattern is insufficient as it only addresses the "simple" 6-field model  and ignores the three primary drivers of complexity:   

Structural (Internationalization): The divergence in global address formats is not a field-level problem but a structural one, requiring a template-based engine to manage.   

Lifecycle (Validation): The process of validation creates a rich, complex metadata object (verdict, metadata, geocode) that is essential to deliverability.   

Compositional (Multi-Role): The "billing vs. shipping" pattern is a 1:N relationship problem that maps directly to OODS composition principles.   

The Addressable trait, as specified in Part III, is the correct architectural solution. It fully abstracts these three complex axes, providing a standardized, reliable, and powerful interface to all OODS Foundry consumers and preventing mass-scale fragmentation and duplication of logic.

4.2 Implementation and Handoff Context
Based on this analysis, the following next steps and handoff context are provided to the Product and Engineering leads.

Executive Summary for Handoff: Research confirms the hypothesis that Address/Location is both universal (80-90% coverage) and highly complex. The complexity is threefold: 1) Structural divergence in international formats (UPU S42, JP, UK), 2) Lifecycle complexity from validation/enrichment (Google AV API metadata), and 3) Compositional patterns for multi-role addresses (billing vs. shipping). A simple schema pattern is insufficient. We recommend elevating this to a core Addressable trait to abstract this complexity, providing a canonical Address schema, an AddressMetadata schema, and a trait interface to manage formatting, validation, and compositional roles.

Next Steps:

[Product] Review and ratify the proposed Address (Section 3.1) and AddressMetadata (Section 3.2) canonical schemas.

[Product] Review and ratify the proposed Addressable trait interface (Section 3.3).

[Engineering] Begin implementation of the core Addressable trait in the OODS Foundry registry and composition engine.

[Engineering] Begin research on a backing service (internal or 3rd-party) to manage the international formatTemplateKey logic  required for the getFormattedAddress() method.   

[Engineering] Begin vendor analysis for a default validation provider to back the validateAddress() method, using the Google AV API  or USPS API  as a baseline.   

Product Handoff:

PRD Updates: The PRD requirement R3.1-001 should be updated to reflect the trait-based recommendation and explicitly adopt the three proposed artifacts (schemas Address, AddressMetadata; trait Addressable).

KPI Alignment: Key performance indicators should focus on trait adoption, measuring the reduction in one-off, application-specific address-handling logic across consumer applications.

Engineering Handoff:

SRD Updates: The SRD must be updated to include the Addressable trait (Section 3.3) in the core trait registry. The Address and AddressMetadata schemas (Sections 3.1, 3.2) must be added to the canonical schema library.

Feasibility Review: The implementation feasibility review should focus on the two external dependencies identified: the international formatting template service  and the address validation provider service.   


postcodeaddressfile.co.uk
PAF Data Specification & Notes - Postcode Address File
Opens in a new window

help.sap.com
Standard Japanese Address Format - SAP Help Portal
Opens in a new window

upu.int
Addressing Solutions - UPU.int
Opens in a new window

upu.int
Addressing and Postcode Manual - UPU.int
Opens in a new window

developers.google.com
Method: validateAddress | Address Validation API | Google for ...
Opens in a new window

nextsmartship.com
Billing Address vs. Shipping Address - What is the difference - NextSmartShip
Opens in a new window

redstagfulfillment.com
Billing address vs. shipping address - Red Stag Fulfillment
Opens in a new window

dba.stackexchange.com
Storing a Billing Address Best Practice in Orders Table
Opens in a new window

docs.stripe.com
The Customer object | Stripe API Reference
Opens in a new window

docs.stripe.com
The Location object | Stripe API Reference
Opens in a new window

shopify.dev
Addresses - Shopify Dev Docs
Opens in a new window

developer.paypal.com
Address - developer Paypal
Opens in a new window

studio.apollographql.com
Schema | Braintree@current - Apollo Studio
Opens in a new window

schema.org
PostalAddress - Schema.org Type
Opens in a new window

schema.org
address - Schema.org Property
Opens in a new window

usps.com
Address API - Get Zipcode Req - USPS
Opens in a new window

usps.com
ZIP Code Lookup API - USPS
Opens in a new window

upu.int
S42 - UPU.int
Opens in a new window

shopify.engineering
Handling Addresses from All Around the World - Shopify
Opens in a new window

w3c.github.io
Address formats around the world - W3C on GitHub
Opens in a new window

developers.google.com
Japanese address format specification | Google Business Profile APIs
Opens in a new window

en.wikipedia.org
Postcode Address File - Wikipedia
Opens in a new window

docs.informatica.com
Address Verification Best Practices for Germany - Address Format and Address Structure
Opens in a new window

developers.google.com
Address Validation API overview - Google for Developers
Opens in a new window

smarty.com
Features of Smarty US Address Verification: Address metadata
Opens in a new window

ekata.com
Top 8 Features for Address Verification Services - Ekata, a Mastercard company
Opens in a new window

developer.salesforce.com
Address | Object Reference for the Salesforce Platform | Salesforce ...
Opens in a new window

dba.stackexchange.com
Should I create a separate table for geo-location points?
Opens in a new window

stackoverflow.com
Is it worth breaking out address information into a separate database table? - Stack Overflow
Opens in a new window

powercommerce.com
Billing Address vs Shipping Address: Why Getting Both Right Cuts Failed Deliveries, Fraud and Costs - Power Commerce
Opens in a new window

shopify.com
Billing Address vs. Shipping Address: Why the Difference Matters (2025) - Shopify
Opens in a new window

baymard.com
Use "Shipping Address" as "Billing Address" - Baymard
Opens in a new window

stackoverflow.com
a customer with more than one possible physical adress, how to design database schema?
Opens in a new window

en.wikipedia.org
Object composition - Wikipedia
Opens in a new window

geeksforgeeks.org
Object-Oriented Design (OOD) - System Design - GeeksforGeeks
