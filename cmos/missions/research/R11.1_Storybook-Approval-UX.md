Designing an Approval-Gated Workflow for Storybook Agent
Deconstructing the plan → approve → execute Interaction Pattern
Introduction to Approval-Gated Workflows in Developer Tooling
The plan → approve → execute pattern is a foundational interaction model in modern developer tooling, designed to instill confidence and provide explicit control over automated processes that alter a system's state. This workflow transforms potentially opaque operations into a transparent, predictable, and auditable sequence. It serves as a critical trust-building mechanism by ensuring that no changes are made without informed human consent.

The canonical implementation of this pattern is found in command-line tools like HashiCorp Terraform, which follows a core workflow of initialize → plan → apply. In this model, terraform plan generates a non-destructive preview of the changes required to align the infrastructure with the configuration. This execution plan details which resources will be created, updated, or destroyed. Only after the user reviews this plan and explicitly agrees to it does the terraform apply command execute the proposed changes. For automated contexts, this approval can be pre-supplied via a saved plan file or a command-line flag like -auto-approve, but the default interactive mode demands manual confirmation, underscoring the pattern's emphasis on safety.   

A graphical user interface (GUI) parallel exists in platforms like GitHub Actions, particularly in the workflow for approving pull requests from forked repositories. Before a workflow is run, a maintainer is prompted to review the proposed code changes in a "Files changed" tab. Only after this inspection can they click an "Approve workflows to run" button, which gates the execution. This model demonstrates how the core principles of preview and consent are adapted to a collaborative, visual environment.   

These examples highlight universal principles found in effective approval systems: transparency through detailed previews, clear stages of review, and a robust audit trail that documents the decision-making process. However, a key distinction arises when translating these patterns into a Storybook addon panel. Tools like Terraform and CI/CD systems are often designed for asynchronous, long-running tasks that may take minutes to complete. In contrast, a Storybook panel exists within a highly interactive, synchronous development environment where users expect immediate feedback. Therefore, the implementation cannot be a direct port; the "planning" and "executing" phases must be presented as quick, blocking operations within the UI, managed with clear state indicators (e.g., spinners) to maintain a fluid user experience. The "awaiting approval" state is transient, existing only for the duration of the user's active review.   

Core User Psychology: Certainty, Risk, and Consent
The effectiveness of the plan → approve → execute pattern is rooted in how it addresses fundamental user psychology when interacting with powerful automation. The primary objective is to mitigate the user's fear of unintended consequences and build trust in the tool.

Certainty (The "Plan" Phase): This stage directly addresses the user's need for predictability. Before committing to an action, the user asks, "What is this tool about to do?" The plan preview provides a definitive answer, showing a diff of proposed changes and a list of affected files. This transforms an abstract command into a concrete set of outcomes, giving the user the information needed to make a rational decision.

Risk and Consent (The "Approve" Phase): This stage is the fulcrum of the interaction, focusing on risk management and explicit consent. For any action that is destructive or difficult to reverse, this step forces a moment of deliberate consideration. It is the point of human-in-the-loop validation, where the user formally accepts responsibility for the consequences of the operation. This is particularly crucial for actions like file deletion or overwriting.

Closure and Evidence (The "Execute" Phase): After the action is complete, the user needs confirmation and proof. This phase answers the question, "What did the tool do, and where is the evidence?" The post-run summary and the generated artifacts serve as this proof. A successful run provides positive reinforcement and closure, while a failed run must provide clear, actionable feedback. The artifacts themselves become the durable, tangible record of the operation.   

System Architecture: States and Components for the Addon Panel
Defining the Panel's State Machine
To ensure a robust and predictable user experience, the addon panel's operation will be governed by a formal state machine. This lifecycle defines every possible state of the panel from user initiation to completion, providing a clear architectural blueprint. Documenting this state machine is a critical artifact in itself, aligning the design and engineering teams on the system's behavior before implementation begins.   

The defined states are:

idle: The initial state. The panel is ready for user input, displaying a primary action button to start the process.

planning: The system is processing the user's request and generating the plan. The UI is disabled, and a loading indicator is displayed.

review: The plan has been generated and is presented to the user for inspection. The user can review diffs and artifact lists.

awaiting-approval: The user has initiated the approval step, typically by clicking an "Approve" button, which presents a final confirmation dialog.

executing: The user has confirmed the plan. The system is now applying the changes. The UI is disabled, and a progress indicator is shown.

summary: The execution has completed successfully. The panel displays a summary of the actions taken and provides links to the resulting artifacts.

error: The execution has failed. The panel displays an error message, relevant logs, and provides actionable next steps, such as a retry option.

Core UI Components
The user interface will be constructed from a set of modular components, each corresponding to specific states in the machine. As a Storybook addon, this will be implemented as a PANEL type, the most common pattern for custom UI in the addon panel.   

DiffViewer: The core component of the review state. It renders a visual comparison of file changes, highlighting additions and deletions.

ArtifactList: Used in both the review and summary states. It displays a list of files that will be or have been created, modified, or deleted.

ApproveDialog: A modal dialog that serves as the gate between the awaiting-approval and executing states, requiring explicit user confirmation.

SummaryCard: The primary component of the summary state, presenting the results of a successful execution.

ErrorNotice: The primary component of the error state, communicating failure and providing recovery options.

The approval step within this architecture is more than a simple UI event; it represents a formal transaction. The click on the "Approve & Apply" button is the user's signature on the proposed plan. This understanding has significant implications for the system's design. The post-run summary is not merely a transient notification but a persistent "receipt" of this transaction. It must provide an unambiguous record of the outcome, including durable links to the generated artifacts and an implicit connection to the plan that was approved. This creates the necessary audit trail, a key feature of enterprise-grade approval workflows. Consequently, the telemetry collected must capture this entire transactional lifecycle—from the hash of the plan to the final exit code and the hashes of the resulting artifacts—as a single, cohesive unit.   

Interaction Design and UX Specifications
The Plan Preview (review state): Visualizing Proposed Changes
The review state is where the user builds the confidence needed to approve the proposed changes. The interface must be clear, scannable, and transparent.

Code snippet

graph TD
    subgraph Storybook Addon Panel
        A
        B{DiffViewer}
        C[Artifact List]
        D
        A --> B
        B --> C
        C --> D
    end
    style A fill:#fefcbf,stroke:#f59e0b,stroke-width:2px
Caption: Wireframe for the Plan Preview state, showing a risk summary, diff viewer, artifact list, and primary action.

DiffViewer Component:
The DiffViewer will present file changes. A key design decision is the choice between a unified diff and a side-by-side diff. A unified format is more compact and generally better suited to the constrained space of an addon panel, while a side-by-side view can offer more clarity for complex, multi-line changes. The recommended approach is to use a unified view by default, which is more space-efficient.   

The visual presentation will adhere to established conventions to maximize readability: lines to be added (+) will have a green background, lines to be deleted (-) will have a red background, and unchanged context lines will have a neutral background. To further clarify subtle changes within a single line, word-level highlighting (analogous to git diff --word-diff) will be implemented.   

ArtifactList Component:
This component will provide a scannable list of all files to be affected by the operation. Following best practices for displaying file lists, the design will prioritize key information on the left to align with the natural F-shaped reading pattern and will be designed to avoid horizontal scrolling. Each row will display an icon indicating the action (create, modify, delete), followed by the file path.   

Risk Callouts:
At the top of the plan preview, a visually distinct summary box will provide an at-a-glance overview of the plan (e.g., "Plan: 2 to create, 1 to modify, 0 to delete."). Any high-risk actions, such as file deletions, will be explicitly highlighted with a warning icon and unambiguous language to draw the user's immediate attention.

The Approval Gate (awaiting-approval state): A Modal for Explicit Consent
To prevent accidental execution and emphasize the significance of applying changes, a modal dialog is used. This is a blocking interaction that forces the user to pause and consciously confirm their intent.   

Code snippet

graph TD
    subgraph Modal Dialog
        A
        B
        C
        D
        E
        A --> B
        B --> C
        C --> D
        C --> E
    end
    style C fill:#fee2e2,stroke:#ef4444,stroke-width:2px
Caption: Wireframe for the Approval Dialog, summarizing the plan and presenting clear, opposing actions.

The modal's content will re-summarize the most critical information from the plan, including the number of files to be created, modified, and deleted, along with a strong warning for any irreversible actions. The primary call-to-action will be labeled "Approve & Apply," with a secondary, de-emphasized "Cancel" button.

This component carries the highest accessibility burden. Its implementation must strictly adhere to the WAI-ARIA Authoring Practices Guide (APG) for modal dialogs. This includes:   

The dialog container must have role="dialog" and aria-modal="true".

Keyboard focus must be trapped within the dialog. Tab and Shift+Tab must cycle only through the interactive elements inside the modal.

The Escape key must close the dialog.

Upon closing, focus must return to the element that triggered the dialog (the "Approve & Apply" button in the panel).

A critical aspect of the dialog's accessibility and safety is the management of initial focus. The WAI-ARIA APG advises that for dialogs confirming a non-reversible or destructive action, initial focus should be set on the least destructive action available. In this case, the "Approve & Apply" button is the destructive action, while "Cancel" is the safe, non-destructive one. Therefore, to prevent a user from accidentally triggering the apply action by reflexively hitting the Enter or Space key, initial focus must be programmatically set on the "Cancel" button when the dialog opens. This deliberate design choice leverages accessibility best practices to enhance user safety at the workflow's most critical juncture.   

The Post-Run Summary (summary and error states): Communicating Outcomes
The final state provides closure by clearly communicating the result of the operation.

Code snippet

graph TD
    subgraph Success Summary
        A[Icon: Checkmark]
        B
        C
        D
        E[List of artifact links]
    end

    subgraph Error Summary
        F[Icon: X-Mark]
        G
        H["Error Message: A concise summary of the error."]
        I[Accordion: "View technical details"]
        J
    end
Caption: Wireframes for the Post-Run Summary state, showing both a success case with artifact links and an error case with retry actions.

Success (summary) State:
The SummaryCard will display a prominent success message and icon. It will reiterate the actions performed (e.g., "2 files created, 1 modified") and provide two forms of evidence: a direct link to the output directory (/artifacts/current-state/YYYY-MM-DD) and an ArtifactList where each file name is a direct link to the newly created or modified file. This fulfills its role as the "receipt" for the transaction.

Failure (error) State:
The ErrorNotice will display a clear failure message. It will present a concise, user-friendly summary of what went wrong. Verbose technical details, such as stack traces, will be available but collapsed by default within an accordion to avoid overwhelming the user. Most importantly, the notice must provide actionable next steps, including a "Retry" button and a "View Logs" link. If a partial apply is possible—a known risk in similar systems where some resources may be changed before an error occurs—the UI must communicate this with extreme clarity, warning the user that the system may be in an inconsistent state.   

Content and Accessibility
Copy Deck and Messaging
A centralized copy deck ensures consistency, clarity, and an action-oriented tone across the entire user interface. All user-facing text should be short and specific.

ID	Component/State	Copy Text	Notes
panel.label.dryRun	Plan Preview	Preview only (no changes will be applied)	Displayed when the plan is first shown.
plan.risk.delete	Plan Preview	Warning: This will permanently delete {count} file(s).	Used in the risk callout for destructive actions.
plan.cta.approve	Plan Preview	Approve & Apply...	The primary button to open the approval dialog.
approveDialog.title	Approval Dialog	Approval Required	The title of the modal dialog.
approveDialog.cta.confirm	Approval Dialog	Approve & Apply	The primary, confirming action in the dialog.
approveDialog.cta.cancel	Approval Dialog	Cancel	The secondary, dismissing action in the dialog.
summary.success.title	Summary Card	Changes Applied	Header for a successful run.
summary.link.artifacts	Summary Card	View output directory	Link to the main artifact folder.
error.title	Error Notice	Apply Failed	Header for an unsuccessful run.
error.retry.cta	Error Notice	Retry	The primary action in the error state.

Export to Sheets
Accessibility Blueprint
This blueprint translates accessibility guidelines into a concrete specification for developers, ensuring the feature is usable by everyone.

State/Component	Focus Order	Screen Reader (SR) Announcements	Keyboard Shortcuts
Plan Preview	1. Run/Approve Button, 2. Diff Viewer content, 3. Artifact List items	On load: "Plan ready for review. Proposing {X} creations, {Y} modifications, {Z} deletions."	N/A
Approval Dialog	1. Cancel Button (initial focus), 2. Approve & Apply Button, 3. (if present) Close 'X' icon	On open: "Approval Required dialog. This action will create {X} files and modify {Y}. This action is irreversible."	Escape: Closes dialog, returns focus. Tab/Shift+Tab: Cycles focus within dialog.
Summary Card	1. "View output directory" link, 2. Individual artifact links	On load: "Apply complete. {X} files created, {Y} modified."	N/A
Error Notice	1. Retry Button, 2. "View technical details" control	On load: "Error: Apply failed. {Error summary text}."	N/A

Export to Sheets
Measurement and Verification
Telemetry and Performance Metrics
To measure the feature's effectiveness and identify areas for improvement, a minimal, privacy-conscious set of telemetry events will be captured. The collection strategy will be intentional, transparent, and will not capture any personally identifiable information (PII). Data will be processed to redact any potentially sensitive information and filter out noise, such as health check spans.   

Event Name	Trigger	Properties	Rationale
run_initiated	User clicks the initial "Run" button.	{ timestamp }	Measures user engagement with the feature's entry point.
approval_step_shown	The ApproveDialog is displayed.	{ timestamp, plan_hash }	Tracks how often users proceed to the final confirmation step.
approval_step_completed	User clicks "Approve & Apply" or "Cancel".	{ timestamp, approved: [true|false] }	Measures approval vs. cancellation rates, indicating potential friction or confusion in the plan preview.
run_completed	The execute phase finishes (success or failure).	{ timestamp, duration_ms, exit_code, plan_hash, artifact_count, artifact_hashes }	The core event for measuring overall task success, performance, and the integrity of the transaction.

Export to Sheets
Testable Acceptance Criteria
This checklist provides a set of verifiable conditions that the feature must meet to be considered complete and ready for release. The criteria are written to be clear, testable, and focused on user outcomes rather than implementation details.   

Functional Criteria:

[ ] Given the panel is in the idle state, when the user clicks "Run", then the panel must transition to the planning state and subsequently to the review state upon completion.

[ ] Given the panel is in the review state, when the user clicks "Approve & Apply...", then the ApproveDialog must appear.

[ ] Given the user confirms the ApproveDialog, then the apply=true parameter must be passed to the execution engine and the panel must transition to the executing state.

[ ] Given the execution succeeds, then the summary state must be displayed, and all artifact links must point to the correct path format: /artifacts/current-state/YYYY-MM-DD/....

[ ] Given the execution fails, then the error state must be displayed with an enabled "Retry" action.

[ ] Given the user clicks "Cancel" in the ApproveDialog, then the dialog must close and the panel must remain in the review state.

Accessibility Criteria:

[ ] When the ApproveDialog is open, keyboard focus must be trapped within its interactive elements.

[ ] When the ApproveDialog is open, pressing the Escape key must close it and return focus to the "Approve & Apply..." button.

[ ] When the ApproveDialog opens, initial keyboard focus must be programmatically set on the "Cancel" button.

[ ] When each panel state loads, a screen reader must announce the corresponding status message (e.g., "Plan ready for review," "Apply complete").

Data Criteria:

[ ] Upon completion of an execution, the run_completed telemetry event must be fired with a valid exit_code (0 for success, non-zero for failure) and a duration_ms value greater than 0.

[ ] The artifact_count in the run_completed event must match the number of files listed in the post-run summary.


Sources used in the report

developer.hashicorp.com
Create a Terraform plan - HashiCorp Developer
Opens in a new window

developer.hashicorp.com
terraform apply command reference - HashiCorp Developer
Opens in a new window

spacelift.io
Terraform Apply - When to Run & Quick Usage Examples - Spacelift
Opens in a new window

docs.github.com
Approving workflow runs from forks - GitHub Docs
Opens in a new window

larksuite.com
Approval workflow: Speed, design, best practices | Lark
Opens in a new window

birdviewpsa.com
Approval workflow software: your guide to streamlined operations - Birdview PSA
Opens in a new window

atlassian.com
Optimize Your Approval Process | The Workstream - Atlassian
Opens in a new window

medium.com
Approval Process for Terraform Deployments Using Jenkins | by Venkata Durgaprasad | Niveus Solutions Stories | Medium
Opens in a new window

uxmatters.com
User-Centered Design Artifacts - UXmatters
Opens in a new window

yellowslice.in
UX Design Deliverables: Essential Documents and Artefacts for Successful Design Projects
Opens in a new window

storybook.js.org
Types of addons | Storybook docs
Opens in a new window

kissflow.com
Ultimate Guide to Automated Approval Processes 2025 - Kissflow
Opens in a new window

dev.to
Understanding Diff Formats: A Developer's Guide to Making Sense of Changes
Opens in a new window

ux.stackexchange.com
Side-by-side code diff view UX - User Experience Stack Exchange
Opens in a new window

learn.microsoft.com
Creating Useful Views for Lists & Libraries | Microsoft Learn
Opens in a new window

w3.org
Dialog (Modal) Pattern | APG | WAI - W3C
Opens in a new window

schalkneethling.com
The HTML Dialog Element: A Native Solution for Accessible Modal Interactions
Opens in a new window

w3.org
Modal Dialog Example | APG | WAI | W3C
Opens in a new window

marcon.me
6 telemetry best practices for CLI tools - Massimiliano Marcon
Opens in a new window

honeycomb.io
OpenTelemetry Best Practices #3: Data Prep and Cleansing - Honeycomb
Opens in a new window

testomat.io
Clear Acceptance Criteria for User Stories the BDD way - Testomat.io
Opens in a new window

atlassian.com
Acceptance Criteria Explained [+ Examples & Tips] | The Workstream - Atlassian
Opens in a new window

resources.scrumalliance.org
Acceptance Criteria: Everything You Need to