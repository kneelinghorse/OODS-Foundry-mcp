# R28.1 Separation of Duty (SoD) Constraint Patterns

## 1.0 Introduction

This report provides a comprehensive overview of Separation of Duty (SoD) constraint patterns, including a taxonomy of canonical patterns, guidance on database schema design for storing SoD policies, and strategies for enforcement.

## 2.0 Taxonomy of SoD Constraint Patterns

### 2.1 Static Separation of Duty (SSoD)

- **Definition:** Prevents a user from being assigned to conflicting roles simultaneously.
- **Example:** A user cannot be both a "payment initiator" and a "payment authorizer".
- **Enforcement:** Enforced at the time of role assignment.

### 2.2 Dynamic Separation of Duty (DSoD)

- **Definition:** Allows a user to be assigned to conflicting roles but prevents them from exercising conflicting permissions within the same session or during a specific task.
- **Example:** A user with both "purchasing" and "approving" roles cannot approve their own purchase.
- **Enforcement:** Enforced at the time of the action (e.g., a transaction).

### 2.3 Quorum-based Separation of Duty

- **Definition:** Requires a minimum number of approvals (a quorum) from a defined group before a critical action can be performed.
- **Example:** A financial transaction over a certain amount requires approval from at least three out of five designated managers.
- **Enforcement:** Enforced at the time of the action, requiring multiple approvals.

## 3.0 Database Schema Patterns for SoD Policies

This section will provide detailed guidance on how to model SoD policies in a relational database, including example schemas.

Based on the foundational 5-table RBAC model described in the `R21.2` research report, we will create a new schema named `authz_sod` to house the tables required for storing SoD constraints. This approach keeps the SoD-related tables separate from the core RBAC model, improving modularity and clarity.

### 3.1 Static SoD Schema

Static SoD constraints are defined as conflicts between roles. We will create a table to store these conflicting role pairs.

```sql
CREATE SCHEMA authz_sod;

CREATE TABLE authz_sod.static_role_conflicts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    role_id_1 UUID NOT NULL REFERENCES authz.roles(id),
    role_id_2 UUID NOT NULL REFERENCES authz.roles(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (role_id_1, role_id_2)
);
```

### 3.2 Dynamic SoD Schema

Dynamic SoD constraints are defined as conflicts between permissions. We will create a table to store these conflicting permission pairs.

```sql
CREATE TABLE authz_sod.dynamic_permission_conflicts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    permission_id_1 UUID NOT NULL REFERENCES authz.permissions(id),
    permission_id_2 UUID NOT NULL REFERENCES authz.permissions(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (permission_id_1, permission_id_2)
);
```

### 3.3 Quorum-based SoD Schema

Quorum-based SoD requires a more complex schema to manage policies, track approvals, and link them to actions.

First, we define a table for the quorum policies themselves:

```sql
CREATE TABLE authz_sod.quorum_policies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    description TEXT,
    quorum_threshold INTEGER NOT NULL CHECK (quorum_threshold > 0),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

Next, we need a table to associate these policies with specific permissions that require quorum approval:

```sql
CREATE TABLE authz_sod.quorum_policy_permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    policy_id UUID NOT NULL REFERENCES authz_sod.quorum_policies(id),
    permission_id UUID NOT NULL REFERENCES authz.permissions(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (policy_id, permission_id)
);
```

Finally, we need a table to track the approvals for a specific action that is subject to a quorum policy.

```sql
CREATE TABLE authz_sod.quorum_approvals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    policy_id UUID NOT NULL REFERENCES authz_sod.quorum_policies(id),
    action_identifier TEXT NOT NULL, -- A unique identifier for the action being approved
    approver_id UUID NOT NULL REFERENCES core.users(id),
    approved_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (policy_id, action_identifier, approver_id)
);
```


## 4.0 Enforcement Strategies

This section will discuss the trade-offs between different enforcement strategies, such as database triggers and application-layer enforcement.

The choice of enforcement strategy depends on several factors, including the complexity of the SoD policies, the performance requirements of the system, and the existing architecture of the application.

### 4.1 Database-Level Enforcement (Triggers)

Database triggers can be used to enforce SoD constraints directly within the database. For example, a trigger could be created on the `authz.memberships` table to prevent a user from being assigned to a role that conflicts with their existing roles.

**Pros:**

*   **Data Integrity:** Enforcement is close to the data, ensuring that no invalid data can be inserted into the database.
*   **Centralized Logic:** The SoD enforcement logic is centralized in the database, making it easier to manage and update.
*   **Atomicity:** The SoD check and the data modification are part of the same transaction, ensuring atomicity.

**Cons:**

*   **Complexity:** Writing and maintaining database triggers can be complex, especially for complex SoD policies.
*   **Performance:** Triggers can add overhead to database operations, potentially impacting performance.
*   **Portability:** Trigger implementations can be database-specific, making it harder to migrate to a different database system.
*   **Limited Context:** Triggers have limited access to application-level context, which may be required for some DSoD scenarios.

### 4.2 Application-Layer Enforcement

SoD constraints can also be enforced in the application code. For example, the application could check for SoD violations before assigning a role to a user or executing a sensitive transaction.

**Pros:**

*   **Flexibility:** The application has access to the full context of the user's session, making it easier to implement complex DSoD policies.
*   **Performance:** The SoD checks can be performed before the database transaction begins, reducing the overhead on the database.
*   **Portability:** The enforcement logic is part of the application code, making it portable across different database systems.
*   **Easier to Test:** Application-level logic is generally easier to unit test than database triggers.

**Cons:**

*   **Data Integrity:** There is a risk that a bug in the application code could allow a SoD violation to occur.
*   **Decentralized Logic:** The SoD enforcement logic may be scattered throughout the application, making it harder to manage.
*   **Race Conditions:** Care must be taken to avoid race conditions where a user's permissions change between the time of the SoD check and the time of the action.

### 4.3 Recommended Approach

For most scenarios, a hybrid approach is recommended:

*   **Static SoD:** Enforce SSoD constraints using database triggers on the `authz.memberships` table. This ensures that the role assignments are always valid.
*   **Dynamic SoD and Quorum-based SoD:** Enforce DSoD and Quorum-based SoD constraints in the application layer. This provides the flexibility needed to handle the complexities of these types of policies.

This hybrid approach provides a good balance between data integrity, performance, and flexibility.

## 5.0 Example Implementation

This section will provide a concrete example of how to implement an SoD policy, including the policy definition, database schema, and enforcement logic.

We will use a Static SoD policy as an example.

### 5.1 Policy Definition

**Policy:** A user cannot be both a "Payment Initiator" and a "Payment Authorizer".

### 5.2 Database Setup

First, we need to get the UUIDs of the "Payment Initiator" and "Payment Authorizer" roles from the `authz.roles` table. Let's assume they are `'...role_id_1...'` and `'...role_id_2...'` respectively.

Next, we insert the conflicting role pair into the `authz_sod.static_role_conflicts` table:

```sql
INSERT INTO authz_sod.static_role_conflicts (role_id_1, role_id_2)
VALUES ('...role_id_1...', '...role_id_2...');
```

### 5.3 Enforcement Logic (PostgreSQL Trigger)

Now, we create a trigger function that will be executed whenever a new role is assigned to a user in the `authz.memberships` table. The function will check if the new role conflicts with any of the user's existing roles.

```sql
CREATE OR REPLACE FUNCTION authz.check_static_sod_violation()
RETURNS TRIGGER AS $$
DECLARE
    conflicting_role_id UUID;
BEGIN
    -- Check for conflicts when a new role is assigned
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.role_id IS DISTINCT FROM OLD.role_id) THEN
        -- Find a conflicting role that the user is already a member of
        SELECT role_id_2 INTO conflicting_role_id
        FROM authz_sod.static_role_conflicts
        WHERE role_id_1 = NEW.role_id
          AND role_id_2 IN (SELECT role_id FROM authz.memberships WHERE user_id = NEW.user_id AND organization_id = NEW.organization_id);

        IF conflicting_role_id IS NOT NULL THEN
            RAISE EXCEPTION 'Static SoD violation: User cannot be assigned role % because they already have role %', NEW.role_id, conflicting_role_id;
        END IF;

        -- Also check the other direction of the conflict
        SELECT role_id_1 INTO conflicting_role_id
        FROM authz_sod.static_role_conflicts
        WHERE role_id_2 = NEW.role_id
          AND role_id_1 IN (SELECT role_id FROM authz.memberships WHERE user_id = NEW.user_id AND organization_id = NEW.organization_id);

        IF conflicting_role_id IS NOT NULL THEN
            RAISE EXCEPTION 'Static SoD violation: User cannot be assigned role % because they already have role %', NEW.role_id, conflicting_role_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER enforce_static_sod
BEFORE INSERT OR UPDATE ON authz.memberships
FOR EACH ROW EXECUTE FUNCTION authz.check_static_sod_violation();
```

This trigger will automatically prevent any user from being assigned to both the "Payment Initiator" and "Payment Authorizer" roles within the same organization.

## 6.0 Conclusion

This report has provided a comprehensive overview of Separation of Duty (SoD) constraint patterns, including a taxonomy of canonical patterns (Static, Dynamic, and Quorum-based), guidance on database schema design for storing SoD policies, and a discussion of enforcement strategies.

By understanding the different types of SoD constraints and the trade-offs between different enforcement strategies, organizations can design and implement a robust SoD solution that meets their specific security and compliance requirements. The recommended hybrid approach, using database triggers for Static SoD and application-layer enforcement for Dynamic and Quorum-based SoD, provides a good balance of data integrity, performance, and flexibility.

The example implementation provided in this report serves as a starting point for organizations looking to implement SoD in their own systems. By following the guidance and examples in this report, organizations can build a secure and compliant authorization system that enforces the principle of least privilege and protects against fraud and errors.
