Canonical Model Reconciliation for Subscription and Invoice Statuses: Stripe and Chargebee Integration Analysis
Executive Summary
This report presents a comprehensive analysis and validation of canonical data models for Subscription and Invoice objects, specifically by reconciling them against the current API implementations of Stripe and Chargebee. The primary objective is to establish a robust, provider-agnostic set of status enums that accurately reflect the complete billing lifecycle, rectify existing model inaccuracies, and provide a solid foundation for building scalable and reliable billing-related features.

The analysis reveals several critical findings that necessitate a significant update to the existing canonical models. For the Invoice object, the current model incorrectly includes past_due and retrying as distinct API-level statuses. Investigation shows these are merely user interface badges within the Stripe ecosystem, applied to invoices that are fundamentally in an open state. Furthermore, the inclusion of a refunded status is a categorical error; refunds are financial operations executed against paid invoices, often via credit notes, but they do not alter the terminal paid status of the invoice itself.   

For both Subscription and Invoice models, the existing canonical sets lack the granularity to represent crucial modern billing workflows. Key states such as future (for scheduled subscription starts), non_renewing (for subscriptions pending cancellation), pending (for metered billing invoices), and posted (for invoices with net payment terms) are absent. These omissions limit the system's ability to accurately model and communicate the full range of billing scenarios offered by providers like Chargebee.   

The primary recommendation of this report is the adoption of revised and expanded canonical models for both Subscription and Invoice statuses. These new models, detailed within, are designed to resolve the identified discrepancies, introduce the necessary granularity for future-proofing the billing abstraction layer, and enable the development of more precise and intuitive user interface states. Implementing these changes will significantly enhance system accuracy, reduce state-related bugs, and improve the clarity of communication with end-users regarding their billing status.

Part I: Subscription Status Model Analysis
This section deconstructs the subscription lifecycle as implemented by Stripe and Chargebee. It identifies the official, API-level statuses for each provider, analyzes their respective state transition models, and synthesizes these findings into a single, robust canonical model that accommodates the nuances of both platforms.

1.1 Stripe Subscription Status Deep Dive
Stripe's subscription model is centered around the payment status of associated invoices, particularly the initial and renewal invoices. Understanding its statuses requires a close examination of the events that trigger transitions between them.

Official Status Enumeration & Definitions
Stripe's API documentation and lifecycle guides confirm a set of distinct, machine-readable statuses for the Subscription object:

trialing: This status indicates that the subscription is in a free trial period. During this time, the customer is not charged, but service can and should be provisioned. The subscription automatically transitions to active upon the successful payment of the first invoice at the end of the trial period.   

active: The subscription is in good standing, and the customer is entitled to service. This status is achieved after a successful initial payment or a trial conversion. It is crucial to note that an active status only confirms that the most recent invoice required to maintain service has been paid; it does not guarantee that all historical invoices associated with the subscription are settled.   

incomplete: This is a transient, initial state for a subscription where the first invoice has been created but payment has not been successfully collected. This often occurs when customer action is required, such as completing a 3D Secure authentication for SCA compliance. The associated invoice has a status of open. This state typically has a 23-hour window for the customer to complete the payment.   

incomplete_expired: This is a terminal state. It occurs if the payment for an incomplete subscription is not completed within the allotted 23-hour window. The subscription cannot be reactivated from this state, and a new one must be created.   

past_due: This status signifies that a renewal payment for an active subscription has failed. Stripe's dunning processes, such as Smart Retries, may be actively attempting to collect payment during this period. Service access may be restricted based on business logic. A successful payment of the outstanding invoice will transition the subscription back to active.   

canceled: This is a terminal state indicating that the subscription has been permanently stopped. This can be initiated by a direct API call, through the customer portal, or as the final step in a failed dunning process. The subscription will not generate any future invoices.   

unpaid: This is an optional state that can be configured to follow past_due. While in this state, new invoices may continue to be generated, but Stripe will not attempt to collect payment for them. This status serves as a stronger signal than past_due to revoke service access, as it represents a deliberate cessation of collection attempts before a final cancellation.   

Lifecycle and State Transitions
The lifecycle of a Stripe subscription is heavily event-driven. A typical flow begins with either trialing or incomplete, depending on the setup. A successful payment transitions the subscription to active. From active, a failed renewal payment moves it to past_due. The past_due state can then resolve back to active upon payment, or escalate to unpaid or canceled based on dunning settings.   

The initial state is significantly influenced by the payment_behavior parameter used during subscription creation. For instance, allow_incomplete (the default) permits the subscription to enter the incomplete state, whereas error_if_incomplete will cause the API call to fail if the initial payment cannot be processed immediately.   

Furthermore, the payment method itself can alter the lifecycle. Asynchronous payment methods like ACH Direct Debit often cause the subscription to move directly to active, bypassing the incomplete state entirely. A subsequent payment failure on such a method would then be handled through other means, potentially voiding the invoice while the subscription remains temporarily active.   

Stripe also accommodates future-dated subscriptions through a separate but related resource: Subscription Schedules. A schedule allows for defining phases for a subscription, including a start_date in the future. While the subscription itself does not have a future status, its lifecycle is governed by the schedule until it begins, at which point it assumes one of the standard statuses like trialing or active.   

The distinction between the past_due and unpaid statuses reveals a sophisticated, two-stage approach to handling payment failures. The past_due state represents a "soft" dunning phase, where payment is actively being retried and the subscription is considered recoverable. In contrast, the unpaid state represents a "hard" dunning phase, where collection attempts have ceased, signaling a more severe payment issue that likely warrants immediate service revocation, even before the subscription is formally canceled. This two-tiered failure model provides more granular control over customer communication and service access during the dunning process.

A foundational principle of Stripe's model is the inextricable link between a subscription's initial state and its first invoice. The documentation repeatedly emphasizes that a subscription only becomes active once its first invoice is successfully paid. Actions on this first invoice have direct consequences for the subscription; for example, voiding the first invoice of an incomplete subscription terminally moves it to incomplete_expired. This dependency dictates that a robust system integration cannot rely solely on the customer.subscription.created webhook as a signal to provision service. The definitive trigger for service entitlement is the invoice.paid event for that first invoice. Relying on the creation event alone creates a significant risk of granting service access to customers who have not completed payment.   

1.2 Chargebee Subscription Status Deep Dive
Chargebee's subscription model is more descriptive and lifecycle-oriented, with statuses that explicitly represent the business state of the subscription rather than just its payment status.

Official Status Enumeration & Definitions
Chargebee's API documentation provides a clear and comprehensive list of subscription statuses:

future: The subscription has been created but is scheduled to begin at a later date. No service is active, and no billing occurs. On its specified start_date, it will transition to either in_trial or active.   

in_trial: The subscription is currently in a free trial period. The customer has access to the service but is not being charged.   

active: The subscription is active, and the customer is being billed according to the plan's terms. This is the standard state for a paying customer in good standing.   

non_renewing: The subscription is currently active and the customer retains service access, but it has been scheduled to be canceled at the end of the current billing term. It will not renew automatically.   

paused: The subscription has been temporarily halted, either by an administrator or the customer. Billing and service access are typically suspended during this period. The subscription can be resumed, at which point it would return to an active state.   

canceled: This is a terminal state. The subscription is inactive, billing has ceased, and the customer no longer has access to the service.   

transferred: A specialized status used in Chargebee's multi-business-entity feature. It indicates that the subscription has been moved from one business entity to another. This status is highly specific to Chargebee's architecture and is generally not applicable to a universal canonical model.   

Lifecycle and State Transitions
The Chargebee subscription lifecycle follows a logical progression of business states. A new subscription can start as future and then transition to in_trial or directly to active. An active subscription can be paused, or a cancellation can be scheduled, which moves it to the non_renewing state. From paused or non_renewing, the subscription can either be reverted to active (by resuming or removing the scheduled cancellation) or proceed to the terminal canceled state at the appropriate time.   

A key mechanism governing the lifecycle in Chargebee is the "Number of Billing Cycles" setting. This allows a subscription to be configured with a finite lifetime. When the configured number of renewals is complete, the subscription automatically transitions to non_renewing and is subsequently canceled at the end of its final term.   

Chargebee's non_renewing status provides a powerful and explicit representation of a common business scenario: a customer cancels but retains access until their paid-through period ends. This contrasts with Stripe's approach, which handles this case via a boolean flag, cancel_at_period_end. In Stripe, a subscription with this flag set remains in the active status until the end of the billing period, at which point its status changes directly to canceled. Chargebee's use of a distinct non_renewing status creates a clearer state machine. For an application building on top of this, it is much simpler to design UI elements—such as a banner stating "Your subscription will be canceled on [date]"—by reacting to a single, unambiguous status rather than checking for a combination of a status (active) and a boolean flag (cancel_at_period_end). Adopting a similar explicit status in a canonical model greatly simplifies application logic.

1.3 Proposed Canonical Subscription Model
Synthesizing the models from Stripe and Chargebee allows for the creation of a comprehensive canonical model that captures the full subscription lifecycle and resolves inconsistencies between the two providers.

Subscription Status Mapping
The following table provides a detailed mapping from each provider's status set to the proposed canonical model, including the logic required for accurate translation.

Provider	Provider Status	Canonical Status	Mapping Logic / Notes
Stripe	trialing	trialing	Direct one-to-one mapping.
active	active	Map to active only if cancel_at_period_end is false.
active	non_renewing	Map to non_renewing if cancel_at_period_end is true. This correctly represents the pending cancellation state.
past_due	past_due	Direct one-to-one mapping. Represents a recoverable payment failure.
unpaid	past_due	Grouped with past_due. While Stripe differentiates them, a single past_due canonical state simplifies the model. The distinction can be captured in metadata if necessary.
canceled	canceled	Direct one-to-one mapping. Terminal state.
incomplete	incomplete	Direct one-to-one mapping. Represents the initial payment pending state.
incomplete_expired	incomplete_expired	Direct one-to-one mapping. Terminal state for failed initial payments.
N/A (via Schedules)	future	Map to future if a subscription is governed by a Subscription Schedule with a start_date in the future.
N/A (via logic)	paused	Stripe does not have a native paused status. This must be implemented in the integration layer, typically by stopping payment collection. The canonical model should support it.
Chargebee	future	future	Direct one-to-one mapping.
in_trial	trialing	Direct one-to-one mapping.
active	active	Direct one-to-one mapping.
non_renewing	non_renewing	Direct one-to-one mapping.
paused	paused	Direct one-to-one mapping.
canceled	canceled	Direct one-to-one mapping.
transferred	Ignored	This status is specific to Chargebee's multi-entity architecture and is not generalizable for a canonical model.

Export to Sheets
Gap Analysis & Recommendations
A comparison of the providers' models with the user's current set (trialing, active, past_due, paused, canceled, incomplete, incomplete_expired) reveals gaps and areas for improvement.

Statuses to Deprecate/Redefine from User's Current Set:

The user's current set is a strong starting point. The status paused is correctly identified as a necessary state, mapping directly to Chargebee. The integration with Stripe will require custom logic to implement this functionality, as Stripe does not offer a native paused status, instead recommending patterns like pausing payment collection.   

Proposed Additions to Canonical Set:

future: This status is essential for representing subscriptions that are scheduled to start at a later date, a common requirement for B2B sales cycles and pre-orders. It maps directly to a native Chargebee status and can be derived from Stripe's Subscription Schedules feature. Adding this enum value provides an explicit state for this business case.   

non_renewing: This status is critical for accurately modeling the state of a subscription that is active but will terminate at the period's end. It maps directly to Chargebee's non_renewing status and can be derived from Stripe's cancel_at_period_end flag. Introducing this status provides a much clearer signal for UI and business logic than checking a combination of fields, simplifying the application code that handles end-of-life subscription management.   

Statuses to Ignore:

transferred (Chargebee): This is too specific to Chargebee's internal architecture for multi-entity businesses and lacks broad applicability for a general-purpose canonical model.   

unpaid (Stripe): For the sake of a simpler state machine, this can be conceptually grouped with past_due. The core business meaning—that payment is overdue and service is at risk—is captured by past_due. If the distinction between active retries (past_due) and ceased retries (unpaid) is critical, this can be managed with a secondary flag or metadata on the canonical subscription object rather than a top-level status.

Final Recommended Canonical Subscription Enum Set
Based on this comprehensive analysis, the following enum set is recommended for the canonical Subscription model. It provides complete coverage of the subscription lifecycle across both providers and introduces necessary states for modern billing workflows.

future: The subscription is scheduled to start at a future date.

trialing: The subscription is active and in a free trial period.

active: The subscription is active and in good payment standing.

past_due: A renewal payment has failed, and the subscription is in a dunning or recovery process.

paused: The subscription has been temporarily suspended and is not billing.

non_renewing: The subscription is active but will be canceled at the end of the current billing period.

canceled: The subscription has been terminated and will not renew.

incomplete: The subscription is awaiting a required initial payment or customer action.

incomplete_expired: The initial payment for the subscription was not completed in time, and it has been terminated.

Part II: Invoice Status Model Analysis
This section addresses a fundamental misunderstanding in the user's current invoice model regarding Stripe's statuses. It clarifies the true API-level states for each provider and proposes a new, more robust canonical model that correctly represents the invoice lifecycle, from creation and collection to final settlement.

2.1 Stripe Invoice Status Deep Dive
Stripe's invoice model is built around a concise set of five core, API-level statuses that represent the immutable stages of an invoice's life.

Official Status Enumeration & Definitions
The Stripe API and documentation consistently define only the following five statuses for an Invoice object:

draft: This is the initial state of any new invoice. In this state, the invoice is fully mutable—line items, customer details, and other attributes can be changed. A draft invoice cannot be paid and must be finalized before collection can begin.   

open: Once an invoice is finalized, its status changes to open. At this point, its core financial details become immutable to ensure compliance and record-keeping integrity. An open invoice is awaiting payment from the customer.   

paid: This is a terminal state indicating that the full amount of the invoice has been successfully collected. An invoice in the paid state cannot be changed.   

void: This is a terminal state used to cancel an open or uncollectible invoice. Voiding an invoice effectively makes it a zero-value record for accounting purposes, rendering it non-payable while preserving the invoice number and history.   

uncollectible: This is a terminal state for an open invoice that is deemed unlikely to be paid (e.g., due to customer bankruptcy). This allows the invoice to be written off as bad debt for accounting purposes. It can be transitioned to paid or void if circumstances change.   

Critical Distinction: UI Badges vs. API Statuses
A crucial point of clarification is the nature of terms like "Past Due" and "Retrying" in the Stripe ecosystem. The user's current canonical model incorrectly treats these as distinct statuses. However, Stripe's documentation explicitly states that these are not API statuses. Instead, they are presentational badges applied within the Stripe Dashboard to invoices that are in the open API state.   

An open invoice is considered "Past due" if the current date is past the due_date specified on the invoice object.

An open invoice is considered "Retrying" if Stripe's automated dunning logic is actively attempting to collect payment after an initial failure.

This is a critical architectural distinction. The state of the invoice at the API level remains open. The "past due" or "retrying" condition is derived state, determined by comparing the current time against the invoice's due_date and dunning metadata. Any canonical model must reflect this reality by separating the core status from this derived, presentational information.

The user's current canonical model, which includes past_due, retrying, and refunded, is therefore based on a flawed premise. It conflates the true, immutable API state with transient, derived UI state. This leads to an abstraction layer that is attempting to map to concepts that do not exist at the provider's API level, resulting in brittle and overly complex logic. The primary architectural correction required is to remove these derived states from the canonical status enum and instead represent them through other properties on the canonical invoice object, such as due_date and next_payment_attempt_timestamp. This creates a clean separation of concerns between the backend's source-of-truth state and the frontend's presentational logic.

Lifecycle and State Transitions
The Stripe invoice lifecycle is straightforward and linear. It begins in the draft state. The invoice.finalized webhook signals its transition to open. From open, it can transition to one of three terminal states: paid (triggered by an invoice.paid event), void (triggered by invoice.voided), or uncollectible (triggered by invoice.marked_uncollectible). A failed payment attempt, which triggers an invoice.payment_failed event, does not change the invoice's status; it remains open.   

2.2 Chargebee Invoice Status Deep Dive
In contrast to Stripe's concise model, Chargebee employs a more granular, workflow-based set of statuses that provide more context about the invoice's position in the billing and collections process.

Official Status Enumeration & Definitions
Chargebee's API defines the following statuses for its Invoice object:

pending: This status is specifically used for metered billing. An invoice is generated in a pending state at the end of a billing period, allowing for final usage data to be added before the invoice is "closed" and payment is attempted.   

posted: This status is used for invoices with payment terms (e.g., Net 30). The invoice has been finalized and sent to the customer, but payment is not yet due. It remains in the posted state until the due date is reached.   

payment_due: This status indicates that the invoice's due date has passed and payment has not been received. The invoice is now actively in the collections or dunning process. This is also the status used for in-progress direct debit payments before they have settled.   

not_paid: This is a terminal failure state. It signifies that all dunning attempts to collect payment have failed, and Chargebee will make no further automatic attempts.   

paid: This is a terminal success state, indicating the invoice has been paid in full.   

voided: This is a terminal state indicating the invoice has been canceled.   

Lifecycle and State Transitions
The Chargebee invoice lifecycle is more nuanced to accommodate complex B2B billing scenarios. An invoice for metered usage starts as pending, then closes and moves to posted or payment_due. An invoice with payment terms starts as posted. Once the due date arrives, it transitions to payment_due. From payment_due, it can either be successfully collected and move to paid, or exhaust all retries and move to the terminal not_paid state. An invoice can be voided from most non-paid states.   

This model provides more explicit information about why an invoice is awaiting payment. The distinction between posted (awaiting due date) and payment_due (actively in collections) is particularly valuable. Stripe's single open status covers both of these scenarios, requiring the consuming application to infer the context from the due_date. By adopting a more granular canonical model inspired by Chargebee, the abstraction layer becomes inherently more powerful and capable of supporting sophisticated billing logic without modification, even when the underlying provider (like Stripe) has a simpler model.

2.3 Proposed Canonical Invoice Model
A new canonical model is required to correct the user's current model and robustly handle the different philosophies of Stripe and Chargebee. The proposed model leans towards the greater granularity of Chargebee for future-proofing.

Invoice Status Mapping
The following table details the mapping from provider statuses to the proposed canonical model. It highlights the conditional logic needed to translate Stripe's simpler model into the richer canonical representation.

Provider	Provider Status	Canonical Status	Mapping Logic / Notes
Stripe	draft	draft	Direct one-to-one mapping.
open	open	Map to open if now() < due_date and payment is not actively being retried. This represents an invoice awaiting its due date.
open	past_due	Map to past_due if now() >= due_date. This correctly represents an overdue invoice that is in collection.
paid	paid	Direct one-to-one mapping. Terminal success state.
void	void	Direct one-to-one mapping. Terminal cancellation state.
uncollectible	uncollectible	Direct one-to-one mapping. Terminal write-off state.
Chargebee	pending	pending	Direct one-to-one mapping. For metered billing.
posted	open	Direct one-to-one mapping. Represents an invoice awaiting its due date.
payment_due	past_due	Direct one-to-one mapping. Represents an overdue invoice in collection.
not_paid	not_paid	Direct one-to-one mapping. Terminal failure state.
paid	paid	Direct one-to-one mapping.
voided	void	Direct one-to-one mapping.

Export to Sheets
Gap Analysis & Recommendations
The user's current invoice set (draft, open, paid, void, uncollectible, past_due, retrying, refunded) requires significant revision.

Statuses to Deprecate/Redefine from User's Current Set:

past_due: This status should be kept but redefined. It is not a direct mapping from a Stripe API status but rather a derived state that aligns perfectly with Chargebee's payment_due status. It should represent an invoice that is overdue and actively in collection.

retrying: This status should be strongly deprecated. It represents a transient sub-state of past_due and should not be a top-level enum. Including it adds unnecessary complexity to the state machine. The status of dunning attempts can be tracked via separate metadata fields if required.

refunded: This status should be strongly deprecated. A refund is an action performed on a paid invoice; it does not change the invoice's status. In both Stripe and Chargebee, refunds are managed through separate objects like Credit Notes or Refund objects. The canonical model must reflect this by tracking refunds as separate entities linked to the invoice, while the invoice itself remains paid.   

Proposed Additions to Canonical Set:

pending: This status should be added to natively support metered billing workflows. It maps directly to Chargebee's pending status. For a Stripe integration, an invoice could be considered pending if it is in the draft state but is associated with an active subscription that has metered components, awaiting final usage data before finalization.   

not_paid: This status should be added to represent a terminal payment failure. It maps directly to Chargebee's not_paid status. In a Stripe context, this would correspond to an open invoice where the dunning schedule has been exhausted, just before it is manually or automatically marked uncollectible. This provides a clearer "end of the line" failure state than uncollectible, which specifically implies a write-off for accounting purposes.   

Final Recommended Canonical Invoice Enum Set
The following enum set is recommended for the canonical Invoice model. It corrects the foundational errors in the current model and provides a comprehensive, future-proof framework for managing the entire invoice lifecycle.

draft: The invoice is being composed and has not been finalized.

pending: The invoice is finalized but is awaiting closure before payment collection (e.g., for metered usage aggregation).

open: The invoice is finalized and awaiting payment, but is not yet past its due date.

past_due: The invoice is finalized, past its due date, and payment collection is being actively attempted.

paid: The invoice has been successfully paid.

void: The invoice has been canceled and is non-payable.

uncollectible: The invoice has been written off as bad debt.

not_paid: All payment attempts have failed, and no further collection will be attempted.

Part III: Dynamic Lifecycles and UI/UX Implications
Defining static statuses is only half the task. A successful billing system must be architected to handle the dynamic, event-driven nature of these objects and translate their states into clear, actionable information for the user.

3.1 The Imperative of a Webhook-Driven Architecture
Maintaining state consistency in a distributed system that includes third-party billing providers is impossible to achieve reliably through API polling. Polling is inefficient, introduces latency, and is highly susceptible to race conditions where the local system's state falls out of sync with the provider's state.

The only reliable source of truth for state transitions is the event stream provided by the billing platforms via webhooks. The system's architecture must be fundamentally webhook-driven. This means designing ingestion services capable of processing these events asynchronously and, critically, idempotently. Because webhooks can be delivered more than once due to network issues or retries, the processing logic must be able to handle duplicate events without causing unintended side effects, typically by tracking processed event IDs.   

3.2 Comparative Event Mapping
To build a resilient webhook ingestion service, it is essential to map the key state-transition events between providers to a common set of internal handlers.

State Transition	Stripe Webhook Event	Chargebee Webhook Event	Notes
Invoice Finalized	invoice.finalized	invoice_generated	
Triggers the move from draft to an open state. For Chargebee metered billing, invoice_generated is also fired when a pending invoice is closed.

Invoice Paid	invoice.paid	payment_succeeded	The primary signal that an invoice is paid and service should be provisioned or continued.
Invoice Payment Failed	invoice.payment_failed	payment_failed	Indicates a recoverable failure; the invoice moves into or remains in a past_due state.
Subscription Canceled	customer.subscription.deleted	subscription_cancelled	The definitive event for a subscription's termination.
Customer Action Required	invoice.payment_action_required	N/A (Handled via payment intent status)	
A critical Stripe event for SCA, signaling that the UI must prompt the user to authenticate the payment.

  
3.3 Handling Transient and Derived States in the User Interface
The nuanced states defined in the proposed canonical models have direct implications for creating a clear and trustworthy user experience. The UI must accurately reflect the subscription and invoice status to prevent confusion and build confidence.

Stripe's incomplete state: When a subscription is in the canonical incomplete state, the UI must not simply display "Subscribed." This would be misleading. Instead, it should present a clear call to action, such as, "Please confirm your payment to activate your subscription." This state is often triggered by the invoice.payment_action_required event, which provides the necessary context to guide the user through the required steps, like 3D Secure authentication.   

Chargebee's payment_due for Direct Debit: When an invoice is past_due (mapping from payment_due) and the underlying payment method is a direct debit like ACH, the payment can be in progress for several days. The UI should not display an alarming "Payment Failed" message. A more accurate and reassuring message would be, "Payment processing. This may take 3-5 business days to confirm." This correctly sets user expectations for asynchronous payment methods.   

Canonical past_due: The past_due canonical status should trigger UI elements indicating a payment problem. This is where the concept of derived state is correctly applied at the application level. Based on the past_due status combined with metadata like next_payment_attempt_timestamp, the UI can display context-specific messages like "Payment Overdue" or "We are retrying your payment. Please update your payment method if needed."

Canonical non_renewing: This status provides a powerful and unambiguous signal to the UI. It should trigger a persistent, non-dismissible banner within the user's account settings, clearly stating: "Your subscription is scheduled to be canceled on. You will retain full access until then." This proactive communication prevents surprise cancellations and correctly manages user expectations.

Conclusion & Consolidated Recommendations
The analysis of Stripe and Chargebee's billing models reveals the necessity of a significant revision to the existing canonical status enums for Subscriptions and Invoices. The current models contain foundational inaccuracies and lack the granularity required to support modern, complex billing workflows. By conflating API statuses with UI badges and omitting key lifecycle states, the existing models introduce unnecessary complexity and risk into the billing abstraction layer.

This report has detailed the precise, API-level statuses for both providers, deconstructed their respective lifecycles, and proposed a set of revised canonical models. These new models correct the identified flaws, introduce critical states like future, non_renewing, and pending, and establish a clear separation between core status and derived, presentational information. Adopting these recommendations will result in a more accurate, resilient, and future-proof billing architecture. It will enable a superior developer experience by providing a clear and consistent state machine, and it will foster a better user experience through more precise and transparent communication regarding billing status.

The final, consolidated recommendations for the canonical enum sets are as follows:

Final Recommended Canonical Subscription Enum Set:
["future", "trialing", "active", "past_due", "paused", "non_renewing", "canceled", "incomplete", "incomplete_expired"]

Final Recommended Canonical Invoice Enum Set:
["draft", "pending", "open", "past_due", "paid", "void", "uncollectible", "not_paid"]


Sources used in the report

support.stripe.com
Invoice States - Stripe Support
Opens in a new window

docs.stripe.com
How invoicing works | Stripe Documentation
Opens in a new window

docs.stripe.com
Status transitions and finalization - Stripe Documentation
Opens in a new window

chargebee.com
Invoice Operations - Chargebee Docs
Opens in a new window

chargebee.com
Working with Subscriptions - Chargebee Docs
Opens in a new window

apidocs.chargebee.com
Invoices - Chargebee API documentation
Opens in a new window

docs.stripe.com
How subscriptions work | Stripe Documentation
Opens in a new window

docs.stripe.com
Create a subscription | Stripe API Reference
Opens in a new window

docs.stripe.com
Subscription invoices - Stripe Documentation
Opens in a new window

docs.stripe.com
Update a subscription | Stripe API Reference
Opens in a new window

docs.stripe.com
Subscription schedules | Stripe Documentation
Opens in a new window

apidocs.chargebee.com
Subscriptions | Chargebee API documentation
Opens in a new window

apidocs.chargebee.com
Estimates - Chargebee API documentation
Opens in a new window

apidocs.chargebee.com
Subscriptions - Chargebee API documentation
Opens in a new window

chargebee.com
Subscription Lifetime - Chargebee Docs
Opens in a new window

docs.stripe.com
How invoicing works | Stripe Documentation
Opens in a new window

docs.stripe.com
Using webhooks with subscriptions - Stripe Documentation
Opens in a new window

chargebee.com
Invoices - Chargebee Docs
Opens in a new window

docs.stripe.com
Events | Stripe API Reference
Opens in a new window

chargebee.com
Events & Webhooks - Chargebee Docs
Opens in a new window

apidocs.chargebee.com
Events - Chargebee API documentation
Opens in a new window

chargebee.com
Invoice Generated event - Stay updated about your new invoi