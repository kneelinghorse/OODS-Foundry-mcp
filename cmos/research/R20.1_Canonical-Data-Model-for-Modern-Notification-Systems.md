A Canonical Data Model for Modern Notification Systems: Analysis of Cross-Platform Schemas, State Management, and Delivery Orchestration
1.0 Introduction: Defining the Notification Intent
Notification systems have evolved from simple "fire-and-forget" alert mechanisms into the primary, stateful communication backbone of all modern software. They are the principal driver of user engagement, the conduit for critical transactional alerts, and a core component of asynchronous application architecture.   

This report analyzes and documents the canonical data model for these systems, establishing a universal blueprint derived from the documented APIs of leading platforms. The scope of this analysis includes mobile push (APNs, FCM), chat (Slack, Discord), multi-channel orchestrators (Twilio, OneSignal, Pusher, SendGrid, Amazon SNS, Azure Notification Hubs), and native platform frameworks.

The central concept of this analysis is the "Notification Intent." This is a single, abstract data object that represents the system's intent to communicate with a user. This object is channel-agnostic; it defines the "what" (content), "who" (recipient), "why" (topic), and "how" (priority, actionability) of the message before it is translated into the disparate, platform-specific payloads required for final delivery. This report deconstructs this "Intent" and the processes that act upon it.

2.0 The Canonical Notification Object: The "Intent" Schema
The Notification Intent is the logical record created the moment a system decides a user must be alerted. Its structure is a superset of all common fields found across notification providers.

2.1 Core Identity and Routing Fields
At its inception, the Intent must contain four core fields:

id (UUID/String): A unique, immutable identifier for the notification intent itself. This is distinct from any provider-specific IDs generated later (e.g., Slack's message_ts  or OneSignal's notificationId ).   

recipient_id (String/UUID): The foreign key to the canonical User object. This is a critical abstraction. The system targets a user, not a device. This ID (referred to as Identity by Twilio  or external_id by OneSignal ) is used to subsequently look up the user's preferences and their array of destination endpoints (device tokens, email addresses, etc.).   

topic_id (String/Enum): A system-defined category for the notification (e.g., billing_alert, new_message, marketing_promo). This field is the primary key for managing user preferences and applying legal rules (e.g., transactional vs. marketing).

created_at (Timestamp): The timestamp of the event that generated the intent.

2.2 The Content Model: Text, Rich, and Raw
The content model diverges based on the destination channel's capabilities.

Simple Text Model: The most common pattern, with high convergence across platforms. It consists of a title and body.

Firebase (FCM): notification.title, notification.body    

Apple (APNs): aps.alert.title, aps.alert.body    

OneSignal (Abstraction): headings, contents    

Rich Content Model: Chat and in-app platforms utilize structured, non-linear content models.

Slack: The chat.postMessage API uses blocks, a JSON array defining UI components (sections, images, buttons).   

Discord: The Message object supports embeds, a rich object for structured content.   

A canonical content object must support both, allowing a simple title/body for Push/SMS/Email while providing a blocks or raw field for richer platforms.

2.3 Actionability (CTA) Model: "Indirect" vs. "Direct"
A key point of divergence is how Call-to-Action (CTA) buttons are defined.

The APNs "Indirect" Model: Apple's APNs payload does not directly define buttons. It specifies a category string within the aps dictionary. This string must match a UNNotificationCategory that the client application has pre-registered with the operating system on launch. This pre-registered category contains the definitions for the buttons and their associated client-side actions. This is a security-focused model that gives the client app full control and prevents a server from defining arbitrary, potentially malicious, client-side code execution paths.   

The Android/Web "Direct" Model: Native Android's Notification.Builder allows for dynamically adding actions via methods like AddAction. This method takes a title, an icon, and a PendingIntent (the code to run). This means the client-side code constructs the actions at runtime based on data received in the notification payload.   

Orchestration platforms like OneSignal abstract this complexity by providing a simple, unified buttons array in their API payload. Their client-side SDKs then perform the necessary translation—mapping to pre-defined categories on iOS while dynamically building the buttons on Android.   

A canonical actions model should be an array of objects, each with an id, title, and action_url for simple deep-linking.   

2.4 Metadata and System Fields
This is the "control plane" of the notification, containing instructions for the delivery system and the client application.

data (Custom Payload): This is the single most critical and universally converged-upon field. It is a JSON object of arbitrary key-value pairs intended for consumption by the client application, not the user.

Implementations: data (FCM, Twilio) , additionalData (OneSignal) , custom_data (OneSignal) , custom root-level keys (APNs).   

Architectural Significance: The data object is the true payload; the notification object (title/body) is merely a presentation layer for that data. The client app should always be designed to receive and parse the data object (e.g., {"order_id": "12345"}) to perform business logic like deep-linking or updating local state. The FCM "Notification message" vs. "Data message" distinction confirms this; "Data messages" are required to reliably trigger the app's onMessageReceived handler.   

priority / urgency: High convergence on this concept.

Twilio: priority: 'high' | 'low'.   

OneSignal: priority: 10 | 5 (maps to native).   

APNs (Modern): interruption-level ('passive', 'active', 'time-sensitive', 'critical').   

idempotency_key (String): An emerging best-practice pattern to prevent duplicate messages from failed API calls. OneSignal explicitly supports an idempotency_key.   

ttl (Integer): Time-to-Live, in seconds, defines how long a push provider (like APNs or FCM) should attempt delivery if the device is offline.   

Table 2.1: Canonical Notification Intent Schema
This schema represents the idealized "Notification Intent" object, synthesizing the fields and patterns analyzed across all platforms.

Field Path	Canonical Type	Description	Convergence	Platform Implementations (Field Name)
id	UUID/String	Unique identifier for this specific notification intent.	100%	notificationId (OneSignal), message_ts (Slack), NotificationSid (Twilio)
recipient_id	String	Foreign key to the canonical User object.	100%	Identity (Twilio), external_id (OneSignal), user (Discord)
topic_id	String/Enum	Internal category for preference management (e.g., billing, social).	70%	(Logical concept in orchestrators) category (APNs - for actions)
created_at	Timestamp	Timestamp of the originating event.	100%	timestamp (Discord)
content.title	String	The main headline of the notification.	90%	headings (OneSignal), notification.title (FCM), alert.title (APNs)
content.body	String	The main message text/body.	90%	contents (OneSignal), notification.body (FCM), alert.body (APNs), text (Slack)
content.blocks	Array<Object>	Structured UI components for rich-content platforms.	30%	blocks (Slack), embeds (Discord)
data	Object (JSON)	Custom key-value data for client-side processing. The true payload.	100%	data (FCM/Twilio), additionalData (OneSignal), Root-level keys (APNs), metadata (Slack)
priority	Enum(high, normal)	Delivery urgency and interruption level.	80%	priority (Twilio), priority / ios_interruption_level (OneSignal), priority (FCM)
actions	Array<Object>	Array of CTA buttons or quick replies.	60%	buttons (OneSignal), actions (Android), category (APNs - indirect)
idempotency_key	String	Optional key to prevent duplicate sends from API retries.	30%	idempotency_key (OneSignal)
grouping_key	String	Key used for stacking/collapsing notifications on the device.	50%	thread-id (APNs), android_group (Android), batchingKey (NotificationAPI)
ttl	Integer	Time-to-Live in seconds for push providers.	40%	ttl (Twilio), ttl (FCM)
send_after	Timestamp	Optional time to defer sending until (for scheduling).	50%	send_after (OneSignal)
3.0 Multi-Channel Orchestration and Delivery Taxonomy
Orchestration is the process of translating the single "Notification Intent" (Section 2.0) into one or more platform-specific payloads and dispatching them.

3.1 The Channel Taxonomy
The primary notification channels exhibit distinct technical characteristics:

Push (Mobile): The primary channel for real-time alerts. Governed by APNs (Apple)  and FCM (Firebase/Google). Payloads are ephemeral and strictly size-limited (e.g., 4KB for standard APNs notifications, 5KB for VoIP).   

Email (Transactional & Marketing): Handled by providers like SendGrid. Asynchronous, persistent, supports rich HTML content, and is subject to distinct legal regulations (see Section 5.1).   

SMS: Handled by providers like Twilio. High urgency, high cost, primarily text-only (or MMS), and subject to strict carrier regulations.   

In-App (Feed & Chat): Platforms like Slack  and Discord. These are persistent, stateful (read/unread), and utilize highly structured content models (blocks, embeds).   

Webhook (System-to-System): Platforms like Pusher  can be used for server-to-server notifications, which are not user-facing.   

3.2 Native Payload Analysis: The "Last Mile" Contract
Understanding the native payloads for APNs and FCM is critical, as all orchestration platforms must ultimately produce these.

Apple (APNs) Payload: The payload is a JSON dictionary. Apple's servers only read the top-level aps dictionary.   

aps.alert (Object): Contains the user-facing title and body.

aps.badge (Number): Sets the app icon badge count.

aps.sound (String): The name of a sound file.

aps.content-available: 1: Instructs the OS to deliver this as a silent background notification.

aps.mutable-content: 1: This key is essential for rich media. It tells the OS to wake the app's Notification Service Extension, allowing it to modify the payload (e.g., download and attach an image) before display.   

aps.thread-id (String): The key used for grouping notifications into a stack.   

Custom Data: All other keys at the root level (outside the aps dictionary) are considered custom data. APNs ignores them and passes them directly to the application's userInfo dictionary for processing.   

Firebase (FCM) Payload: The payload is a message object. It contains a critical architectural divergence:   

notification Object: This object contains the display-only fields (title, body).

data Object: This object contains custom key-value pairs.

The Divergence: As documented in system design guides , when an app is in the background, messages containing only a notification payload are handled by the Android system tray. The application's onMessageReceived handler is not called. This is a common developer pitfall, as it prevents the app from running logic (like deep-linking or analytics).   

The Solution: To reliably trigger the app's code, the payload must contain a data object (either data only, or both data and notification). This ensures onMessageReceived is always invoked, giving the application code control over handling the event.   

3.3 Orchestration Abstraction Patterns
Orchestration platforms abstract this native complexity using two primary API design patterns:

Pattern 1: The "Fan-Out" JSON Object (Explicit Targeting) This model requires the developer to provide a single JSON payload that contains distinct, nested JSON objects for each platform.

Amazon SNS: Uses the MessageStructure='json' parameter. The payload is a top-level JSON object with keys like default, APNS, and GCM. A significant drawback is that the values for the APNS and GCM keys must be string-escaped JSON, which is brittle and error-prone.   

Pusher Beams: A cleaner implementation of the same pattern. The API request takes a JSON object with interests (for targeting) and peer-level objects: apns: {...}, fcm: {...}, and web: {...}. These values are true JSON objects, not escaped strings, making the API far easier to use.   

Pattern 2: The "Unified + Override" Model (Implicit Targeting) This model provides a set of simple, unified fields (like title) and automatically maps them to the correct native fields. It then also allows for specific override fields.

Twilio Notify: The API request (application/x-www-form-urlencoded) takes a generic body field. This is used as the default. It also accepts apn: {...} and fcm: {...} objects that override the generic body for those specific channels.   

OneSignal: This is the most evolved version of the pattern. The create-message API  uses generic fields like contents, headings, and custom_data. It then includes channel-specific fields at the same level (e.g., email_subject, sms_media_urls, ios_attachments, android_channel_id). The OneSignal backend intelligently assembles the correct native payload for each subscribed channel.   

The "Fan-Out" model offers maximum control but requires maximum developer knowledge of native payloads. The "Unified" model offers maximum simplicity and abstraction, but the developer is limited to the features the orchestrator has chosen to abstract.

Table 3.1: Platform Orchestration Strategy Matrix
Platform	API Endpoint	Abstraction Model	Payload Format	Channel Override Keys
Amazon SNS	Publish	Fan-Out	application/json	
APNS, GCM, ADM (as escaped strings) 

Pusher Beams	.../publishes/interests	Fan-Out	application/json	
apns, fcm, web (as objects) 

Azure Notif. Hubs	.../messages	Fan-Out (Native) / Template	application/json	
(Headers: ServiceBusNotification-Format: apple or gcm) 

Twilio Notify	.../Notifications	Unified + Override	application/x-www-form-urlencoded	
apn, fcm, sms (as objects) 

OneSignal	.../notifications	Unified + Override	application/json	
ios_..., android_..., email_..., sms_... (as peer keys) 

Courier	.../send	Unified (via Templates)	application/json	
(Overrides handled in template UI, not payload) 

  
4.0 The Notification Lifecycle: A Canonical State Machine
A notification is not a single event; it is a long-lived object that transitions through multiple states. Tracking this lifecycle is essential for reliability and analytics.

4.1 Canonical State Transition Model
Synthesizing system design documentation  and platform APIs , the following canonical state machine is established:   

Pending (or Scheduled): The Notification Intent is created and stored but is not yet eligible for delivery. This occurs if send_after is in the future  or delivery is paused for "quiet hours".   

Queued: The notification is eligible and has been submitted to a message broker (e.g., Kafka, RabbitMQ) for asynchronous processing by a "Notification Sender" worker.   

Dispatched (or Sent): The worker successfully sent the payload to the third-party provider (e.g., received an HTTP 200 response from APNs, FCM, or Twilio). This is what FCM's analytics call "Sends".   

Failed (Transient): The provider returned a retryable error (e.g., HTTP 503 Service Unavailable, 429 Rate Limit). The system must re-queue the message, ideally with exponential backoff.   

Failed (Permanent): The provider returned a non-retryable error (e.g., invalid device token, user unsubscribed). The notification is moved to a "Dead Letter Queue" (DLQ) for analysis.   

Delivered: The provider confirms the message successfully reached the end-user's device.

Read (or Acted): The user interacted with the notification (e.g., clicked the body, tapped an action button).   

Dismissed: The user actively dismissed the notification without taking an action.   

The full lifecycle can be described as a flow: An event or schedule transitions a Pending notification to Queued. A worker dequeues it and attempts delivery. This results in Dispatched (on success), Failed (Transient) (on retryable error, returning to Queued), or Failed (Permanent). From Dispatched, the system awaits external confirmation, which transitions the state to Delivered. Finally, client-side events transition the state to Read or Dismissed.

4.2 State Tracking Mechanisms: The "Webhook vs. SDK" Divide
Tracking states beyond Dispatched is the most significant challenge in notification architecture.

The "Black Box" Problem: Native providers like APNs are "fire-and-forget." They do not provide per-message, real-time delivery receipts. FCM provides aggregated analytics for states like "Received" and "Opens," but these are delayed by up to 24 hours and are not available as real-time webhooks for per-message tracking. Therefore, systems built only on native providers cannot reliably know any state past Dispatched.   

The Orchestrator Solution (SDKs): Platforms like OneSignal solve this "last-mile" problem with their client-side SDKs. This is their core value proposition.

The OneSignal SDK on the device intercepts the incoming notification (via notification.willDisplay on web  or onMessageReceived on Android ).   

The SDK immediately makes a network call back to OneSignal's servers to report that the notificationId was just delivered.

This proprietary network call is how OneSignal populates its "Confirmed Delivery" metric  and can fire a notification.willDisplay server-to-server webhook.   

When the user clicks the notification, the SDK intercepts that event as well and makes a second network call to report "Clicked."

This SDK-based, "closed-loop" system is the only way to get reliable, real-time Delivered and Read statuses for push notifications.

Webhook Callbacks (SMS/Email): For channels they control directly (SMS, Email), providers do offer robust webhooks. Twilio provides a Notify delivery callback URL that receives a DeliveryState JSON for bulk deliveries. Email providers like SendGrid offer webhooks for "delivered," "bounced," and "opened" events.   

Client Acknowledgment API: An alternative pattern places the burden of reporting on the client application. Salesforce, for example, provides an acknowledgements API where a client can POST a status update with an acknowledgementType: "delivery" or acknowledgementType: "read". This is a formal, robust pattern for custom-built systems.   

5.0 Models for User Preference and Subscription Management
Preference management is no longer an optional feature; it is a legal and functional necessity for user retention and compliance.

5.1 The Legal Foundation: Transactional vs. Marketing
The architectural design of a preference system is dictated by the legal distinction between transactional and marketing messages.   

Transactional Notifications:

Trigger: A 1:1 message sent in response to a specific user action or system event (e.g., password reset, order confirmation, security alert).   

Consent: Implied consent is sufficient. Under FTC CAN-SPAM and other regulations, these are considered essential service messages and are legally exempt from explicit opt-in requirements.   

Content: Must not contain any promotional content. Adding a marketing message to a transactional email (e.g., "Your receipt... by the way, check out our 20% off sale!") legally converts the entire message into a marketing email, which may violate consent rules.   

Marketing Notifications:

Trigger: A 1:many message broadcast to a segment of users as part of a campaign (e.g., newsletter, new feature announcement, promotional offer).   

Consent: Explicit, opt-in consent is required.   

Content: Promotional in nature. Must contain a clear and easy-to-use unsubscribe mechanism.   

GDPR Implications: The General Data Protection Regulation (GDPR) imposes further requirements.

Demonstrable: The controller (business) must be able to demonstrate that the user consented. This requires logging consent events (who, what, when).   

Granular: Consent must be granular. A single "I agree to all notifications" checkbox is non-compliant. Users must be given a "real choice" to opt-in to some notification topics (e.g., "social mentions") but not others (e.g., "marketing newsletters").   

Withdrawable: It must be as easy to withdraw consent as it was to give it. This legally mandates a user-friendly, accessible preference center.   

5.2 The Canonical Preference Data Model: A Three-Tiered Synthesis
Based on these legal requirements and best practices , a robust preference model cannot be a single boolean. It must be a multi-tiered JSON object stored on the User record.   

Tier 1: Global Status: A master "kill switch" for all non-essential communication.

user.preferences.global_unsubscribe: true | false

Tier 2: Channel-Level Preferences: A coarse-grained toggle for each channel.

user.preferences.channels: { "email": true, "push": false, "sms": true }

Tier 3: Topic-Level (Granular) Preferences: This is the most complex and most important tier, required by GDPR for granular consent. The architecture must be Topic-based, not Subscription-based. A user's preference for "billing" alerts should apply to all their devices, not be tied to a single device token. The model must also support per-topic, per-channel preferences, as a user may want "billing notifications via both SMS and email," but "system errors via PagerDuty".   

This leads to a canonical model based on a (User, Topic, Channel) tuple:

JSON
/* Example User.preferences JSON Object */
{
  "global_unsubscribe": false,
  
  "channels": {
    /* Tier 2: Coarse-grained channel controls */
    "email": true,
    "push": true,
    "sms": false
  },

  "topics": {
    /* Tier 3: Granular, topic-based controls */
    "billing": {
      "email": true,  /* "I want billing emails" */
      "push": true,
      "sms": false
    },
    "marketing": {
      "email": true,  /* "I want marketing emails" */
      "push": false,
      "sms": false
    },
    "social_mentions": {
      "email": false,
      "push": true,   /* "Only send push for @mentions" */
      "sms": false
    }
  },

  "quiet_hours": {
    "enabled": true,
    "start": "22:00",
    "end": "08:00",
    "timezone": "America/New_York"
  }
}
5.3 Preference-Driven Delivery Logic
The Notification Sender worker (or the initial API endpoint) must perform this logic check before a notification is ever queued for delivery:

Fetch the Notification Intent (with its topic_id) and the User.preferences object.

Check Global: Is preferences.global_unsubscribe == true? -> STOP.

Check Channel (Coarse): Get intended channel (e.g., "push"). Is preferences.channels.push == false? -> STOP.

Check Topic (Granular): Get topic (e.g., "billing"). Is preferences.topics.billing.push == false? -> STOP.

Check Legality: Is Intent.topic_id == "marketing" and preferences.topics.marketing.push == false? -> STOP (prevents sending un-consented marketing).

If all checks pass, the notification proceeds to the Queued state.

6.0 Advanced Patterns and Architectural Considerations
Beyond the core model, several advanced patterns are necessary for building a scalable, user-friendly system.

6.1 Grouping and Batching (Digests)
This pattern addresses "notification fatigue," where high-frequency events (e.g., "User liked your post," "New comment") overwhelm the user.   

Solution 1: Real-time Collapsing (Stacking) This is a client-side grouping achieved by sending a consistent grouping key in the payload. The device OS then "stacks" these notifications.

Native Keys: APNs uses the thread-id key. Android uses a groupKey, abstracted by OneSignal as android_group.   

Orchestration Keys: Abstracted as a batchingKey or groupingKey. For example, a "new comment" notification template can be configured to use {{parameters.post_id}} as its batchingKey. All notifications for the same post are then collapsed into one stack, often showing a summary like "3 new comments."   

Solution 2: Asynchronous Digests (Batching) This is a preference-based system where a user explicitly requests a summary (e.g., "Send me a daily digest of all comments").   

Architecture: When a notification is triggered for a user with this preference, the system does not send it. Instead, the Notification Intent is written to a DigestItems table in the database. A separate scheduler (e.g., a cron job) runs daily, collects all items for that user, renders them into a single email/message, and dispatches that one notification.

6.2 Anti-Patterns and Mitigation Strategies
Anti-Pattern: Notification Storms (Thundering Herd)

Problem: A single event (e.g., breaking news, a high-profile social media post) triggers notifications for millions of users simultaneously. This "thundering herd" can overwhelm the database, message queues, and 3rd-party providers, leading to cascading failures.   

Mitigation:

Asynchronous Queuing: Never send notifications synchronously from the main application thread. All intents must be written to a high-throughput message queue (e.g., Kafka, SQS) for processing by a separate fleet of workers.   

Egress Rate Limiting: Implement robust rate limiting on the sender workers to control the flow of requests to 3rd-party providers (APNs, Twilio). This prevents your system from being blacklisted for abuse. Sliding window log algorithms are effective for this.   

Aggressive Scaling: For ingress (the initial storm of events), systems must be able. Netflix's solution to this problem is to configure aggressive scale-up policies for their clusters.   

Anti-Pattern: Disrespecting "Quiet Hours"

Problem: Sending a non-critical notification at 3:00 AM, waking the user, and leading to an immediate app uninstall.

Mitigation:

User Preference: Quiet hours must be a user-configurable setting, complete with a timezone , as modeled in Section 5.2.   

Deferred State: The Notification Sender worker must check the current time in the user's specified timezone against their quiet hours setting. If the notification falls within this window, it is not sent. Its state is set to Pending (Deferred), and a scheduler re-evaluates it after the quiet hours window closes.

Anti-Pattern: Privacy Leaks via Delivery Receipts

Problem: As highlighted in recent research , delivery receipts (Delivered status) can be weaponized. An attacker can use them to "ping" a user's device, silently tracking their online status, daily schedule, location, and even inferring battery life, all without generating a user-facing notification.   

Mitigation:

Restrict Receipts: Do not provide real-time Delivered status for messages between users who have not mutually consented.

Aggregate Analytics: For non-critical notifications, avoid per-message webhooks. Rely on aggregated, delayed analytics for delivery (similar to FCM's model ) to satisfy business intelligence needs without compromising user privacy.   

7.0 Master Platform Comparison Matrix and Synthesis
The following table provides the comprehensive data synthesis that underpins this report's models and conclusions.

Table 7.1: Master Platform Comparison Matrix
Platform	Primary Channel	API Endpoint	Content: Title	Content: Body	Data Payload	CTA Model	Grouping Key	Orchestration	State Tracking
APNs (Native)	Push	(Direct)	
aps.alert.title 

aps.alert.body 

Root-level keys 

category (String) 

thread-id 

None (Native)	
None (Fire & Forget) 

FCM (Native)	Push	.../messages:send	
notification.title 

notification.body 

data (Object) 

(Client-side) 

collapse_key	None (Native)	
Aggregated Analytics 

Android (Native)	Push	(SDK)	
setContentTitle() 

setContentText() 

setExtras() (Bundle) 

AddAction() (SDK) 

setGroup()	None (Native)	(Client-side)
Slack	In-App (Chat)	chat.postMessage	(via blocks)	
text (fallback) 

metadata 

blocks (Array) 

thread_ts	N/A	API (Read Status)
Discord	In-App (Chat)	.../messages	(via embeds)	
content 

embeds (Object) 

components (Array) 

(Threads)	N/A	API (Read Status)
Amazon SNS	Orchestrator	Publish	(in override)	
default (String) 

(in override)	(in override)	(in override)	
Fan-Out (String) 

Webhook (Aggregated) 

Azure Notif. Hubs	Orchestrator	.../messages	(in override)	
(via template) 

(in override)	(in override)	ServiceBusNotification-Tags	
Fan-Out / Template 

Telemetry API 

Pusher Beams	Orchestrator (Push)	.../publishes/interests	(in override)	(in override)	(in override)	(in override)	(in override)	
Fan-Out (Object) 

Webhook 

Twilio Notify	Orchestrator	.../Notifications	
title 

body 

data (Object) 

action (String) 

(Not specified)	
Unified + Override 

Webhook (Delivery) 

OneSignal	Orchestrator	.../notifications	
headings 

contents 

custom_data 

buttons (Array) 

android_group 

Unified + Override 

SDK (Delivered, Read) 

SendGrid	Email	.../mail/send	
subject 

content (HTML) 

dynamic_template_data 

(HTML links)	N/A	N/A (Email)	
Webhook (Delivered, Bounced) 

Courier	Orchestrator	.../send	(in template)	(in template)	
data (Object) 

(in template)	(in template)	
Unified (Template) 

Webhook / API
  
7.1 Synthesis of Convergence
The master matrix reveals strong convergence in two key areas:

Core Content: Nearly all platforms (~90%) have a concept for a basic title and body.

Developer Payload: 100% of modern, rich notification platforms (all except bare-bones SMS/Email) provide a mechanism for a data payload. This confirms the architectural separation of presentation (title/body) from logic (data).

Orchestration Model: High-level orchestrators are converging on the "Unified + Override" model (OneSignal, Twilio) as it provides the superior developer experience, balancing simplicity with power.

7.2 Synthesis of Divergence
The most significant divergences remain at the "last-mile" implementation:

CTA Implementation: The "Indirect" category model of iOS  vs. the "Direct" AddAction model of Android  is the single largest technical divergence at the native layer.   

State Tracking: The "Black Box" (native APNs/FCM)  vs. the "Closed Loop" (orchestrator SDKs)  is the primary business and architectural divergence. This split forces architects to choose between full-stack native control and the full-lifecycle visibility provided by a third-party orchestrator.   

8.0 Recommendations and Integration Patterns
8.1 Final Recommendations for System Architects
Separate Intent from Payload: The canonical data model must distinguish between the NotificationIntent (the abstract, channel-agnostic request) and the MessagePayload (the final, platform-specific JSON that was dispatched). The Intent should be stored in a primary table for business logic and analytics, while the Payload should be stored (perhaps in a document store or log) for debugging and auditing.

Prioritize the data Payload: All client-side applications (mobile, web) must be architected to always expect and process the data object. All business logic, such as deep-linking, analytics, and local state updates, should be driven by the contents of the data object, not by parsing the user-facing title or body.

Build or Buy the State Machine: The analysis of state tracking (Section 4.2) demonstrates that building a reliable, closed-loop state machine (tracking Delivered and Read) is a massive engineering effort. It requires building, maintaining, and versioning client-side SDKs for every platform to "call home" and report status. For most use cases, buying this capability from an orchestration provider (e.g., OneSignal, Courier) is more cost-effective than building it.

Model Preferences Granularly from Day One: Implementing a three-tiered, granular preference model (Section 5.2) after launch is exponentially more difficult than designing for it from the start. Legal requirements for granular consent  and user expectations for control make this a non-negotiable component of a modern notification system.   

8.2 Integration with the "User" Canonical Object
The notification system is a-service, but it is critically dependent on the User service. A high-speed, low-latency, read-only cache of the User object is a common pattern. The User object must be the source of truth for two key pieces of data:   

Preferences: The User.preferences object (as defined in Section 5.2) must be checked before any notification is rendered or queued.

Contact Endpoints (Subscriptions): The User object must store the array of tokens and addresses for that user. The OneSignal Subscription model  provides a strong pattern for this: a single User (identified by external_id) can have many Subscription objects (e.g., an email address, a phone number, and multiple push tokens for different devices). The notification service queries for all valid subscriptions for a user after preferences have been checked.   

8.3 Concluding Report
The modern notification system has completed its evolution from a simple "fire-and-forget" alerting tool into a complex, stateful, and legally-regulated component of the core application stack. Its architecture is defined by the clear separation of intent from payload, a universal reliance on the data object for business logic, and a deep, unavoidable coupling with user preference and consent models. The convergence toward abstract orchestrators, rich data payloads, and granular preference management defines the blueprint for any robust notification service built today.


courier.com
Transactional vs Product vs Marketing Notifications: Key Differences
Opens in a new window

api.slack.com
send_message Function - Slack API
Opens in a new window

documentation.onesignal.com
OSNotification payload - OneSignal Documentation
Opens in a new window

twilio.com
Notification Resource | Twilio
Opens in a new window

documentation.onesignal.com
View user - OneSignal Documentation
Opens in a new window

firebase.google.com
Send a Message using FCM HTTP v1 API | Firebase Cloud Messaging
Opens in a new window

developer.apple.com
Local and Remote Notification Programming Guide: Payload Key ...
Opens in a new window

documentation.onesignal.com
Sending messages with the OneSignal API - OneSignal
Opens in a new window

docs.slack.dev
Modals | Slack Developer Docs
Opens in a new window

docs.slack.dev
Messaging | Slack Developer Docs
Opens in a new window

discord.com
Webhook Resource | Documentation | Discord Developer Portal
Opens in a new window

discord.com
Messages Resource | Documentation | Discord Developer Portal
Opens in a new window

experienceleague.adobe.com
Understanding Campaign Standard Push Notifications Payload Structure
Opens in a new window

developer.apple.com
Generating a remote notification | Apple Developer Documentation
Opens in a new window

developer.apple.com
Declaring your actionable notification types | Apple Developer Documentation
Opens in a new window

learn.microsoft.com
Notification.Builder Class (Android.App) | Microsoft Learn
Opens in a new window

tool.oschina.net
Notification.Builder - Android SDK
Opens in a new window

stackoverflow.com
Firebase FCM notifications add action button - Stack Overflow
Opens in a new window

medium.com
How to add custom actions in Android Push Notifications | by Syed Faizan Ali | Medium
Opens in a new window

learn.microsoft.com
App notification content - Windows apps | Microsoft Learn
Opens in a new window

docs.aws.amazon.com
Using Google Firebase Cloud Messaging v1 payloads in Amazon SNS
Opens in a new window

drdroid.io
| Pusher Beams Payload Size Exceeded - Doctor Droid
Opens in a new window

sendgrid.com
Email API - Start for Free | SendGrid
Opens in a new window

twilio.com
Notify: Multi-Channel Notifications - Twilio
Opens in a new window

pusher.com
Webhook Reference - Pusher Beams Docs
Opens in a new window

docs.aws.amazon.com
Publishing Amazon SNS notifications with platform-specific payloads
Opens in a new window

pusher.com
Publishing notifications to your users - Pusher Beams Docs
Opens in a new window

learn.microsoft.com
Use REST APIs from a backend - Microsoft Learn
Opens in a new window

courier.com
Send API - Courier
Opens in a new window

courier.com
Webhook Integration - Courier
Opens in a new window

designgurus.io
Designing a Notification System - Design Gurus
Opens in a new window

medium.com
System Design Interview: Design a Notification System | by bugfree.ai | Medium
Opens in a new window

notificationapi.com
Notification Service Design | The Ultimate Guide with Diagrams - NotificationAPI
Opens in a new window

developer.salesforce.com
Send Delivery Acknowledgments or Read Receipts | Interaction Service API Reference - Salesforce Developers
Opens in a new window

documentation.onesignal.com
Web push webhooks - OneSignal Documentation
Opens in a new window

systemdesignhandbook.com
How to Design a Notification System: A Complete Guide
Opens in a new window

bemyaficionado.com
Design A Notification System - BeMyAficionado
Opens in a new window

firebase.google.com
Understanding message delivery | Firebase Cloud Messaging - Google
Opens in a new window

stackoverflow.com
ios - Apple push notifications - delivery receipt - Stack Overflow
Opens in a new window

onesignal.com
Understanding Confirmed Delivery - OneSignal
Opens in a new window

twilio.com
Notify delivery callbacks | Twilio
Opens in a new window

postmarkapp.com
Transactional vs. marketing email explained - Postmark
Opens in a new window

fyno.io
Transactional vs. Marketing Notifications: Understanding the Differences and Use-Cases
Opens in a new window

gdpr-info.eu
Art. 7 GDPR – Conditions for consent - General Data Protection Regulation (GDPR)
Opens in a new window

usercentrics.com
GDPR Consent Requirements: 7 Conditions for Valid Consent - Usercentrics
Opens in a new window

gdpr-info.eu
Consent - General Data Protection Regulation (GDPR)
Opens in a new window

courier.com
A Developer's Guide to Notification APIs - Courier
Opens in a new window

medium.com
How do you batch multiple notifications into 1 without building an aggregate engine? | by Nikita @SuprSend | Medium
Opens in a new window

docs.suprsend.com
Batching & Digest - SuprSend, Notification infrastructure for Product teams
Opens in a new window

notificationapi.com
Batching & Digest - NotificationAPI
Opens in a new window

netflixtechblog.com
Rapid Event Notification System at Netflix | by Netflix Technology Blog
Opens in a new window

hellointerview.com
Design a Distributed Rate Limiter - Hello Interview
Opens in a new window

bytebytego.com
Design A Rate Limiter - ByteByteGo | Technical Interview Prep
Opens in a new window

geeksforgeeks.org
Rate Limiting in System Design - GeeksforGeeks
Opens in a new window

arxiv.org
Careless Whisper: Exploiting Silent Delivery Receipts to Monitor Users on Mobile Instant Messengers - arXiv
Opens in a new window

docs.aws.amazon.com
Amazon SNS message delivery status - Amazon Simple Notification Service
Opens in a new window

learn.microsoft.com
Notification Hubs templates - Azure - Microsoft Learn
Opens in a new window

learn.microsoft.com
REST API methods | Microsoft Learn
Opens in a new window

sendgrid.com
SendGrid Email API and Email Marketing Campaigns | SendGrid
Opens in a new window

twilio.com
Getting started with the SendGrid API - Twilio
Opens in a new window

twilio.com
How to Send an Email with Dynamic Templates | SendGrid Docs | Twilio
Opens in a new window

stackoverflow.com
Design architecture of a notification system - Stack Overflow