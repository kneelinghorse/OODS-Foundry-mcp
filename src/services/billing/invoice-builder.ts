/**
 * Usage-Aware Invoice Builder
 *
 * Enriches canonical invoices with metered usage line items sourced from
 * UsageSummary rollups. Summaries are typically generated by the usage
 * aggregation job (`pnpm usage:aggregate`) and persisted via the shared
 * usage summary repository.
 *
 * @module services/billing/invoice-builder
 */

import { resolve } from 'node:path';
import { DateTime } from 'luxon';
import TimeService from '../time';
import type { CanonicalInvoice, CanonicalSubscription, InvoiceLineItem } from '../../domain/billing/core.js';
import type { UsageLineItem, UsageSummary, MeterUnit } from '../../domain/billing/usage.js';
import {
  FileUsageSummaryRepository,
  type UsageSummaryRepository,
} from './usage-repositories.js';

const DEFAULT_SUMMARY_PATH = resolve('artifacts/usage/summaries.json');

export interface UsageInvoiceBuilderOptions {
  summaryRepository?: UsageSummaryRepository;
  clock?: () => Date;
}

interface CombinedSummary {
  meterName: string;
  unit: MeterUnit;
  periodStart: string;
  periodEnd: string;
  totalQuantity: number;
  eventCount: number;
  minQuantity: number;
  maxQuantity: number;
  avgQuantity: number;
  summaryIds: string[];
}

/**
 * Usage-aware invoice builder.
 */
export class UsageInvoiceBuilder {
  private readonly summaries: UsageSummaryRepository;
  private readonly now: () => DateTime;

  constructor(options: UsageInvoiceBuilderOptions = {}) {
    this.summaries =
      options.summaryRepository ??
      new FileUsageSummaryRepository(DEFAULT_SUMMARY_PATH);
    const clock = options.clock ?? (() => TimeService.nowSystem().toJSDate());
    this.now = () => TimeService.fromDatabase(clock());
  }

  /**
  * Attach usage line items to a canonical invoice for the supplied subscription.
  */
  async attachUsage(
    invoice: CanonicalInvoice,
    subscription: CanonicalSubscription
  ): Promise<CanonicalInvoice> {
    const periodStartSource = subscription.currentPeriod?.start ?? invoice.issuedAt;
    const periodEndSource = subscription.currentPeriod?.end ?? invoice.dueAt;
    const periodStart = TimeService.toIsoString(TimeService.normalizeToUtc(periodStartSource));
    const periodEnd = TimeService.toIsoString(TimeService.normalizeToUtc(periodEndSource));

    const summaries = await this.summaries.getBySubscription(
      subscription.subscriptionId,
      periodStart,
      periodEnd
    );

    if (summaries.length === 0) {
      return {
        ...invoice,
        usageSummaries: [],
        usageLineItems: [],
      };
    }

    const combined = this.combineByMeter(summaries);
    const usageLineItems: UsageLineItem[] = [];
    let usageChargeTotal = 0;

    for (const summary of combined) {
      const isPrimaryMeter = subscription.usage?.meterName === summary.meterName;
      const includedQuantity = isPrimaryMeter
        ? subscription.usage?.includedQuantity ?? 0
        : 0;
      const overageRateMinor = isPrimaryMeter
        ? subscription.usage?.overageRateMinor ?? 0
        : 0;
      const overageQuantity = Math.max(0, summary.totalQuantity - includedQuantity);
      const totalMinor = overageQuantity * overageRateMinor;
      usageChargeTotal += totalMinor;

      usageLineItems.push({
        id: `usage_${summary.meterName}_${summary.periodStart}`,
        description: this.describeLineItem(
          summary.meterName,
          summary.periodStart,
          summary.periodEnd,
          summary.totalQuantity,
          subscription.usage?.unitLabel ?? summary.unit
        ),
        meterName: summary.meterName,
        unit: summary.unit,
        quantity: summary.totalQuantity,
        unitRateMinor: overageRateMinor,
        totalMinor,
        periodStart: summary.periodStart,
        periodEnd: summary.periodEnd,
        summaryId: summary.summaryIds[0],
        createdAt: TimeService.toIsoString(this.now()),
      });
    }

    const existingUsageTotal =
      invoice.usageLineItems?.reduce((sum, item) => sum + item.totalMinor, 0) ?? 0;
    const baseSubtotal = invoice.subtotalMinor - existingUsageTotal;
    const baseTotal = invoice.totalMinor - existingUsageTotal;
    const baseBalance = invoice.balanceMinor - existingUsageTotal;

    const canonicalUsageLines = this.toCanonicalLineItems(usageLineItems, subscription);
    const mergedLineItems = this.mergeLineItems(invoice.lineItems, canonicalUsageLines);

    return {
      ...invoice,
      subtotalMinor: baseSubtotal + usageChargeTotal,
      totalMinor: baseTotal + usageChargeTotal,
      balanceMinor: baseBalance + usageChargeTotal,
      usageSummaries: summaries,
      usageLineItems,
      lineItems: mergedLineItems,
      updatedAt: TimeService.toIsoString(this.now()),
    };
  }

  private combineByMeter(summaries: UsageSummary[]): CombinedSummary[] {
    const grouped = new Map<string, UsageSummary[]>();
    for (const summary of summaries) {
      const bucket = grouped.get(summary.meterName);
      if (bucket) {
        bucket.push(summary);
      } else {
        grouped.set(summary.meterName, [summary]);
      }
    }

    const combined: CombinedSummary[] = [];
    for (const [meterName, bucket] of grouped.entries()) {
      const sorted = [...bucket].sort((a, b) =>
        a.periodStart.localeCompare(b.periodStart)
      );
      const totalQuantity = bucket.reduce((sum, summary) => sum + summary.totalQuantity, 0);
      const eventCount = bucket.reduce((sum, summary) => sum + summary.eventCount, 0);
      const minQuantity = Math.min(...bucket.map((summary) => summary.minQuantity));
      const maxQuantity = Math.max(...bucket.map((summary) => summary.maxQuantity));
      const avgQuantity = eventCount > 0 ? totalQuantity / eventCount : 0;

      combined.push({
        meterName,
        unit: sorted[0].unit,
        periodStart: sorted[0].periodStart,
        periodEnd: sorted[sorted.length - 1].periodEnd,
        totalQuantity,
        eventCount,
        minQuantity,
        maxQuantity,
        avgQuantity,
        summaryIds: sorted.map((summary) => summary.summaryId),
      });
    }

    return combined;
  }

  private describeLineItem(
    meterName: string,
    periodStart: string,
    periodEnd: string,
    totalQuantity: number,
    unitLabel: string | MeterUnit
  ): string {
    const startDate = TimeService.toIsoDateString(TimeService.normalizeToUtc(periodStart));
    const endDate = TimeService.toIsoDateString(TimeService.normalizeToUtc(periodEnd));
    const meterLabel = meterName.replace(/_/g, ' ');
    return `${meterLabel} usage (${startDate} → ${endDate}) — ${totalQuantity.toLocaleString()} ${unitLabel}`;
  }

  private toCanonicalLineItems(
    usageLineItems: UsageLineItem[],
    subscription: CanonicalSubscription
  ): InvoiceLineItem[] {
    return usageLineItems.map((usageItem) => ({
      id: usageItem.id,
      description: usageItem.description,
      quantity: usageItem.quantity,
      amountMinor: usageItem.totalMinor,
      unitAmountMinor: usageItem.unitRateMinor,
      productCode: usageItem.meterName,
      planInterval: subscription.plan.billingInterval,
    }));
  }

  private mergeLineItems(
    existing: InvoiceLineItem[],
    usageLineItems: InvoiceLineItem[]
  ): InvoiceLineItem[] {
    const usageIds = new Set(usageLineItems.map((item) => item.id ?? ''));
    const filteredExisting = existing.filter((item) => !usageIds.has(item.id ?? ''));
    return [...filteredExisting, ...usageLineItems];
  }
}

export const usageInvoiceBuilder = new UsageInvoiceBuilder();
