The Canonical Data Model for Work Management: An Analysis of Task, Ticket, and Workflow Primitives
Part 1: The Canonical Work Item Schema (The "Atom" of Work)
1.1 Abstract: The "Work Item" Entity
The fundamental, indivisible unit of any work management system is the discrete "Work Item." This is the atom of productivity, representing a single, trackable piece of work. While its nomenclature varies by platform—reflecting the system's origin and philosophy—its core function is identical.

This entity is referred to as a:

Task: In project management platforms like Asana , Salesforce , and Basecamp.   

Issue: In developer-centric and complex project management tools like Jira , GitHub , and GitLab.   

Ticket: In IT Service Management (ITSM) and customer support platforms like Zendesk  and ServiceNow.   

Item: In flexible work-builders like Monday.com.   

For the purpose of this analysis, the abstract term Work Item will be used to represent this canonical entity.

1.2 Core Data Fields (Universal Properties)
Analysis of API schemas from over 15 platforms reveals a high degree of convergence on a set of universal, non-nullable properties. These fields form the essential DNA of a Work Item.

id (String/Integer): The system-wide, immutable unique identifier. Asana, for example, refers to this as the gid (globally unique identifier).   

key / display_id (String): The human-readable, project-scoped identifier (e.g., "JRA-1234" or "#134"). This is distinct from the database id and is the primary handle for user-facing communication.   

title / summary / name (String): The primary subject line or name of the Work Item.   

description / body (Rich Text): The detailed content, which has evolved from simple text to complex, structured data.   

status (String/Enum): The Work Item's current position in its lifecycle. (See Part 3).   

priority (String/Enum/Object): The defined urgency or rank. (See Part 4).   

created_at (Timestamp): The immutable timestamp of the item's creation.   

updated_at (Timestamp): The mutable timestamp of the most recent modification.   

1.3 Relational and Contextual Fields
These fields link the Work Item to other core entities, providing essential context.

project_id / workflow_id (Foreign Key): Links the item to its parent container (e.g., a Jira project , Asana projects array , or Trello board ).   

assignee_id(s) (Foreign Key Array): The user(s) or team(s) responsible for executing the work. (See Part 5).   

creator_id (Foreign Key): The user who created the item. This is often named author_id  or created_by.   

reporter_id / requester_id (Foreign Key): The user (often a customer) on whose behalf the item was created. This is a critical field in ITSM platforms like Zendesk  and Jira.   

1.4 Semantic Divergence: 'Name' vs. 'Summary'
A semantic split in the title field reveals the core philosophy of a platform.

Project Management Tools (Asana, Linear): Use the field name. This implies the Work Item is an "object" or a "thing" to be managed in a hierarchy, like a node in an outline.   

ITSM/Dev Tools (Jira, GitHub): Use summary  or title. This implies the Work Item is a "communication" or a "report"—a subject line for a problem to be solved.   

This distinction highlights the platform's origin: object-oriented project management versus communication-oriented issue tracking. A canonical model must reconcile this, typically by standardizing on title.

1.5 Semantic Divergence: The 'Description' Format
The description field is a primary source of integration complexity. It is no longer a simple TEXT blob but a structured, rich-text format.

Jira: Uses the Atlassian Document Format (ADF), a complex, proprietary JSON schema that defines nodes for paragraphs, code blocks, and mentions.   

GitHub: Uses body formatted in Markdown.   

Asana: Provides both notes (plain text) and html_notes (rich text).   

This evolution from a "field" to a "document" is a critical architectural shift. A canonical model cannot treat this as description: string. It must be modeled as a structured object: description: { format: (text | markdown | html | adf), content: string }.

1.6 Semantic Divergence: 'Creator' vs. 'Reporter'
A critical distinction separates project management tools from service desks.

In PM tools, the creator and the reporter are typically the same internal collaborator.   

In ITSM/CRM platforms (Jira, Zendesk), these are two distinct and vital fields. The creator may be an agent, or an automation, that is logging a ticket. The reporter (or requester in Zendesk) is the customer or stakeholder on whose behalf the work is being done.   

The creator_id should be immutable, whereas the reporter_id is often mutable, allowing an agent to correct who the ticket is for. The canonical model must possess both fields to support all use cases.

1.7 Deliverable: Core Work Item Field Convergence
The following table demonstrates the convergence of core concepts across a representative sample of platforms, mapping their specific API field names to the canonical model.

Table 1: Core Work Item Field Convergence Matrix

Canonical Field	Jira (Issue)	Asana (Task)	GitHub (Issue)	GitLab (Issue)	Zendesk (Ticket)	Salesforce (Task)
id	id	gid	id	id	id	Id
key	key	(n/a)	number	iid	(n/a)	(n/a)
title	fields.summary	name	title	title	subject	Subject
description	fields.description (ADF)	notes / html_notes	body (Markdown)	description (Markdown)	description (first comment)	Description
status	fields.status	completed (boolean)	state (open/closed)	state (opened/closed)	status	Status
priority	fields.priority	custom_fields	labels	priority / labels	priority	Priority (combobox)
creator_id	fields.creator	created_by	user	author	submitter_id	CreatedById
reporter_id	fields.reporter	(n/a)	(n/a)	(n/a)	requester_id	WhoId (Lead/Contact)
assignee_id(s)	fields.assignee	assignee	assignees (array)	assignees (array)	assignee_id	OwnerId
project_id	fields.project	projects (array)	repository (implicit)	project_id	(n/a)	WhatId (Related Object)
created_at	fields.created	created_at	created_at	created_at	created_at	CreatedDate
updated_at	fields.updated	modified_at	updated_at	updated_at	updated_at	LastModifiedDate
due_date	fields.duedate	due_on / due_at	milestone (object)	due_date	due_at	ActivityDate
Part 2: The Canonical Workflow Schema (The "Container" of Work)
2.1 Abstract: The "Workflow" Entity
Work Items do not exist in a vacuum. They are contained within, and governed by, a parent entity. This "container" provides the context, configuration, and ruleset for the Work Items it holds.

This container is variously named:

Project (Jira , GitLab )   

Board (Trello )   

Team (Linear )   

Workspace / Project (Asana )   

Table / Database (ServiceNow , incident table)   

2.2 The Container as the Schema Definer
The single most important architectural principle of modern work systems is that the container defines the schema. A Work Item's specific fields, valid statuses, and available transitions are not intrinsic to the item itself; they are inherited from its container.

This "schema-on-demand" model is a universal solution to a common problem: how to support millions of unique customer processes within a single multi-tenant platform. Storing all possible customizations on the Work Item object itself is computationally infeasible. Instead, customization (custom fields, status lists, automation rules) is attached to the parent container.

Evidence for this model is found in the "meta" APIs that all advanced platforms provide:

Jira: The createmeta API flow is the canonical example. To know which fields are valid for a new issue, an integration must first query for the project, then the available issue types for that project, and finally the fields for that specific project/issuetype combination.   

ServiceNow: The /api/now/ui/meta/{tablename} API returns the specific fields, types, and even valid choice options for a given table, such as incident.   

Linear: The Team entity defines the workflow, which includes the list of valid states (statuses) and templates.   

This architecture dictates a dynamic, two-step integration pattern, replacing the naive, static POST /task model.

Step 1 (Discover): GET /workflow/{id}/schema (to discover available fields, types, and rules).

Step 2 (Create): POST /workflow/{id}/items (to create an item that is valid against that specific schema).

2.3 Models of Work Organization
Workflows are organized in two primary ways:

Container-based (Kanban): Work items exist in a single logical container and are visualized by their status in columns. This is the classic Trello model.   

Time-boxed (Sprint/Milestone): Work items are additionally grouped into time-bound iterations. This is fundamental to Scrum (Jira Sprints) and related methodologies (Linear Cycles , GitLab Milestones ).   

2.4 Canonical Workflow Schema
The canonical Workflow entity, therefore, is the locus of configuration.

JSON
{
  "id": "workflow-123",
  "name": "Mobile Team Project",
  "key": "MOB",
  "type": "SCRUM", // ENUM: KANBAN, SCRUM, PROCESS
  "owner_id": "user-456",
  "status_workflow_id": "statemachine-001", // FK to StatusWorkflow
  "custom_field_schema_id": "schema-def-007" // FK to CustomFieldSchema
}
Part 3: Lifecycle and State Machine Modeling (Status)
The status field is the engine of the workflow, defining a Work Item's progression through its lifecycle.

3.1 The Two-Tiered State Model: 'Status' vs. 'State Category'
A key architectural pattern is the separation of the human-facing Status from the system-facing State Category.

Status: The flexible, custom, user-defined label (e.g., "Awaiting Customer," "In Triage," "Ready for QA").

State Category: The fixed, canonical, system-level state (e.g., TODO, IN_PROGRESS, DONE).

This model is necessary to balance user flexibility with system-level reporting. A team needs to create custom workflow statuses, but the system needs to know which of them mean "done" to calculate cycle time metrics.

Zendesk: Defines a fixed list of six standard status values: New, Open, Pending, On-hold, Solved, and Closed.   

ServiceNow: Explicitly maps multiple user-facing statuses (e.g., "Awaiting User Info," "Awaiting Evidence") to a single, canonical On Hold state.   

Salesforce: The TaskStatus object includes a simple IsClosed boolean flag, which is a binary state category system (Open vs. Closed).   

A canonical model must represent status as an object: status: { name: "Awaiting Review", category: "IN_PROGRESS" }. The canonical categories are: TODO (or New), IN_PROGRESS (or Open), DONE (or Closed), and ON_HOLD (or Pending).

3.2 The Two Models of State Transition
The most significant architectural divergence in workflow design is how an item's status is changed.

3.2.1 Model A: Direct State Mutation (Set-based)
This model allows an API client to directly set the value of the status field.

Description: UPDATE task SET status = "Done".

Platforms: Trello (moving a card) , Asana, ClickUp.   

Pros/Cons: Simple, fast, and highly flexible. It lacks process control, auditability, and the ability to enforce business rules.

3.2.2 Model B: Explicit Transition (Event-based)
This model, fundamental to ITSM and Business Process Management (BPM), prohibits direct mutation of the status field. Instead, an API client must trigger a named transition.

Description: POST /issue/{key}/transitions with a payload of {"transition": {"id": "21"}}. The system receives this event (e.g., "Resolve Issue") and is responsible for changing the status from "In Progress" to "Resolved."

Platforms: Jira  and ServiceNow.   

Rationale: This model is essential for enterprise process control. An organization cannot allow a developer to simply set a task to "Done." They must enforce a process—for example, that only a "QA Lead" can execute the "Pass Test" transition. This event-based model allows the "transition" itself to become an object that can be permissioned, audited, and augmented with pre-conditions (validators) and post-functions (automation).

This difference is the primary source of process friction between flexible PM tools (Model A) and process-driven ITSM/BPM tools (Model B).

3.3 Canonical StatusWorkflow Schema
This entity defines the state machine for a Workflow.

JSON
{
  "id": "statemachine-001",
  "name": "Agile Software Workflow",
  "statuses":,
  "transitions":
}
Part 4: Prioritization and Severity Taxonomies
This section analyzes the systems used to rank and stack Work Items.

4.1 Model 1: Fixed Enumeration (Classic ITSM)
This is the most common model, providing a simple, fixed list of priority names.

Platforms: Zendesk defines priority as a string enum: "urgent", "high", "normal", or "low". Jira's default configuration is similar (High, Medium, Low), though these are configurable objects, each with a unique id.   

4.2 Model 2: Calculated Priority (Advanced ITSM)
This model, central to formal ITSM, treats Priority as a calculated, read-only field derived from Impact and Urgency.

Platforms: ServiceNow is the classic example.   

Logic:

Impact: Measures the blast radius or business-wide effect of the issue (e.g., "How many users are affected?").

Urgency: Measures the time-sensitivity or speed of damage (e.g., "Is the system down now?").

Priority: The resulting value from a 2x2 "Priority Lookup Matrix" (e.g., High Impact + High Urgency = P1 "Critical").

This system forces a business-risk discussion, moving beyond an agent's subjective assessment. This calculated priority is then used to drive Service Level Agreements (SLAs).   

4.3 Model 3: Priority-as-Custom-Field (Flexible PM)
In this model, priority is not a first-class citizen but is implemented as a standard Custom Field.

Platforms: Asana.   

Pros/Cons: This is highly flexible, allowing users to define their own ranking systems (e.g., P0-P4, "High," "Hot"). The significant drawback is a lack of standardization, which complicates cross-project reporting.

4.4 Model 4: Priority-as-Label (Developer-centric)
This model delegates priority to the Labels system, a key-value tag.

Platforms: GitHub  and GitLab.   

Anti-Pattern: This is the most flexible model but also the most prone to data integrity failures. A user can accidentally apply three priority labels (e.g., prio:low, prio:high) or no priority label at all. This makes deterministic sorting and reporting unreliable.   

4.5 Canonical Model
A robust canonical model must support the formal ITSM pattern while remaining simple for PM use cases. It should contain impact: enum, urgency: enum, and priority: enum. The priority field can either be set directly (for PM) or be a calculated, read-only field (for ITSM).

Part 5: Assignment and Routing Patterns
This section analyzes how a Work Item is routed to the responsible party.

5.1 Model 1: Single Assignee (The "DRI" Model)
The Work Item has a single assignee field, enforcing the concept of a "Directly Responsible Individual" (DRI) for accountability.

Platforms: Asana , Jira.   

5.2 Model 2: Multiple Assignees (The "Collaborative" Model)
The Work Item has an assignees field, which is an array of User IDs. This reflects the reality of collaborative work (e.g., pair programming, joint reviews) but can dilute accountability.

Platforms: GitHub , GitLab , ClickUp.   

5.3 Model 3: Queue/Group Assignment (The "Service Desk" Model)
This is the fundamental pattern for service desk load balancing. Work is assigned to a Queue or Group, not an individual. An agent can then take the item from the queue.

Platforms: Zendesk (group_id) , ServiceNow (assignment_group) , ClickUp (group_assignees).   

Architecture: In this model, a ticket has two distinct assignment fields: assignment_group_id (the queue) and assignee_id (the agent). Routing between teams is accomplished by changing the assignment_group_id.

5.4 Model 4: AI/Agent Assignment (The "Automation" Model)
A nascent but architecturally critical pattern is the assignment of work to a non-human Agent.

Platforms: Linear has a first-class Agent concept. An issue can be assigned to an AI agent, which acts on the issue (e.g., writes code) and then delegates it back to a human.   

This implies the assignee field is becoming polymorphic. It must reference an abstract Actor entity, where an Actor can have a type of USER, TEAM, or AGENT (bot).

4.5 Canonical Model
The canonical model must synthesize these patterns. It requires an assignment_group_id (for queue-based routing) and an assignee_ids array (for individual assignment). This assignee_ids array should be polymorphic, capable of referencing User, Team, and Agent entities.

Part 6: Dependency and Relationship Modeling (Hierarchy & Graphs)
This section deconstructs how relationships between Work Items are modeled. These relationships fall into two distinct categories: hierarchical and graph.

6.1 Model 1: Hierarchical (Parent/Child)
This model is used for work breakdown, decomposing a large task into smaller, manageable pieces. It is a one-to-many relationship.

Jira: Implemented via a parent field and a special issuetype of Sub-task.   

Asana: A subtask is architecturally identical to a task, distinguished only by the presence of a parent field.   

ClickUp: Explicit subtask model.   

Monday.com: Uses subitems.   

ServiceNow: Supports parent_incident relationships.   

Linear: Uses a parent / sub-issue model.   

A canonical WorkItem schema must therefore include a nullable parent_id field and a children collection.

6.2 Model 2: Graph (Peer-to-Peer)
This model is used for sequencing and dependency, linking peer items to show temporal or logical relationships. This is a many-to-many relationship.

GitLab: Provides the most explicit and robust model via its Issue links API. An API client can POST a link with a specific link_type enum: "relates_to", "blocks", or "is_blocked_by".   

GitHub: Supports issue_dependencies with a "blocked by" relationship.   

Linear: Explicitly supports blocked, blocking, related, and duplicate relations.   

These two models solve different problems. Hierarchy (Parent/Child) is for scope management ("This task is made of these 5 pieces"). The Graph (Peer-to-Peer) is for temporal dependency ("This task cannot start until that task is finished"). Platforms are rapidly converging to support both simultaneously.

6.3 Canonical WorkItemLink Schema
A canonical model requires both the parent_id field (for hierarchy) and a separate join table/array for the graph.

JSON
{
  "id": "link-456",
  "source_item_id": "item-123",
  "target_item_id": "item-789",
  "link_type": "BLOCKS" // ENUM: RELATES_TO, BLOCKS, IS_BLOCKED_BY, DUPLICATES
}
Part 7: Time Tracking and Estimation Patterns
This section analyzes how effort and time are modeled.

7.1 Model 1: Stateful Estimates (The "Jira" Model)
This model, originating from traditional project management, stores time estimates as state on the Work Item itself.

Platforms: Jira is the classic example. The timetracking object contains three distinct fields: originalEstimate, remainingEstimate, and timeSpent.   

Rationale: This model is simple for "burndown" calculations, where a fixed bucket of originalEstimate is depleted. Its major weakness is auditability; it only stores the current state of time, not the history of how that time was spent, by whom, or when.

7.2 Model 2: Log-Based Time (The "Harvest" Model)
This model, correct from a database normalization perspective, does not store "time spent" on the Work Item. Instead, the Work Item has a collection of TimeEntry objects.

Platforms: Asana has time_tracking_entries. GitLab uses /spend quick actions to create discrete time logs.   

Architecture: The "Total Time Spent" is not a stored field but a calculation (a SUM) of its related TimeEntry objects. This model provides a full, auditable, and billable history of all work.

The stateful model (Jira) is simple but lossy. The log-based model (Asana, GitLab) is the superior and canonical approach, as its data can be "rolled up" to provide the same three numbers as the Jira model, while also retaining the granular audit log.

7.3 Canonical TimeEntry Schema
JSON
{
  "id": "time-entry-777",
  "work_item_id": "item-123",
  "user_id": "user-456",
  "duration_minutes": 120,
  "logged_on_date": "2025-11-05",
  "description": "Implemented API endpoint."
}
The WorkItem object would then have a single estimated_minutes field and a calculated total_time_spent_minutes field.

Part 8: Extensibility (Custom Fields) and Schema-on-Demand
The horizontal dominance of these platforms is achieved through extensibility. Users must be able to add their own fields to the canonical model.

8.1 The Canonical Custom Field Types
Platforms have converged on a standard set of supported custom field types.

Zendesk: Provides a clear taxonomy: Drop-down, Multi-select, Text, Multi-line, Checkbox, Numeric, Decimal, Date, and Regex.   

Jira: Offers similar types, including text, rich_text, single_select, multi_select, and user_picker.   

Asana: Includes text, number, enum, multi_enum, and people.   

8.2 Schema Discovery: The "Meta" APIs
As established in Part 2, these custom fields are defined on the container, not the item. Integrations must discover this schema at runtime.

Jira: The new 3-step flow (GET /project -> GET /.../issuetypes -> GET /.../fields) replaces the older, monolithic createmeta endpoint, which suffered from severe performance degradation on instances with large custom field schemas.   

ServiceNow: The /api/now/ui/meta/{tablename} API is a clean, modern implementation of this, returning a list of all fields, their types, and choice options for a given table.   

8.3 Implementation: "Field Bag" vs. "Nested Array"
The representation of custom field values on a Work Item follows two patterns:

Model A: "Field Bag" (Jira): Custom fields are injected into the main fields object with opaque, system-generated names (e.g., "customfield_10010": "..."). This is easy to write but difficult to parse without the corresponding createmeta schema.   

Model B: "Nested Array" (Asana): Custom fields are placed in a dedicated custom_fields array. Each object in the array is self-describing, containing its gid, name, type, and value.   

Model B is the superior design for a canonical API, as it is self-describing and does not require a separate schema lookup to be interpretable.

Part 9: Automation, Escalation, and Approval Workflows
This section analyzes the "active" logic that drives the workflow.

9.1 Automation: The Trigger-Condition-Action Model
All modern automation engines (Asana Rules , Jira Automation ) share a universal canonical model:   

Trigger: An event that initiates the rule (e.g., "Issue Created" , "Due date is set" , or an "Incoming webhook" ).   

Condition: A logical filter (e.g., "Priority is High" AND "Issue Type is Bug").

Action: The operation to perform (e.g., "Assign task to..." , "Send web request" , "Transition issue" ).   

9.2 SLA and Escalation
An SLA (Service Level Agreement) is not a unique object type; it is a specialized and time-sensitive implementation of the Trigger-Condition-Action model.

Zendesk: SLA policies are explicitly defined by a filter (the Condition) and apply policy_metrics (the Action).   

Deconstruction: An SLA policy like "Respond to Urgent tickets in 1 hour" can be deconstructed:

Trigger: "Ticket Created."

Condition: priority == "urgent".

Action: "Start 'Time to First Response' timer."

A separate, system-level automation then runs:

Trigger: "On Timer Tick (every minute)."

Condition: "Timer 'Time to First Response' > 1 hour" AND status_category!= ON_HOLD.

Action: "Trigger 'SLA Breach' event" (which may escalate priority or notify a manager).

9.3 Approval Workflows
An approval is a validator that gates a state machine transition. This pattern connects directly back to the "Explicit Transition" model (Part 3.2).

Jira Service Management: Explicitly adds an "Approval" step to a workflow. This step prevents a transition (e.g., from "Awaiting Approval" to "Approved") until the defined approvers have acted.   

The "Approve" and "Reject" buttons are simply UI-friendly triggers for the underlying, permissioned workflow transitions.   

This demonstrates why robust approval workflows are impossible to build in systems that only support "Direct State Mutation" (Model A). Process-driven approvals require the "Explicit Transition" (Model B) architecture.

Part 10: Anti-Patterns, Edge Cases, and Recommendations
10.1 Anti-Pattern: Priority-as-Label
Using flexible systems like labels or tags to manage core, single-value fields like priority is a common anti-pattern.

Problem: As seen in GitHub  and GitLab , this allows a Work Item to have multiple, conflicting priorities (e.g., prio:low and prio:high) or no priority at all.   

Recommendation: A canonical model must enforce that core state fields (Status, Priority, Assignee) are first-class, discrete properties. Labels should be reserved for cross-cutting, multi-value categorization (e.g., "frontend," "bug," "ios-app").

10.2 Anti-Pattern: Circular Dependencies
The peer-to-peer Graph model (Part 6.2) allows for the creation of deadlocks.

Problem: A user can define "Task A blocks Task B" and "Task B blocks Task A." Platforms like GitLab  and GitHub  allow this.   

Recommendation: A canonical API must include validation logic to traverse the dependency graph on creation/update and reject any link that would create a circular dependency.

10.3 Anti-Pattern: Custom Field Sprawl
The "schema-on-demand" model is powerful but prone to "schema-on-chaos."

Problem: The proliferation of duplicative or one-off custom fields leads to user confusion and severe performance degradation, as seen with Jira's createmeta endpoint.   

Recommendation: For structured, related data (e.g., an "Asset" with a serial number, location, and owner), a "Custom Object" (Zendesk , Salesforce) is a far superior pattern to creating 20 flat "Asset-Location," "Asset-Serial" custom fields.   

10.4 Edge Case: Orphaned Subtasks and Schema Mismatch
Hierarchical models (Part 6.1) create complex edge cases.

Problem: If a parent task (Asana ) is deleted, what happens to its children? If a subtask is moved to a new project with a different workflow, is its status still valid?   

Recommendation: The canonical model must define these rules. The safest pattern is to (a) promote orphaned children to top-level Work Items upon parent deletion and (b) trigger a mandatory re-validation and status-mapping upon any change to the project_id container.

10.5 Mission Completion Report and Recommendations
This analysis has successfully documented the canonical data model for work management systems by deconstructing them into their core primitives and identifying the key architectural patterns that differentiate them.

Key Recommendations:

Adopt the Canonical Model as a "Rosetta Stone": The canonical schemas defined in this report (for WorkItem, Workflow, StatusWorkflow, WorkItemLink, TimeEntry) serve as the ideal conceptual blueprint for any integration, migration, or unified API. It acts as a "Rosetta Stone" for mapping concepts between disparate systems (e.g., a Jira priority object maps to a Zendesk priority string, which maps to an Asana custom_field).

Architect for the PM/ITSM Divide: The most significant finding is the deep, philosophical split between flexible Project Management tools (Model A: Direct Mutation) and process-driven BPM/ITSM tools (Model B: Explicit Transition). A unified system must support both models. It should expose a simple UPDATE endpoint (for Model A) that, behind the scenes, is a wrapper for a more formal TRANSITION (Model B) engine.

Embrace "Container-as-Schema": Any integration effort that hardcodes fields (e.g., "customfield_10010") is guaranteed to fail. The only viable, long-term integration pattern is dynamic and two-step: 1. Discover (by calling the createmeta  or ui/meta  APIs) and 2. Create (by posting a payload that conforms to the discovered schema).   

Prioritize Log-Based Time: When building new systems, the "Stateful" time model (Jira ) should be avoided. The "Log-Based" model (Asana , GitLab ) is architecturally superior, providing a full audit trail for billing and analytics while still allowing for a "rolled-up" state view.   

Future-Proof the Assignee: The concept of the "assignee" is already in flux. The canonical model should define the assignee as a polymorphic Actor (User, Team, or Agent), as pioneered by Linear , to accommodate the inevitable rise of AI and bot-based automation.   


developers.asana.com
Overview - Asana Docs
Opens in a new window

developer.salesforce.com
Task | Object Reference for the Salesforce Platform
Opens in a new window

developer.salesforce.com
Task | Salesforce Field Reference Guide | Salesforce Developers
Opens in a new window

basecamp.com
Basecamp Integrations
Opens in a new window

developer.atlassian.com
Jira Cloud platform REST API documentation - Developer, Atlassian
Opens in a new window

docs.github.com
REST API endpoints for issues - GitHub Docs
Opens in a new window

docs.github.com
REST API endpoints for pull requests - GitHub Docs
Opens in a new window

docs.github.com
REST API endpoints for issues - GitHub Docs
Opens in a new window

docs.gitlab.com
Issues API - GitLab Docs
Opens in a new window

docs.gitlab.com
Issues | GitLab Docs
Opens in a new window

developer.zendesk.com
API Reference Home | Zendesk Developer Docs
Opens in a new window

developer.zendesk.com
Tickets - Zendesk Developer Docs
Opens in a new window

servicenow.com
Update the incident - ServiceNow
Opens in a new window

developer.monday.com
Items - Apps Framework - Monday.com
Opens in a new window

docs.atlassian.com
JIRA Server platform REST API reference - Atlassian
Opens in a new window

docs.atlassian.com
JIRA REST API documentation - Atlassian
Opens in a new window

support.atlassian.com
Advanced field editing using JSON | Cloud automation Cloud - Atlassian Support
Opens in a new window

community.developer.atlassian.com
Jira REST API description field - The Atlassian Developer Community
Opens in a new window

support.zendesk.com
About ticket fields - Zendesk help
Opens in a new window

servicenow.com
Define priority lookup rules - ServiceNow
Opens in a new window

postman.com
Trello REST API | Documentation | Postman API Network
Opens in a new window

developer.zendesk.com
Requests | Zendesk Developer Docs
Opens in a new window

community.atlassian.com
How to set the reporter in create issue by API (POST REST API) - Atlassian Community
Opens in a new window

community.developer.atlassian.com
Post HTML Issue Description with JIRA REST API v3 - The Atlassian Developer Community
Opens in a new window

community.atlassian.com
How do I know the data types and expected JSON format for all issue fields
Opens in a new window

servicenow.com
Solved: Incident REST detailed documentation - ServiceNow Community
Opens in a new window

docs.gitlab.com
REST API resources - GitLab Docs
Opens in a new window

trello.org
Using the Trello API
Opens in a new window

linear.app
Teams – Linear Docs
Opens in a new window

docs.trunk.io
Linear integration | docs - Trunk Platform
Opens in a new window

developers.asana.com
Quick start guide - Asana Docs
Opens in a new window

davidmac.pro
ServiceNow 'schema' and 'meta' APIs, and why system integrations ...
Opens in a new window

confluence.atlassian.com
Createmeta REST endpoint to be removed | Atlassian Support ...
Opens in a new window

community.developer.atlassian.com
Create Issue Meta Endpoint Deprecation - Jira Cloud - The Atlassian Developer Community
Opens in a new window

linear.app
API and Webhooks – Linear Docs
Opens in a new window

docs.gitlab.com
Issues statistics API - GitLab Docs
Opens in a new window

support.servicenow.com
Incident Management State Model - Support and Troubleshooting
Opens in a new window

developer.salesforce.com
TaskStatus | Object Reference for the Salesforce Platform
Opens in a new window

community.atlassian.com
how to change jira status by transition with REST ...
Opens in a new window

stackoverflow.com
Listing All JIRA Transitions via API - Stack Overflow
Opens in a new window

community.atlassian.com
REST API that returns all workflow's transitions - Atlassian Community
Opens in a new window

servicenow.com
Update State Field in Catalog Task with REST API - ServiceNow Community
Opens in a new window

servicenow.com
Trying to change State via API - ServiceNow Community
Opens in a new window

developer.atlassian.com
Get all issue priorities - The Jira Data Center REST API
Opens in a new window

community.developer.atlassian.com
Change Priority of issue via API - Jira Cloud - The Atlassian Developer Community
Opens in a new window

community.atlassian.com
Can't set priority when creating an issue REST API - Atlassian Community
Opens in a new window

servicenow.com
Setting Impact and Urgency via REST api using Priority lookup rules - ServiceNow
Opens in a new window

developer.zendesk.com
SLA Policies - Zendesk Developer Docs
Opens in a new window

help.asana.com
Schedule tasks based on priority - Asana Help Center
Opens in a new window

developers.asana.com
Custom fields - Asana Docs
Opens in a new window

forum.asana.com
How to get priority field on tasks? - Developers & API - Asana Forum
Opens in a new window

docs.github.com
REST API endpoints for labels - GitHub Docs
Opens in a new window

docs.github.com
Managing labels - GitHub Docs
Opens in a new window

webapps.stackexchange.com
Sort GitHub issues by priority (or by labels) - Web Applications Stack Exchange
Opens in a new window

forum.openrefine.org
Cleaning up our GitHub issue labels - Development & Design - OpenRefine
Opens in a new window

docs.gitlab.com
Sorting and ordering issue lists - GitLab Docs
Opens in a new window

gitlab.com
Cannot set (group) label priority for project in subgroup via API (#368070) · Issue - GitLab
Opens in a new window

developers.asana.com
Tasks - Asana Docs
Opens in a new window

community.atlassian.com
Setting Assignee via REST API always assigns issue to caller - Atlassian Community
Opens in a new window

github.blog
Multiple assignees for issues and pull requests now available in all repositories
Opens in a new window

docs.gitlab.com
Multiple assignees for issues - GitLab Docs
Opens in a new window

reddit.com
python-gitlab and issue assignees - Reddit
Opens in a new window

developer.clickup.com
Get Tasks - ClickUp API
Opens in a new window

developer.clickup.com
Tasks - ClickUp API
Opens in a new window

help.clickup.com
Multiple Assignees - ClickUp Help
Opens in a new window

developer.zendesk.com
Groups - Zendesk Developer Docs
Opens in a new window

servicenow.com
Service Now GET incident list by Assignment Group using Python and REST API
Opens in a new window

servicenow.com
Post API to create an incident with the assignment... - ServiceNow Community
Opens in a new window

servicenow.com
Mapping assignment groups via the REST API - ServiceNow Community
Opens in a new window

servicenow.com
How to create an incident with the assignment_group field set using the REST Table API? - ServiceNow
Opens in a new window

developer.clickup.com
Create Task - ClickUp API
Opens in a new window

linear.app
AI Agents – Linear Docs
Opens in a new window

youtube.com
Why Linear Built an API For Agents - YouTube
Opens in a new window

confluence.atlassian.com
How to create issues using direct HTML links in Jira - Atlassian Documentation
Opens in a new window

community.atlassian.com
How do I create a subtask and link it to an issue I have auto created in a script listener, for Jira - Atlassian Community
Opens in a new window

developers.asana.com
Get subtasks from a task - Asana Docs
Opens in a new window

forum.asana.com
Can you extract descriptions from a subtask? - Developers & API - Asana Forum
Opens in a new window

developer.monday.com
Subitems - Apps Framework
Opens in a new window

servicenow.com
Parent and child security incident relationships - ServiceNow
Opens in a new window

servicenow.com
Fetch Child Incident Details using API - ServiceNow Community
Opens in a new window

linear.app
Parent and Sub-Issues – Linear Docs
Opens in a new window

docs.gitlab.com
Issue links API | GitLab Docs
Opens in a new window

docs.gitlab.com
Linked issues - GitLab Docs
Opens in a new window

docs.github.com
REST API endpoints for issue dependencies - GitHub Docs
Opens in a new window

linear.app
Issue relations – Linear Docs
Opens in a new window

docs.atlassian.com
TimeTracking (Atlassian JIRA 7.6.1 API)
Opens in a new window

community.atlassian.com
JIRA Rest API Create Issue with Time Tracking - Atlassian Community
Opens in a new window

developers.asana.com
Time tracking entries - Asana Docs
Opens in a new window

developers.asana.com
Get time tracking entries for a task - Asana Docs
Opens in a new window

forum.asana.com
Native Time Tracking read data - Developers & API - Asana Forum
Opens in a new window

docs.gitlab.com
Time tracking | GitLab Docs
Opens in a new window

gitlab.com
doc/user/project/time_tracking.md · aad6708396054719a3c5ae40c2c0593d01db3753 - GitLab
Opens in a new window

gitlab.com
Time tracking API: list of individual time spent entries per issue/MR (#16724) - GitLab
Opens in a new window

stackoverflow.com
How can I use the GitLab API to get detailed time tracking for a specific issue or task?
Opens in a new window

developer.zendesk.com
Ticket Fields - Zendesk Developer Docs
Opens in a new window

developer.zendesk.com
Custom Fields - Zendesk Developer Docs
Opens in a new window

developer.atlassian.com
Issue Field module for Connect - Atlassian Developer
Opens in a new window

stackoverflow.com
JIRA API create issue with custom fields - Stack Overflow
Opens in a new window

community.atlassian.com
Using JIRA Rest API and JIRA Asset Management Objects - Atlassian Community
Opens in a new window

developers.asana.com
Rules - Asana Docs
Opens in a new window

help.asana.com
Rule Triggers in Asana
Opens in a new window

support.atlassian.com
Jira automation triggers - Atlassian Support
Opens in a new window

support.atlassian.com
Configure the incoming webhook trigger in Atlassian Automation
Opens in a new window

salto.io
Master Jira Webhooks: A Comprehensive Integration Guide - Salto.io
Opens in a new window

support.atlassian.com
How to extend Automation for Jira with REST API calls - Atlassian Support
Opens in a new window

confluence.atlassian.com
5. Add approvals to your workflow | Jira Service Management Data Center 11.1
Opens in a new window

docs.atlassian.com
JIRA Service Desk REST API Reference - Atlassian
Opens in a new window

developer.atlassian.com
Approval - The Jira Service Management REST API
Opens in a new window

youtube.com
How to Create Approval Flow/Path in Jira Software - YouTube
Opens in a new window

support.zendesk.com
Understanding custom objects - Zendesk help
Opens in a new window

support.zendesk.com
Creating custom objects to integrate with custom data - Zendesk help