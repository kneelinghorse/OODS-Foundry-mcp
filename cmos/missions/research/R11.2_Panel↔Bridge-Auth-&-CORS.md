Specification for Panel-Bridge Authentication and Cross-Origin Resource Sharing (CORS)
1.0 Executive Summary
1.1 Mission Objective
This document provides the definitive specification for the Cross-Origin Resource Sharing (CORS) and authentication model governing communication between the Storybook Panel (the client, originating from http://localhost:6006) and the local HTTP Bridge (the server). The primary objective is to define a minimal, robust, and secure communication protocol that prevents common web security vulnerabilities, even within the context of local development.

1.2 Prescribed Solution
The specified solution establishes a "secure-by-default" posture. The Bridge will enforce a strict, allowlist-based CORS policy, permitting requests only from the designated Storybook origin. By default, the Bridge operates in a read-only mode, serving tool information via a GET request without authentication. Write operations, specifically to the POST /run endpoint, are protected by an optional, non-standard, token-based authentication mechanism driven by an environment variable. This design ensures simplicity, robustness, and security, establishing a clear and defensible perimeter for the local development tool.

1.3 Key Security Principles
The design adheres to the principle of least privilege, explicitly rejects insecure configurations (e.g., wildcard origins), and provides a clear, stateless authentication path. This approach avoids the complexities and risks associated with cookies or browser-managed credentials, which are unnecessary for this application's context. By mandating production-grade security practices in a development environment, this specification aims to foster a culture of security awareness and prevent insecure patterns from propagating to production systems.

2.0 Cross-Origin Resource Sharing (CORS) Policy Specification
2.1 The Principle of Least Privilege in CORS Configuration
The foundation of web security is the browser's Same-Origin Policy (SOP), a critical mechanism that restricts how a script on one origin can interact with a resource on another. Cross-Origin Resource Sharing (CORS) is the standard, HTTP-header-based mechanism for a server to grant a client from a different origin permission to access its resources. It is not a tool for disabling security but for configuring it correctly and explicitly. Any relaxation of the SOP must be minimal, deliberate, and justified.   

A common misconception is that services running on localhost are inherently safe from external web threats. However, any malicious webpage or compromised browser extension running in the user's browser can initiate requests to localhost endpoints. A permissive CORS policy, such as allowing all origins (*), would permit a malicious page to make successful cross-origin requests to the Bridge. For example, JavaScript on a compromised website could execute a fetch request to http://localhost:XXXX/run. If the Bridge responded with Access-Control-Allow-Origin: *, the browser would permit the request, potentially triggering unintended file system changes or other sensitive actions, thereby violating the integrity of the local development environment. Therefore, restricting the origin is a critical security control.

This specification forbids insecure patterns like wildcard (*) or dynamically reflected origins (origin: true). While convenient for initial setup, these configurations introduce significant security vulnerabilities and are a common source of "Security Misconfiguration," one of the top risks identified by OWASP. By enforcing a strict allowlist, this policy ensures that only the trusted Storybook UI can interact with the Bridge, upholding the principle of least privilege even on the local machine.   

2.2 Strict Origin Configuration
The Access-Control-Allow-Origin header must be configured to allow a single, static value. This ensures that only the intended Storybook application can make requests.

Allowed Origin: http://localhost:6006

Implementation: The server configuration must specify this exact string, including the scheme (http), domain (localhost), and port (6006). Any request whose Origin header does not exactly match this value must be rejected by the CORS mechanism.   

2.3 Permitted Methods and Headers
To minimize the attack surface, the CORS policy must only permit the methods and headers essential for the Bridge's operation.

Access-Control-Allow-Methods: The Bridge must only permit the following HTTP methods: GET, POST, OPTIONS. This list directly corresponds to the Bridge's defined endpoints (GET /tools, POST /run) and the mandatory preflight OPTIONS method used by browsers for non-simple requests.   

Access-Control-Allow-Headers: The Bridge must explicitly allow the following request headers: Content-Type, Authorization, and the custom X-Bridge-Token.

Content-Type: This header is required for the POST /run request, which will have a JSON payload (application/json). A request with this content type is considered "non-simple" and will trigger a CORS preflight check.   

X-Bridge-Token: This is the primary header for the optional authentication mechanism detailed in Section 4.0. As a custom header, it also triggers a CORS preflight check.   

Authorization: This header is included for future compatibility and to align with standard tooling that may default to using it for authentication tokens.

Access-Control-Expose-Headers: For this use case, only standard, CORS-safelisted response headers are necessary for the client to read. To be explicit, the configuration should list Content-Type.   

2.4 Credentials and State Management
The CORS policy must be configured to disallow credentialed requests.

Access-Control-Allow-Credentials: This policy must be set to false. This explicitly forbids the browser from sending cookies, HTTP authentication credentials, or TLS client certificates with cross-origin requests to the Bridge.   

Rationale: This design mandates a stateless, token-based authentication model, which is simpler and more secure for this application type. It completely eliminates the risk of Cross-Site Request Forgery (CSRF) attacks that rely on the browser's automatic inclusion of credentials like cookies in cross-origin requests.

3.0 Preflight Request (OPTIONS) Handling Protocol
3.1 Anatomy of a Preflight Request
A CORS preflight request is an OPTIONS request that the browser automatically sends before the actual HTTP request to check if the server understands and permits the cross-origin operation. This "safety check" is essential for non-simple requests.   

Trigger Conditions: A preflight request is triggered because the POST /run operation is not a "simple request" as defined by the CORS standard. The use of Content-Type: application/json and the inclusion of the custom X-Bridge-Token header are the specific conditions that necessitate a preflight check.   

Browser-Sent Headers: In the preflight OPTIONS request for the POST /run endpoint, the browser will include the following headers to ask for permission:

Origin: http://localhost:6006

Access-Control-Request-Method: POST

Access-Control-Request-Headers: content-type, x-bridge-token    

3.2 Server Response and Caching Strategy
The Bridge server must be configured to correctly handle these OPTIONS requests.

Response Requirements: The Bridge's OPTIONS handler must respond with a 204 No Content status code (or 200 OK) and include the precise Access-Control-Allow-* headers defined in Section 2.0. The response must not contain a body. This response informs the browser that the requested origin, method, and headers are permitted for the subsequent POST request.   

Access-Control-Max-Age: To optimize performance during a development session, the preflight response must include this header. It instructs the browser to cache the preflight permissions (the allowed methods and headers) for a specified duration in seconds, which prevents the browser from sending a redundant OPTIONS request before every POST call.   

Recommended Value: A value of 600 (10 minutes) is recommended. This provides a tangible performance benefit for a typical development workflow and is safely within the caching limits imposed by major browsers like Chrome (caps at 2 hours) and Firefox (caps at 24 hours).   

4.0 Optional Token-Based Authentication Model
4.1 Mechanism and Default State
The Bridge must operate in a "read-only by default" mode, enforcing the principle of least privilege for its actions.

The GET /tools endpoint, being a safe and idempotent operation, requires no authentication and is publicly accessible from the allowed origin.

The POST /run endpoint, which may perform mutations or execute tools with side effects, requires authentication if and only if the BRIDGE_TOKEN environment variable is defined on the server. If the variable is not set, the endpoint may remain accessible to ease initial setup, but this behavior must be clearly documented as a less secure, "unprotected" mode. This aligns with OWASP recommendations to enforce strong authorization on all state-changing API endpoints.   

4.2 Header and Environment Variable Specification
The authentication mechanism is based on a simple shared secret transmitted via a custom HTTP header.

Environment Variable: The authoritative token value will be provided to the Bridge server via an environment variable named BRIDGE_TOKEN. This practice is critical for security, as it prevents secrets from being hardcoded in source code, which could be accidentally committed to version control.   

HTTP Header: The client (Storybook Panel) must transmit this token in an HTTP header named X-Bridge-Token. The decision to use a custom header instead of the standard Authorization: Bearer <token> is deliberate for this specific local-only context. The Authorization header is strongly associated with standardized authentication schemes like OAuth 2.0. Using a custom header clearly signals a proprietary, non-standard mechanism, avoiding potential conflicts with browser extensions, proxies, or other development tools that might automatically intercept or manipulate the standard Authorization header. This makes the authentication mechanism for this internal tool explicit and self-documenting.   

4.3 Token Management Guidance
Proper handling of the token secret is essential, even in a local development context.

Generation: Tokens must be high-entropy, unpredictable strings. A UUID v4 or a cryptographically secure random string of at least 32 hexadecimal characters (e.g., generated via openssl rand -hex 32) is the required standard.

Storage: The BRIDGE_TOKEN should be stored in a .env file at the root of the Bridge project. This file must be added to the project's .gitignore file to prevent its accidental commitment to version control.   

Rotation: While mandatory, time-based rotation is not critical for this local development tool, documentation should strongly advise developers to regenerate the token if their .env file or local environment is ever shared or compromised.

5.0 Implementation Blueprints
The following sections provide complete, commented code snippets for implementing the specified CORS and authentication model in both Fastify and Express.

5.1 Fastify Server Implementation
This implementation uses the @fastify/cors plugin for CORS handling and a route-specific preHandler hook for authentication.

A critical aspect of this implementation is correctly handling the interaction between CORS preflight requests and authentication. A naive global authentication hook would block OPTIONS requests because they do not carry authentication headers, leading to cryptic CORS failures in the browser. The browser sends the OPTIONS request for POST /run without the X-Bridge-Token header. If a global hook checks for this header, it will reject the request with a 401 Unauthorized. The browser sees this failed preflight and blocks the actual POST request from ever being sent, resulting in an error like "CORS preflight channel did not succeed". The developer might incorrectly assume the CORS configuration is wrong, while the root cause is the authentication middleware. The correct solution, shown below, is to apply the authentication logic only to the specific route that requires it, which naturally bypasses the OPTIONS check.   

JavaScript

// main.js
import Fastify from 'fastify';
import cors from '@fastify/cors';

const fastify = Fastify({ logger: true });

// --- CORS Configuration ---
// Register the CORS plugin with a strict, allowlist-based policy.
await fastify.register(cors, {
  // 1. Specify the exact origin of the Storybook panel.
  origin: 'http://localhost:6006',
  // 2. Allow only the methods required by the bridge.
  methods:,
  // 3. Allow necessary headers, including our custom auth token header.
  allowedHeaders:,
  // 4. Disallow cookies and other browser credentials.
  credentials: false,
  // 5. Cache the preflight response for 10 minutes (600 seconds).
  maxAge: 600,
});

// --- Authentication Middleware (as a function) ---
// This function will be used as a preHandler hook on protected routes.
const requireTokenAuth = async (request, reply) => {
  const expectedToken = process.env.BRIDGE_TOKEN;

  // If BRIDGE_TOKEN is not set in the environment, auth is disabled.
  // Proceed without checking for a token.
  if (!expectedToken) {
    return;
  }

  // Read the token from the custom request header. Header names are case-insensitive.
  const providedToken = request.headers['x-bridge-token']; // [20]

  if (!providedToken) {
    fastify.log.warn('Auth failure: X-Bridge-Token header is missing.');
    reply.code(401).send({ error: 'Unauthorized', message: 'API token is required.' });
    return;
  }

  // Note: For production systems, a constant-time comparison is recommended
  // to prevent timing attacks. For local dev, direct comparison is acceptable.
  if (providedToken!== expectedToken) {
    fastify.log.warn('Auth failure: Provided token is invalid.');
    reply.code(401).send({ error: 'Unauthorized', message: 'Invalid API token.' });
    return;
  }
};

// --- Route Definitions ---

// GET /tools: A read-only endpoint that does not require authentication.
fastify.get('/tools', async (request, reply) => {
  return { tools: ['tool-a', 'tool-b'] };
});

// POST /run: A write endpoint protected by the authentication hook.
fastify.post('/run', { preHandler: }, async (request, reply) => {
  const { toolName, params } = request.body;
  fastify.log.info(`Executing tool: ${toolName} with params:`, params);
  // Business logic to run the tool...
  return { success: true, message: `Tool '${toolName}' executed.` };
});

// --- Server Start ---
try {
  await fastify.listen({ port: 3001 });
} catch (err) {
  fastify.log.error(err);
  process.exit(1);
}
5.2 Express Server Implementation
This implementation uses the cors middleware for CORS and applies a separate authentication middleware function specifically to the protected route. This pattern also correctly avoids the preflight/auth conflict by ensuring the global CORS handler processes OPTIONS requests before the route-specific auth middleware is ever invoked.

JavaScript

// main.js
const express = require('express');
const cors = require('cors');

const app = express();
app.use(express.json()); // Middleware to parse JSON bodies

// --- CORS Configuration ---
// Define the strict CORS options.
const corsOptions = {
  // 1. Specify the exact origin.
  origin: 'http://localhost:6006',
  // 2. Allow only required methods.
  methods:,
  // 3. Allow necessary headers.
  allowedHeaders:,
  // 4. Disallow credentials.
  credentials: false,
  // 5. Cache preflight response.
  maxAge: 600,
  // 6. Ensure OPTIONS requests return 204 No Content.
  optionsSuccessStatus: 204,
};

// Apply the CORS middleware globally. This will handle all OPTIONS preflight requests.
app.use(cors(corsOptions)); // [6]

// --- Authentication Middleware ---
// This middleware will be applied ONLY to routes that need protection.
const requireTokenAuth = (req, res, next) => {
  const expectedToken = process.env.BRIDGE_TOKEN;

  // If the token is not configured on the server, skip auth.
  if (!expectedToken) {
    return next();
  }

  // Read the token from the custom header using req.get() for case-insensitivity.
  const providedToken = req.get('X-Bridge-Token'); // [21, 22]

  if (!providedToken) {
    console.warn('Auth failure: X-Bridge-Token header is missing.');
    return res.status(401).json({ error: 'Unauthorized', message: 'API token is required.' });
  }

  if (providedToken!== expectedToken) {
    console.warn('Auth failure: Provided token is invalid.');
    return res.status(401).json({ error: 'Unauthorized', message: 'Invalid API token.' });
  }

  // If token is valid, proceed to the route handler.
  next();
};

// --- Route Definitions ---

// GET /tools: Publicly accessible from the allowed origin.
app.get('/tools', (req, res) => {
  res.json({ tools: ['tool-a', 'tool-b'] });
});

// POST /run: Protected by the requireTokenAuth middleware.
// The auth middleware is applied here, after the global CORS handler.
app.post('/run', requireTokenAuth, (req, res) => {
  const { toolName, params } = req.body;
  console.log(`Executing tool: ${toolName} with params:`, params);
  // Business logic...
  res.json({ success: true, message: `Tool '${toolName}' executed.` });
});

// --- Server Start ---
const PORT = 3001;
app.listen(PORT, () => {
  console.log(`Express server listening on port ${PORT}`);
});
6.0 Error Handling and Panel UX Taxonomy
6.1 Failure Mode Analysis
A robust API provides clear, semantic error responses. This section defines a contract for how the Bridge should report failures, enabling the Storybook Panel to provide meaningful feedback to the user. The distinction between authentication (401) and authorization (403) is critical: 401 Unauthorized semantically means "unauthenticated" (the client's identity is unknown or invalid), whereas 403 Forbidden means "unauthorized" (the client's identity is known, but they lack permissions for the requested action).   

6.2 Error Code and UX Response Table
The following table translates technical error conditions into specific HTTP status codes and recommended user-facing messages for the Storybook Panel. This mapping is crucial for transforming abstract API failures into an actionable and informative developer experience (DX), preventing generic "Request Failed" messages and empowering the user to self-diagnose problems.

Status Code	HTTP Reason Phrase	Trigger Condition	Recommended Panel UX Message
401 Unauthorized	Unauthorized	
The BRIDGE_TOKEN is set on the server, but the X-Bridge-Token header is missing, or the token value is incorrect. 

"Authentication Failed. Please verify your BRIDGE_TOKEN is set correctly in the Storybook Panel."
403 Forbidden	Forbidden	
The request's Origin header is not http://localhost:6006. This is typically handled by the CORS middleware, resulting in a browser-level error rather than a direct API response to the script. 

"CORS Error: Request from an invalid origin was blocked. Check your browser or proxy configuration."
415 Unsupported Media Type	Unsupported Media Type	
The POST /run request was made without a Content-Type header of application/json, or the body is malformed. 

"Invalid Request: The request must have a Content-Type of application/json."
429 Too Many Requests	Too Many Requests	
(Future-proofing) The Bridge has implemented rate limiting, and the client has exceeded the allowed request frequency. 

"Rate Limit Exceeded. Please wait a moment before trying again."
  
7.0 Security Posture and Verification
7.1 Critical Security Prohibitions
To maintain a strong security posture, the following practices are explicitly forbidden in any implementation of this specification:

No Wildcard Origins: The Access-Control-Allow-Origin header must never be set to *.

No Credentials: The Access-Control-Allow-Credentials header must always be configured as false.

No Hardcoded Tokens: The BRIDGE_TOKEN value must never be hardcoded in source files; it must be loaded from the environment.   

No Token in URL: The token must never be transmitted as a URL query parameter, as this can lead to leakage through browser history, server logs, and referrer headers.

7.2 Comprehensive Test Matrix
The following test plan provides a systematic, repeatable method to verify that any implementation is compliant and secure. It covers both successful paths and common failure scenarios, ensuring the implementation is robust.

Test Case ID	Description	Origin	Method	Headers	Token State	Expected Status
TC-01	Successful GET (read-only)	http://localhost:6006	GET	(none)	N/A	200 OK
TC-02	Successful POST with valid token	http://localhost:6006	POST	Content-Type: application/json, X-Bridge-Token: <valid>	Valid	200 OK
TC-03	Successful CORS Preflight for POST	http://localhost:6006	OPTIONS	Access-Control-Request-Method: POST, Access-Control-Request-Headers: content-type,x-bridge-token	N/A	204 No Content
TC-04	CORS Failure: Invalid Origin	http://localhost:9009	GET	(none)	N/A	Blocked by Browser
TC-05	CORS Failure: Invalid Method	http://localhost:6006	PUT	(none)	N/A	Blocked by Browser
TC-06	Auth Failure: Missing Token	http://localhost:6006	POST	Content-Type: application/json	Missing	401 Unauthorized
TC-07	Auth Failure: Invalid Token	http://localhost:6006	POST	Content-Type: application/json, X-Bridge-Token: <invalid>	Invalid	401 Unauthorized
TC-08	Payload Failure: Invalid Content-Type	http://localhost:6006	POST	Content-Type: text/plain, X-Bridge-Token: <valid>	Valid	415 Unsupported Media Type

Export to Sheets
8.0 Finalized Configuration (findings.yaml)
The following YAML block serves as a machine-readable summary of the key configuration values derived from this specification.

YAML

# cmos/missions/research/R11.2_Panel-Bridge-Auth-CORS.findings.yaml
cors:
  origin: ["http://localhost:6006"]
  methods:
  allow_headers:
  expose_headers:
  credentials: false
auth:
  header: "X-Bridge-Token"
  env: "BRIDGE_TOKEN"
  required_by_default: false
errors: ["401", "403", "415", "429"]

Sources used in the report

developer.mozilla.org
Cross-Origin Resource Sharing (CORS) - HTTP - MDN
Opens in a new window

dev.to
CORS, Preflight request and OPTIONS Method - DEV Community
Opens in a new window

apisecurity.io
OWASP API Security Top 10 - APIsecurity.io
Opens in a new window

github.com
fastify/fastify-cors: Fastify CORS - GitHub
Opens in a new window

fastapi.tiangolo.com
CORS (Cross-Origin Resource Sharing) - FastAPI
Opens in a new window

expressjs.com
Express cors middleware
Opens in a new window

medium.com
CORS Preflight Requests: Every Web Developer Must Understand | by chien hsin Yang
Opens in a new window

moesif.com
Authoritative guide to CORS (Cross-Origin Resource Sharing) for REST APIs | Moesif Blog
Opens in a new window

medium.com
How to Fix CORS Error in Express (Node.js) | by Syeda Taqvi - Medium
Opens in a new window

developer.mozilla.org
Preflight request - Glossary - MDN - Mozilla
Opens in a new window

baeldung.com
Why Is an OPTIONS Request Sent? | Baeldung on Computer Science
Opens in a new window

auth0.com
What is CORS? Complete Tutorial on Cross-Origin Resource Sharing - Auth0
Opens in a new window

developer.mozilla.org
OPTIONS request method - HTTP | MDN
Opens in a new window

developer.mozilla.org
Access-Control-Max-Age header - HTTP | MDN
Opens in a new window

udn.realityripple.com
Access-Control-Max-Age - HTTP
Opens in a new window

f5.com
OWASP API Security Top 10 Overview & Best Practices - F5
Opens in a new window

owasp.org
Secure Coding Practices Checklist - OWASP Foundation
Opens in a new window

reddit.com
API Key Security Best Practices According to OWASP : r/PracticalDevSecOps - Reddit
Opens in a new window

github.com
[5.0.0] new version giving preflight errors · Issue #102 · fastify/fastify-cors - GitHub
Opens in a new window

fastify.dev
Request | Fastify
Opens in a new window

geeksforgeeks.org
Express.js req.get() Function - GeeksforGeeks
Opens in a new window

expressjs.com
Express 5.x - API Reference
Opens in a new window

supertokens.com
Demystifying HTTP Error Codes 401 vs 403 - SuperTokens
Opens in a new window

developer.mozilla.org
HTTP response status codes - HTTP | MDN
Opens in a new window

en.wikipedia.org
List of HTTP status codes - Wikipedia
Opens in a new window

moesif.com
Understanding API Error Codes: 10 Status Errors When Building APIs For The First Time And How To Fix Them - Moesif
Opens in a new window

help.akana.com
HTTP Status Codes - Akana
Opens in a new window

restfulapi.net
HTTP Status Codes - REST API Tutorial