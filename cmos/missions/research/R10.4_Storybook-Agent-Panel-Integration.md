Storybook Agent Panel: Architectural and Implementation Blueprint
I. Architectural Blueprint for the Storybook Agent Panel
This document outlines the definitive architectural design and implementation strategy for the storybook-addon-agent. The primary objective is to create a minimal, viable addon panel within the Storybook environment that can discover and interact with a local Model-Context Protocol (MCP) service. The architecture is designed to facilitate a seamless workflow for designers and developers, enabling them to trigger read-only tools, preview changes, and approve write operations without leaving the Storybook user interface. The design prioritizes adherence to Storybook's established addon patterns, robust security for local development, and a clear separation of concerns to ensure maintainability and extensibility.

1.1. Core Architectural Decision: A Manager-Based Panel Addon
The fundamental architecture of Storybook is bifurcated into two distinct environments: the Manager and the Preview. The Manager is the primary user interface, encompassing the navigation sidebar, toolbars, and the addon panel area. The Preview, rendered within an iframe, is the sandboxed environment where the actual component stories are displayed. These two environments operate in separate contexts and communicate via a dedicated channel, an event emitter-based system that keeps their states synchronized.   

The "Agent Panel" is fundamentally a user-facing tool for orchestrating tasks, not a decorator that alters the rendering of a component within the Preview. Its purpose is to provide a rich, interactive UI for tool discovery, input rendering, and result display. Therefore, its logical and physical location must be within the Storybook Manager.

Among the various types of UI-based addons that Storybook supports, the PANEL type is the most suitable choice. A types.PANEL addon creates a dedicated, tabbed view within the addon panel at the bottom of the Storybook UI. This form factor provides ample screen real-estate for the complex interface required to list available tools, render dynamic forms for their parameters, display execution plans, and present formatted results. Alternative addon types, such as types.TOOL (which adds a simple icon button to the main toolbar) or types.TAB (which creates a full-screen canvas tab), are less appropriate for this workflow, as they either lack the necessary space or would obscure the component story being viewed.   

This decision to house the addon within the Manager has a critical and non-obvious consequence for its communication architecture. The Manager UI is, for all intents and purposes, a standard web application running in the browser. As such, it is governed by the full suite of browser security policies, most notably the Same-Origin Policy (SOP). The Storybook channel API is designed exclusively for communication between the Manager and the Preview, both of which are served from the same origin. It is not a mechanism for general-purpose communication with external services, the local network, or the filesystem. This constraint dictates that any interaction with the local MCP service must be implemented using standard web APIs, such as the Fetch API, and must therefore contend with the associated security models, particularly Cross-Origin Resource Sharing (CORS). The addon's architecture must, from the outset, be designed with a client-side HTTP bridge that is fully aware of and compliant with these browser security constraints.

1.2. Addon File Structure and Module Responsibilities
To ensure a clean separation of concerns and align with best practices established by the official Storybook Addon Kit , the addon will be structured into several distinct modules, each with a clearly defined responsibility. This modular approach enhances maintainability, testability, and readability. The core files, as specified in the project's build implications, will be register.ts, panel.tsx, bridge.ts, and types.ts.   

src/manager.ts (or register.ts): This file serves as the addon's sole entry point for the Storybook Manager. Its responsibility is to register the addon with Storybook's central addon registry. It will use the addons.register() function to assign a unique identifier to the addon. Within the registration callback, it will use addons.add() to define the panel itself, specifying its unique panel ID, its type as types.PANEL, its user-facing title (e.g., "Agent"), and the root React component to render (Panel). This file should contain no UI logic or state management.   

src/panel.tsx: This is the root React component for the addon's user interface. It will be rendered by the Manager when the user selects the "Agent" tab in the addon panel. This component is responsible for orchestrating the entire user workflow, including managing the addon's state (e.g., loading status, available tools, selected tool, execution results), handling user interactions, and rendering the appropriate child components. To ensure a consistent look and feel with the rest of the Storybook application, it will heavily leverage Storybook's internal component library, available at storybook/internal/components.   

src/bridge.ts: This is a custom module dedicated to encapsulating all communication logic with the external local MCP service. It will export functions that abstract away the complexities of making HTTP requests. For example, it will contain an asynchronous function like runTool(toolId, params) that constructs and sends a POST request using the browser's fetch API. This module will be responsible for handling JSON serialization and deserialization, error handling (including network errors and non-2xx HTTP responses), and parsing the response from the MCP service. By isolating this logic, the UI components in panel.tsx remain clean and focused on presentation.

src/types.ts: This file will serve as the single source of truth for all TypeScript type definitions used across the addon. This includes defining the interfaces for the MCP tool schemas, the structure of request and response payloads for the bridge, and the format of execution artifacts. Centralizing these types ensures type safety and consistency between the UI, the bridge, and the data contracts they operate on.

src/constants.ts: To avoid the use of "magic strings" and improve maintainability, this file will define all static constants used by the addon. This includes the unique addon ID and panel ID (e.g., my-org/agent-addon, my-org/agent-addon/panel), and the event names that conceptually map to the bridge's operations (e.g., AGENT_RUN_REQUEST, AGENT_RUN_SUCCESS, AGENT_RUN_ERROR).   

II. User Interface Structure and Component Decomposition
The user interface of the Agent Panel will be constructed as a hierarchy of React components. The design philosophy is to maximize the use of Storybook's own internal UI components to ensure visual and functional consistency with the host application. This approach reduces development effort, guarantees that the addon will respect Storybook's theming, and provides a familiar user experience.

2.1. Leveraging Storybook's Internal Component Library
Storybook exposes a rich library of its own UI components, which are battle-tested and designed for building addons. These components are accessible via the storybook/internal/components module. Utilizing this library is a core principle of this addon's design. Key components that will be employed include:   

AddonPanel: The root wrapper for the panel's content, which handles basic layout and styling.

Button: For all interactive elements, such as triggering a tool or approving an execution.

Form: A suite of components (Form.Input, Form.Select, Form.Checkbox) for dynamically building the input forms for each MCP tool.

Loader: A standardized loading spinner to provide visual feedback during asynchronous operations, such as when the addon is communicating with the MCP service.

PlaceHolder: To render informative messages in empty states, such as when no tools are available or before a tool has been run.

SyntaxHighlighter: For displaying structured data like JSON responses or code diffs in a readable, formatted way.

Tabs: For organizing different views within the panel if needed in the future (e.g., separating "Run Tool" from "History").

By composing the addon's UI from these primitive elements, the final product will feel like a native part of the Storybook experience rather than a disconnected third-party integration.

2.2. Component Hierarchy and State Flow
The UI will be orchestrated by a primary container component, AgentPanel.tsx, which manages the application state and renders a series of presentational child components based on the current stage of the user's workflow. State management will be handled primarily through standard React hooks (useState, useEffect, and potentially useReducer for more complex state transitions).

AgentPanel.tsx (Container Component):

Responsibilities: This component acts as the central controller. Upon mounting, it will use the bridge to fetch the list of available tools from the MCP service. It will manage the overall state of the addon, including isLoading, error, availableTools, selectedTool, and toolOutput. It will render the appropriate child component based on this state (e.g., showing a Loader while fetching tools, then a ToolSelector, and so on). It will also pass down callback functions to its children to handle state updates triggered by user actions.

ToolSelector.tsx (Presentational Component):

Responsibilities: This component's sole purpose is to render the list of tools discovered from the MCP service. It will receive the list of tools as a prop. It might be implemented using a Form.Select dropdown for a compact view or a list of Button components for a more explicit interface. When the user selects a tool, it will invoke an onSelect callback function passed down from AgentPanel to update the selectedTool in the parent's state.

ToolForm.tsx (Presentational Component):

Responsibilities: This component is responsible for dynamically rendering an input form based on the schema of the currently selectedTool. It will receive the tool's definition object as a prop. It will map the schema's input types (e.g., string, boolean, enum) to the corresponding input components from Storybook's Form library. It will manage its own internal form state. Upon submission, it will call an onSubmit prop, passing the collected form data up to the AgentPanel for execution via the bridge.

ExecutionPreview.tsx (Presentational Component):

Responsibilities: This component is critical for the "write approval" workflow. When a tool that performs a write operation returns a "plan" or "diff," this component will be rendered. It will clearly display the proposed changes and present two primary actions: "Approve" and "Cancel." To prevent accidental execution of destructive actions, the "Approve" button will be disabled by default. It will only become enabled after the user performs an explicit confirmation step, such as checking a box that says, "I understand these changes are irreversible."

ResultsDisplay.tsx (Presentational Component):

Responsibilities: This component is responsible for rendering the final output from a tool execution. It must be versatile enough to handle various types of artifacts. It will receive a result object as a prop and will conditionally render its content based on the artifact type. This can include:

Simple text messages or logs within a <pre> tag.

Clickable <a> tags for URLs, including links to local artifacts served by the MCP service and links to external services like Chromatic.

Formatted JSON or code snippets using the SyntaxHighlighter component.

The following table provides a clear specification for this component-based architecture, defining the data flow and responsibilities that will guide the UI implementation.

Table 1: Component Breakdown and State Management

Component	Purpose	Props	Internal State
AgentPanel	Main container, orchestrates workflow	active: boolean	status: 'idle' | 'loading' | 'error' | 'success', tools: Tool, selectedTool: Tool | null, result: Result | null
ToolSelector	Display list of tools and handle selection	tools: Tool, onSelect: (toolId) => void, disabled: boolean	filterText: string
ToolForm	Render inputs for a selected tool	tool: Tool, onSubmit: (params) => void, isSubmitting: boolean	formData: object
ExecutionPreview	Display a plan and request approval	plan: Plan, onApprove: () => void, onCancel: () => void	isConfirmed: boolean
ResultsDisplay	Render tool execution artifacts	result: Result	(none)

Export to Sheets
III. The Communication Bridge: From Storybook to the Local MCP Service
The communication bridge is the functional core of the addon, connecting the browser-based Storybook UI to the locally running MCP service. Its design must be robust, secure, and well-abstracted to isolate network logic from the user interface.

3.1. Communication Protocol: Asynchronous HTTP (Fetch API)
The interaction between the addon and the MCP service follows a classic request-response pattern: the user initiates an action, the addon sends a request, and the service returns a result. For this pattern, the most appropriate communication protocol is standard asynchronous HTTP, implemented using the browser's native fetch() API. This API is Promise-based, non-blocking, and universally available in modern browsers, making it a perfect fit.   

While WebSockets offer a more persistent, bi-directional communication channel, they introduce unnecessary complexity for this use case. A WebSocket connection would need to be established, maintained, and handled for disconnections, which is overkill for simple, discrete tool executions. HTTP provides a stateless and simpler model that aligns directly with the addon's needs.   

The bridge.ts module will contain a set of exported functions that wrap these fetch() calls. For instance, a function runTool(toolId, params, mcpPort) will be responsible for:

Constructing the target URL (e.g., http://localhost:${mcpPort}/mcp/run).

Creating a request body by serializing the toolId and params into a JSON string.

Executing the fetch() call with the method: 'POST', appropriate headers: { 'Content-Type': 'application/json' }, and the JSON body.

Awaiting the response and parsing the resulting JSON payload.

Performing robust error handling.

A crucial aspect of this bridge's design is its defensive nature. The local MCP service is not a highly available, production-grade server; it is a developer tool that may or may not be running when the user opens Storybook. Therefore, the fetch call can fail in ways that go beyond standard HTTP error codes (like 404 or 500). It can fail with a network error (e.g., ECONNREFUSED) if the server is not listening on the specified port. The bridge's implementation must wrap all fetch calls in try...catch blocks to gracefully handle these network-level failures. The error returned to the UI layer should be structured to allow the AgentPanel to distinguish between a "server not found" error and a "tool execution failed" error, enabling it to present a more helpful message to the user, such as "MCP service not detected. Please ensure it is running on port 8081."

3.2. Event Flow Diagram: A Full Request-Response Cycle
The following sequence describes the complete, end-to-end flow of events for a single tool execution, illustrating the interaction between the user, the addon's components, the bridge, and the local MCP service.

User Action: A user fills out the parameters for the a11y.scan tool in the ToolForm.tsx component and clicks the "Run Scan" button.

UI Event Handler: The onSubmit event handler within ToolForm.tsx is triggered. It gathers the form data and calls the onSubmit prop passed down from AgentPanel.tsx.

State Update (Loading): The AgentPanel.tsx component updates its state to status: 'loading', causing a Loader to be displayed.

Bridge Call: The handler in AgentPanel.tsx invokes the bridge function: bridge.runTool('a11y.scan', { storyId: '...' }, 8081).

Browser Preflight Request: Because the request is a cross-origin POST with a Content-Type of application/json, the browser determines it is not a "simple request" and automatically sends an HTTP OPTIONS request (a "preflight" request) to http://localhost:8081/mcp/run to verify that the server permits the cross-origin action.   

Server CORS Response (Preflight): The MCP service, having been configured for CORS, responds to the OPTIONS request with a 200 OK status and the necessary Access-Control-Allow-* headers, signaling its approval.

Browser Main Request: Upon receiving the successful preflight response, the browser proceeds to send the actual POST request containing the JSON payload for the tool execution.

Server Processing: The MCP service receives the POST request, parses the JSON body, identifies the a11y.scan tool, and executes it with the provided parameters.

Server Response (Main): After the tool completes, the MCP service constructs a JSON success response. Crucially, it includes the Access-Control-Allow-Origin header in this response as well. It sends this back with a 200 OK status.

Bridge Promise Resolution: The fetch promise within the bridge.ts function resolves with the server's response. The bridge function parses the JSON payload and returns the structured result data.

State Update (Success): The .then() block in the AgentPanel.tsx component's handler receives the result data. It updates its state to status: 'success' and stores the result in toolOutput.

UI Re-render: React re-renders the panel. The Loader is replaced by the ResultsDisplay component, which is now passed the toolOutput data and renders the accessibility scan results to the user.

3.3. Message Schema Definition
A clearly defined and strictly adhered-to message schema is the contract that ensures reliable communication between the addon (client) and the MCP service (server). This schema prevents integration errors and allows for independent development and testing of both components. The following table formalizes this contract.

Table 2: Message Schema Definition

Message Type	Direction	HTTP Method	Endpoint	Body (JSON Schema)	Example
Tool Execution Request	Addon -> MCP	POST	/mcp/run	{ "toolId": "string", "params": "object" }	{ "toolId": "a11y.scan", "params": { "storyId": "button--primary" } }
Success Response	MCP -> Addon	200 OK	/mcp/run	{ "status": "success", "data": { "type": "string", "content": "any", "artifacts": "Artifact | null" } }	{ "status": "success", "data": { "type": "link", "content": "Chromatic Build", "artifacts": [{ "type": "url", "value": "https://..." }] } }
Error Response	MCP -> Addon	4xx/5xx	/mcp/run	{ "status": "error", "error": { "message": "string", "details": "string | null" } }	{ "status": "error", "error": { "message": "Tool execution failed.", "details": "Axe-core timed out." } }

Export to Sheets
IV. Security Framework for Local Development
Enabling a web application like Storybook to communicate with a process running on the user's local machine requires careful consideration of browser security mechanisms. The entire interaction is predicated on correctly configuring the local MCP service to relax the browser's default security posture in a controlled and deliberate manner using Cross-Origin Resource Sharing (CORS).

4.1. The Same-Origin Policy and Its Implications
The Same-Origin Policy (SOP) is a cornerstone of web security. It prevents a script running on one origin from reading data from another origin. An "origin" is defined by the combination of protocol, hostname, and port. In this context, the Storybook Manager running at http://localhost:6006 and the local MCP service running at http://localhost:8081 are considered different origins because their ports do not match.   

Consequently, any attempt by the addon's JavaScript to make a fetch request from :6006 to :8081 will be intercepted and blocked by the browser by default. This is not a bug but a fundamental security feature preventing a malicious website from, for example, making requests to services running on a user's localhost and exfiltrating data. The solution to this problem does not lie in the client-side code of the addon; it lies entirely in the server-side configuration of the MCP service. The service must explicitly grant permission to the Storybook origin to make these requests.   

4.2. Prescriptive CORS Configuration for the MCP Service
Cross-Origin Resource Sharing (CORS) is the W3C standard mechanism that allows a server to relax the SOP. It works through a system of HTTP headers that the server sends in response to a cross-origin request. For the Agent Panel to function, the MCP service must be configured to send the correct CORS headers.   

Because the addon will be making POST requests with a Content-Type of application/json, these are considered "non-simple" requests and will trigger a CORS preflight. This means the browser will first send an OPTIONS request to the server to ask for permission before sending the actual POST request. The MCP service must be able to handle both the OPTIONS preflight and the subsequent POST request, responding with the appropriate headers in each case.   

The configuration should be as strict as possible for security. While it is possible to set Access-Control-Allow-Origin: *, this is a dangerous practice, especially for a service running on localhost, as it would allow any website visited by the user to make requests to the MCP service. The correct approach is to whitelist only the specific origin of the Storybook development server.   

Table 3: Local MCP Server CORS Configuration

Request Type	HTTP Header	Required Value	Rationale
Preflight (OPTIONS)	Access-Control-Allow-Origin	http://localhost:6006	Explicitly trusts only the default Storybook origin. This value must match the Origin header sent by the browser exactly.
Access-Control-Allow-Methods	POST, GET, OPTIONS	Allows the HTTP methods required by the communication bridge.
Access-Control-Allow-Headers	Content-Type	Explicitly allows the client to send the Content-Type header, which is necessary for application/json payloads.
Main (POST)	Access-Control-Allow-Origin	http://localhost:6006	Re-affirms trust for the main request. This header is mandatory on the main response as well.

Export to Sheets
This prescriptive configuration is the single most critical element for enabling communication. Any deviation will result in the browser blocking the requests.

4.3. Handling Authentication and Configuration
For a local development tool, complex authentication mechanisms like OAuth or session tokens are unnecessary and would add significant friction. The security model relies on the strict CORS policy, which ensures that only the trusted Storybook application can communicate with the service.

However, hardcoding values like the MCP service's port number is brittle and can lead to conflicts with other development tools. To address this, the addon's configuration should be managed through Storybook's native parameters API. This allows users to customize the addon's behavior in their project's .storybook/preview.js file.   

For example, a user can configure the MCP port as follows:

JavaScript

// in.storybook/preview.js
export const parameters = {
  agent: {
    // The port where the local MCP service is running.
    mcpPort: 8081,
  },
};
Inside the AgentPanel.tsx component, this configuration can be accessed using the useParameter hook from the @storybook/manager-api package.   

TypeScript

// in src/panel.tsx
import { useParameter } from '@storybook/manager-api';

const AgentPanel = () => {
  const agentParams = useParameter('agent', { mcpPort: 8081 });
  const mcpPort = agentParams.mcpPort;

  //... use mcpPort when calling the bridge functions
};
This approach makes the addon flexible and robust, allowing developers to easily adapt it to their local environment without modifying the addon's source code.

V. Artifact Management and Presentation
A key function of the Agent Panel is to display the outputs, or "artifacts," generated by the MCP tools in a useful and actionable format. This requires a strategy for handling different types of content, from local files to links for external services.

5.1. Linking to Local File System Artifacts
A common artifact type will be locally generated files, such as an HTML accessibility report or a visual regression diff image. A naive approach would be to have the MCP service return a file:// URL (e.g., file:///Users/dev/project/artifacts/report.html). However, for security reasons, modern browsers heavily restrict or completely block navigation to file:// URLs from pages served over http://. This makes direct file system links unreliable and unsuitable for this addon.   

The most robust and secure solution is for the local MCP service to perform a dual role: in addition to being a tool runner, it should also act as a simple static file server for its own generated artifacts. When a tool like purity.audit generates a report in a subdirectory (e.g., /artifacts/current-state/YYYY-MM-DD/), the MCP service can serve this directory over HTTP.

The workflow would be as follows:

The purity.audit tool runs and saves its output to ./artifacts/purity-report/index.html.

The MCP service returns a success response to the addon, containing an artifact with the URL http://localhost:8081/artifacts/purity-report/index.html.

The ResultsDisplay.tsx component in the addon panel renders this as a standard <a href="..." target="_blank">View Purity Report</a> link.

When the user clicks the link, the browser opens a new tab and makes a standard HTTP request to the local MCP service, which serves the report file.

This approach works reliably within the browser's security model and provides a seamless user experience.

5.2. Generating Links to Chromatic Builds
For visual regression testing (vrt.run), the primary artifact is the result of a Chromatic build. The addon should provide direct links to the relevant Chromatic pages. Chromatic URLs follow a predictable and well-documented format, typically https://<branch>--<appid>.chromatic.com.   

When the vrt.run tool is executed, the underlying MCP service will invoke the Chromatic CLI. This CLI provides several useful outputs, either directly to standard output or via a diagnostics file (chromatic-diagnostics.json) when run with the --diagnostics-file flag. The Chromatic GitHub Action also exposes these as outputs. The MCP service should be designed to capture these outputs.   

This opens up the possibility for a much richer workflow than simply linking to the published Storybook. The Chromatic CLI provides at least two key URLs:

storybookUrl: The permalink to the published, browsable Storybook for that specific commit or branch. This is useful for general review. Example: https://main--your-app-id.chromatic.com.

buildUrl: The link to the Chromatic build page itself, where visual diffs are reviewed and approved. This is the primary destination for the VRT workflow. Example: https://www.chromatic.com/build?appId=...&number=....

The MCP service should capture both of these URLs and return them as distinct artifacts in its response payload. The ResultsDisplay.tsx component can then render two separate, clearly labeled links: "View Published Storybook" and "Review Visual Changes." This provides the user with direct access to the exact resources they need for each part of their workflow, deeply integrating the local Storybook environment with the cloud-based Chromatic service.

VI. Implementation Strategy, Pitfalls, and Recommendations
A successful implementation of the Storybook Agent Panel requires a phased development approach, an awareness of common pitfalls, and a solid testing strategy. This section provides a strategic roadmap to guide the engineering team.

6.1. Phased Implementation Approach
A phased approach is recommended to de-risk the project by tackling the most complex and uncertain parts first.

Phase 1: Foundation and Read-Only Bridge. The initial focus should be on establishing the core addon structure (register.ts, panel.tsx) and the communication bridge. Begin by implementing the bridge.ts module to fetch a static, hardcoded list of tools from a mocked MCP endpoint. The primary goal of this phase is to get the addon panel to render and to solve the CORS configuration challenge. This isolates the most common point of failure and ensures the fundamental communication channel is working before any complex UI is built.

Phase 2: Dynamic Forms and Read-Only Execution. Once the bridge is established, implement the dynamic form rendering in ToolForm.tsx based on tool schemas returned from the (still mocked or simple) MCP service. Connect the form submission to execute a simple, read-only tool like a11y.scan. The initial version of ResultsDisplay.tsx can simply render the raw JSON response using the SyntaxHighlighter component.

Phase 3: Artifact Presentation. With the end-to-end flow for read-only tools working, enhance the ResultsDisplay.tsx component. Implement the logic to parse the artifacts array from the MCP response and conditionally render different UI elements for each artifact type (e.g., local server links, Chromatic URLs, plain text).

Phase 4: Write Operations and Approval Flow. Finally, implement the workflow for write-based tools like reviewKit.create. This involves building the ExecutionPreview.tsx component to display the plan/diff and implementing the explicit approval mechanism to ensure user intent is confirmed before triggering a write operation.

6.2. Potential Pitfalls and Mitigation Strategies
Pitfall: CORS Debugging Nightmare.

Description: Developers, particularly those less familiar with browser security models, can lose days debugging why fetch requests are failing silently or with cryptic network errors. The browser's developer console often shows a generic CORS error without detailing the specific header mismatch.

Mitigation: This report's Table 3 must be treated as the canonical specification for the MCP service's CORS implementation. The MCP service itself should be instrumented with extensive logging for all incoming requests, specifically logging the Origin header it receives and the Access-Control-* headers it sends in response. This server-side visibility is crucial for diagnosing mismatches.

Pitfall: Inconsistent State Management.

Description: The addon's UI is highly asynchronous. Without a disciplined approach to state management, it's easy to create bugs where the UI gets stuck in a loading state, a "Run" button remains disabled after an error, or stale data is displayed.

Mitigation: Employ a finite state machine or a useReducer hook within the main AgentPanel.tsx component. Explicitly define the possible states (e.g., 'IDLE', 'FETCHING_TOOLS', 'TOOL_SELECTED', 'EXECUTING_TOOL', 'DISPLAYING_RESULT', 'ERROR') and the valid transitions between them. This makes the application's state flow predictable, testable, and easier to debug.

Pitfall: Environment Brittleness.

Description: Hardcoding values such as the MCP service port (8081) or specific URL paths will make the addon fragile and difficult for other developers to adopt if their local environment has a port conflict or a different setup.

Mitigation: As detailed in section 4.3, all environment-specific configurations must be exposed through Storybook's parameters API. The addon should be documented with clear instructions on how to configure these parameters in .storybook/preview.js, and it should provide sensible defaults.

6.3. Recommendations for Testing and Maintenance
A multi-layered testing strategy will ensure the addon's long-term quality and stability.

Unit Testing: The bridge.ts module is a prime candidate for unit testing. Using a testing framework like Vitest or Jest, the fetch API can be mocked to test the bridge's logic in isolation. Tests should verify that it correctly formats request bodies, handles various successful and error responses from the mock server, and properly parses the returned JSON.

Integration Testing: The MCP service requires its own suite of integration tests. These tests should validate not only the tool execution logic but also the correctness of its HTTP responses, particularly the CORS headers. Command-line tools like curl can be used in test scripts to simulate cross-origin requests and assert that the expected Access-Control-Allow-Origin headers are present.

End-to-End (E2E) Testing: Once the addon is stable, an E2E testing strategy can provide the highest level of confidence. Using a tool like Storybook's test runner, which can execute tests against a running Storybook instance, it is possible to write automated tests that interact with the Agent Panel's UI, click buttons, and verify that the expected results are displayed. This validates the entire workflow from the user's perspective.   


Sources used in the report

storybook.js.org
Introduction to addons | Storybook docs
Opens in a new window

storybook.js.org
Addon API | Storybook docs - JS.ORG
Opens in a new window

v4-0-10--storybooks.netlify.app
Writing Addons - Storybook
Opens in a new window

storybook.js.org
Types of addons | Storybook docs
Opens in a new window

storybooks.netlify.app
Writing Addons - Storybook
Opens in a new window

github.com
storybookjs/addon-kit: Everything you need to build a Storybook addon - GitHub
Opens in a new window

storybook.js.org
Write an addon | Storybook docs
Opens in a new window

storybook.js.org
Addon knowledge base | Storybook docs - JS.ORG
Opens in a new window

storybook.js.org
storybook-addon-chat | Storybook integrations
Opens in a new window

developer.mozilla.org
Making network requests with JavaScript - Learn web development | MDN - Mozilla
Opens in a new window

developer.mozilla.org
Writing WebSocket client applications - Web APIs - MDN
Opens in a new window

geeksforgeeks.org
How to Create a WebSocket Connection in JavaScript ? - GeeksforGeeks
Opens in a new window

developer.mozilla.org
Cross-Origin Resource Sharing (CORS) - HTTP - MDN
Opens in a new window

learn.microsoft.com
Enable Cross-Origin Requests (CORS) in ASP.NET Core | Microsoft Learn
Opens in a new window

concordusa.com
What is CORS, and Why Does It Keep Coming Up in My Projects? - Concord USA
Opens in a new window

github.blog
Localhost dangers: CORS and DNS rebinding - The GitHub Blog
Opens in a new window

fastapi.tiangolo.com
CORS (Cross-Origin Resource Sharing) - FastAPI
Opens in a new window

storybook.js.org
Configure and communicate with an addon | Storybook docs
Opens in a new window

github.com
Addon: Building a Custom Panel · storybookjs storybook · Discussion #26235 - GitHub
Opens in a new window

developer.mozilla.org
How do you set up a local testing server? - Learn web development | MDN
Opens in a new window

developer.mozilla.org
Window: localStorage property - Web APIs - MDN
Opens in a new window

chromatic.com
Permalinks • Chromatic docs
Opens in a new window

story.to.design
Connect your Storybook - story.to.design
Opens in a new window

chromatic.com
How do I get the published Storybook output URL through the CI pipeline? • Chromatic docs
Opens in a new window

chromatic.com
Automate Chromatic with GitHub Actions
Opens in a new window

storybook.js.org
Vitest addon | Storybook docs