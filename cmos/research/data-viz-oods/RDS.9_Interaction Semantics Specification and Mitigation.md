Interaction Semantics Specification and Mitigation for R-002
I. A Formal Interaction Semantics Model for OODS
This section presents the formal declarative model for interaction semantics, designed to bridge the "semantic gap" identified in Risk R-002. The core deficiency of existing systems is the reliance on imperative, platform-specific event handlers to define interactive behaviors, which are difficult to port, compose, and formally reason about.   

The foundation of the OODS (Organization-Wide Data Visualization Standard) interaction grammar is an adoption and formalization of the principles established in the "Reactive Vega" model. This model provides the necessary abstractions to decouple interaction intent from execution mechanisms.   

1.1 Bridging the Semantic Gap: A Reactive Signal-Based Model
The semantic gap arises from the lack of a formal chain linking low-level user inputs to high-level data-domain changes. Imperative libraries, as explored in mission-dv-6, require developers to manually script this entire causal chain: listening to a DOM event, converting pixel coordinates to data values through scale inversions, building a data query, and finally manipulating the visualization state.

The OODS interaction grammar formalizes this chain declaratively using a reactive dataflow architecture. This model is composed of four core components:   

Events: The raw, low-level event streams originating from the renderer or browser (e.g., mousemove, click, dragstart). These are modeled as composable data streams.   

Signals: Higher-level, composable streams that derive semantic meaning from raw events. For example, a "brush" signal is a composition of mousedown, mousemove, and mouseup event streams.   

Predicates: The data-domain query generated from a signal. This is the critical "lifting" mechanism that closes the semantic gap. It uses scale inversions to map pixel-level geometry (e.g., the coordinates of a drag-box) into a query over the data domain (e.g., a filter on the 'Year' field from 2010 to 2015).   

Production Rules: Declarative rules that bind the Predicate (the data query) to a specific manipulation of the visualization's appearance or data transforms.   

This reactive model implies that a change in an event stream automatically propagates through the chain, updating signals, predicates, and, consequently, the visualization itself. This declarative dataflow stands in direct contrast to the imperative dispatchAction model of Apache ECharts, establishing the friction identified in mission-dv-6 and defining the primary architectural challenge for our cross-renderer adapter.

1.2 The Normalized Interaction Schema: State Machines and Event Payloads
To satisfy the constraint for a normalized schema, each interaction trait is formally modeled as a Finite State Machine (FSM). This approach provides a robust, testable, and predictable structure for managing the lifecycle of an interaction, such as [idle] -> (mousedown) -> [brushing] -> (mouseup) -> [brushed].   

The FSM model is synthesized with the reactive signal model:

State Machine: The OODS InteractionTrait defines the available states and transitions.

Events: Low-level user inputs (e.g., mousedown) act as the triggers for FSM transitions.   

Payload: The output of an FSM transition (e.g., entering the brushed state) is the Predicate (the data query) from the reactive model. This predicate is packaged into a standardized, normalized event payload.   

Production Rule: The Production Rule is the consumer of this event payload, binding the data query to a visual change.

This event-driven architecture (EDA)  ensures that all interaction state changes are published in a consistent, renderer-agnostic format. Table 1 defines the normalized schema for this event payload, which is the standard data structure emitted by the OODS interaction system.   

Table 1: Normalized Interaction Event Schema (Payload Structure)

Field	Type	Description	Example
interactionId	string	Unique name of the interaction instance, matching the spec.	"user_brush"
interactionType	string	The semantic type of the interaction.	"intervalSelection"
state	string	The current state of the FSM for this interaction.	"brushed" (active) or "idle" (cleared)
payload	object	The normalized Predicate (data query) generated by the interaction.	{"field": "Horsepower", "range": }
sourceEvent	object	The original DOM event that triggered the state change (optional, for debugging).	(MouseEvent)
1.3 Specification Deliverable: The InteractionTrait Schema
The InteractionTrait is the formal, machine-readable definition that OODS users will add to their visualization specifications. It encapsulates the FSM and reactive models into a single declarative object. This specification is provided in both TypeScript (for development) and JSON Schema (for validation).

Deliverable 1: TypeScript Definition (.d.ts)
This definition  defines the high-level grammar for OODS interactions.   

TypeScript
/**
 * Defines the selection primitive that generates a Predicate (the data query).
 */
type SelectionType = 

| { 
      /** Selects discrete data values (e.g., on click). */
      type: 'point'; 
      /** The event stream that triggers the selection (e.g., 'click', 'hover'). */
      on: string; 
      /** Data fields to use for the predicate. */
      fields: string; 
    }

| { 
      /** Selects a continuous range of data values (e.g., a "brush"). */
      type: 'interval'; 
      /** The event stream that triggers the selection (e.g., 'drag'). */
      on: string; 
      /** Encoding channels (e.g., 'x', 'y') to drive the interval selection. */
      encodings: ('x' | 'y'); 
    };

/**
 * Defines the Production Rule that consumes the Predicate.
 */
type ProductionRule =

| { 
      /** Binds the predicate to a data filter, subsetting the view. */
      bindTo: 'filter'; 
    }

| { 
      /** Binds the predicate to a conditional visual property. */
      bindTo: 'visual'; 
      /** The visual property to modify (e.g., 'opacity', 'fillColor'). */
      property: string; 
      /** The visual value to apply for data *inside* the predicate. */
      condition: { value: any }; 
      /** The visual value to apply for data *outside* the predicate. */
      else: { value: any }; 
    }

| { 
      /** Binds the predicate (on hover/focus) to a tooltip. */
      bindTo: 'tooltip'; 
      /** The data fields to display in the tooltip. */
      fields: string; 
    };

/**
 * The formal InteractionTrait, which is the core of the OODS interaction grammar.
 */
export interface InteractionTrait {
  /** 
   * A unique name for this interaction, used to reference its signal.
   */
  id: string;

  /**
   * Defines the selection primitive (e.g., 'point' or 'interval')
   * that generates the Predicate (the data query).
   */
  select: SelectionType;

  /**
   * Defines the Production Rule that consumes the Predicate
   * and manipulates the visualization.
   */
  rule: ProductionRule;
}
Deliverable 2: JSON Schema Definition (interaction.schema.json)
This JSON Schema  enables platform-level validation and editor autocomplete for the InteractionTrait.   

JSON
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "InteractionTrait",
  "description": "A formal definition for a declarative interaction trait in OODS.",
  "type": "object",
  "properties": {
    "id": {
      "description": "A unique name for this interaction, used to reference its signal.",
      "type": "string"
    },
    "select": {
      "description": "Defines the selection primitive that generates the Predicate.",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "type": { "enum": ["point"] },
            "on": { "type": "string", "examples": ["click", "hover"] },
            "fields": { "type": "array", "items": { "type": "string" } }
          },
          "required": ["type", "on", "fields"]
        },
        {
          "type": "object",
          "properties": {
            "type": { "enum": ["interval"] },
            "on": { "type": "string", "examples": ["drag"] },
            "encodings": { 
              "type": "array", 
              "items": { "enum": ["x", "y"] }
            }
          },
          "required": ["type", "on", "encodings"]
        }
      ]
    },
    "rule": {
      "description": "Defines the Production Rule that consumes the Predicate.",
      "oneOf": }
          },
          "required":
        },
        {
          "type": "object",
          "properties": {
            "bindTo": { "enum": ["visual"] },
            "property": { "type": "string" },
            "condition": { "type": "object", "properties": {"value": {}} },
            "else": { "type": "object", "properties": {"value": {}} }
          },
          "required":
        },
        {
          "type": "object",
          "properties": {
            "bindTo": { "enum": ["tooltip"] },
            "fields": { "type": "array", "items": { "type": "string" } }
          },
          "required":
        }
      ]
    }
  },
  "required": ["id", "select", "rule"]
}
II. Catalogue and Composition of Prioritized Interaction Traits
This section catalogues the five prioritized interaction intents (Constraint 1) by mapping them to the formal InteractionTrait model.

A critical simplification of the formal model is the unification of "Highlight," "Filter," and "Linked View." These are not distinct types of interaction. Rather, they are different applications (Production Rules) of the same underlying Selection primitive.   

This composability (a dependency of mission-dv-3) is achieved by separating the Predicate (the "what," defined by select) from the Production Rule (the "how," defined by rule).

A Highlight rule  consumes the predicate to conditionally set opacity.   

A Filter rule  consumes the predicate to subset the data.   

A Linked View  is achieved when a remote view's data transform consumes the predicate from a source view.   

This model is more robust and extensible than defining five separate, monolithic traits.

2.1 Trait 1: Tooltip (Details-on-Demand)
Conceptual Model: A transient graphical user interface (GUI) element that appears on hover or focus to provide brief, contextual information about a data point.   

OODS Trait Definition:

select: { type: 'point', on: 'hover', fields: [...] }

rule: { bindTo: 'tooltip', fields: [...] }

State Machine: [Hidden] -> (on_focus | on_hover) -> [Visible] -> (on_blur | on_mouseout) -> [Hidden]

2.2 Trait 2: Highlight (Emphasize)
Conceptual Model: Drawing a user's attention to a subset of data by modifying its visual properties (e.g., opacity, stroke) in response to an event.   

OODS Trait Definition:

select: { type: 'point', on: 'click', fields: [...] }

rule: { bindTo: 'visual', property: 'opacity', condition: { value: 1.0 }, else: { value: 0.3 } }

State Machine: -> (on_select_predicate) -> [Emphasized] -> (on_clear) ->

2.3 Trait 3: Focus (Contextual Drill-Down)
Conceptual Model: A specific form of highlight, typically for a single item, that implies singular selection and may be used to reveal contextual UI or controls.

OODS Trait Definition:

select: { type: 'point', on: 'click', fields: [...] }

rule: { bindTo: 'visual', property: 'strokeWidth', condition: { value: 2 }, else: { value: 0 } }

Note: The semantic intent of "Focus" versus "Highlight" is captured by the developer's choice of Production Rule, not by a different interaction type.

2.4 Trait 4: Filter (Subset)
Conceptual Model: Dynamically subsetting the underlying data source based on a user-defined selection, often via a "brush" (an interval selection).   

OODS Trait Definition:

select: { type: 'interval', on: 'drag', encodings: ['x'] }

rule: { bindTo: 'filter' }

State Machine: [Unfiltered] -> (on_brush_end) -> [Filtered] -> (on_clear) -> [Unfiltered]

2.5 Trait 5: Linked View (Brush & Link)
Conceptual Model: An interval selection (brushing)  in one view (ViewA) that acts as a predicate to filter or highlight a separate, linked view (ViewB).   

OODS Trait Definition (Composite): This is not a single trait but a composition of a trait and a subscription.

On ViewA: InteractionTrait { id: 'my_brush', select: { type: 'interval', on: 'drag', encodings: ['x'] }, rule:... }

On ViewB: The ViewB specification subscribes to the predicate generated by my_brush. transform: [{ filter: { predicate: 'my_brush' } }]

Note: This demonstrates true composability. The my_brush predicate can be consumed by a production rule on ViewA (e.g., to show the brush) and by a data transform on ViewB (to filter it).

Table 2 summarizes the mapping of the five prioritized intents to the formal OODS interaction grammar.

Table 2: Prioritized Interaction Trait Definitions

User Intent	OODS select.type	OODS select.on	OODS rule.bindTo	FSM States
Tooltip	point	hover / focus	tooltip	Hidden -> Visible
Highlight	point	click	visual (e.g., opacity)	Default -> Emphasized
Focus	point	click / contextmenu	visual (e.g., stroke)	Default -> Focused
Linked View	interval	drag	filter (on remote view)	(ViewA) -> (ViewB)
Filter	interval	drag	filter	Unfiltered -> Filtered
III. Renderer Implementation Notes and Adapter Patterns
This section provides the implementation guide (Deliverable 2) for translating the abstract OODS InteractionTrait into concrete renderer specifications for Vega-Lite and Apache ECharts (Constraint 3).

3.1 Target 1: Vega-Lite (Native Declarative Mapping)
Vega-Lite serves as the reference implementation, as its interaction grammar (based on "Reactive Vega") aligns natively with the OODS model. The mapping from the InteractionTrait to the Vega-Lite params definition  is nearly one-to-one.   

select -> params: The OODS select object maps directly to a Vega-Lite params object containing a select property.   

rule:visual -> condition: The OODS visual rule maps directly to a condition object within an encoding channel.   

rule:filter -> transform: The OODS filter rule maps directly to a filter transform that references the param.   

rule:tooltip -> tooltip: The OODS tooltip rule maps to the tooltip encoding channel , which requires the vega-tooltip plugin for rich HTML tooltips.   

Prototype Implementation 1 (Highlight)
This demonstrates mapping the OODS Highlight trait to the Vega-Lite specification.   

OODS Trait:

JSON
{
  "id": "sel", 
  "select": {"type": "point", "on": "click", "fields": ["a"]}, 
  "rule": {
    "bindTo": "visual", 
    "property": "fillOpacity", 
    "condition": {"value": 1}, 
    "else": {"value": 0.3}
  }
}
Resulting Vega-Lite JSON (Adapter Output):

JSON
{
  "params": [
    {"name": "sel", "select": {"type": "point"}}
  ],
  "encoding": {
    "fillOpacity": {
      "condition": {"param": "sel", "value": 1},
      "value": 0.3
    }
  }
}
Prototype Implementation 2 (Filter/Brush)
This demonstrates mapping the OODS Filter trait to the Vega-Lite specification.   

OODS Trait:

JSON
{
  "id": "brush", 
  "select": {"type": "interval", "on": "drag", "encodings": ["x"]}, 
  "rule": {"bindTo": "filter"}
}
Resulting Vega-Lite JSON (Adapter Output):

JSON
{
  "params": [
    {"name": "brush", "select": {"type": "interval", "encodings": ["x"]}}
  ],
  "transform": [
    {"filter": {"param": "brush"}}
  ]
}
3.2 Target 2: Apache ECharts (The Imperative Adapter Pattern)
This adapter is the primary mitigation for Risk R-002. Apache ECharts does not possess a declarative interaction grammar; it is a declarative visualization library with an imperative interaction model. Interactions are managed via event listeners (myChart.on)  and programmatic API calls (myChart.dispatchAction).   

An OODS-ECharts-Adapter is therefore required. This adapter is a function that receives the OODS visualization specification and an initialized ECharts instance. It then iterates over the interactionTraits array and injects the necessary imperative event handlers and component configurations to simulate the declarative intent.

Prototype Implementation 1 (Highlight)
OODS Trait: {"id": "hl", "select": {"type": "point", "on": "hover"}, "rule": {"bindTo": "visual"}}

Adapter Code (simulated): The adapter translates this trait into event listeners that trigger ECharts' built-in highlight and downplay actions.   

JavaScript
// Adapter injects this logic:
chartInstance.on('mouseover', (params) => {
  chartInstance.dispatchAction({
    type: 'highlight',
    seriesIndex: params.seriesIndex,
    dataIndex: params.dataIndex
  });
});
chartInstance.on('mouseout', (params) => {
  chartInstance.dispatchAction({
    type: 'downplay',
    seriesIndex: params.seriesIndex,
    dataIndex: params.dataIndex
  });
});
Prototype Implementation 2 (Filter/Brush)
OODS Trait: {"id": "brush", "select": {"type": "interval", "encodings": ["x"]}, "rule": {"bindTo": "filter"}}

Adapter Code (simulated): The adapter translates this by configuring the ECharts dataZoom component , which is the closest equivalent to an interval filter.   

JavaScript
// 1. Adapter injects 'dataZoom' component into the ECharts option
const eChartsOption = {
  //...
  dataZoom: [
    {
      type: 'slider', // or 'inside'
      xAxisIndex: 0,
      filterMode: 'filter' // 'filter' mode subsets the data [46]
    }
  ],
  //...
};
chartInstance.setOption(eChartsOption);

// 2. Adapter listens for the result to update OODS state
chartInstance.on('datazoom', (params) => {
  // params.startValue and params.endValue contain the 
  // data-domain predicate. This can be published to the
  // OODS event bus (per Table 1).
});
Prototype Implementation 3 (Linked View)
OODS Trait: ViewA has id: 'my_brush'. ViewB has transform: [{ filter: { predicate: 'my_brush' } }].

Adapter Code (simulated): The native echarts.connect()  is insufficient. It links all interactions, is not granular , and is known to break with complex series. The adapter must create the link manually.   

JavaScript
// Adapter must have references to both chart instances
const chartA = echarts.getInstanceByDom(domA);
const chartB = echarts.getInstanceByDom(domB);

// Adapter injects this cross-instance logic:
chartA.on('datazoom', (params) => {
  // A brush on ChartA...
  //...programmatically triggers a 'dataZoom' on ChartB
  chartB.dispatchAction({
    type: 'dataZoom',
    dataZoomIndex: 0, // Target the correct component on ChartB
    startValue: params.startValue,
    endValue: params.endValue
  });
});
Prototype Implementation 4 (Tooltip)
OODS Trait: {"id": "tt", "rule": {"bindTo": "tooltip", "fields": ["category", "value"]}}

Adapter Code (simulated): The adapter injects a tooltip.formatter function  into the ECharts option.   

JavaScript
// Adapter generates this function based on the 'fields' array
eChartsOption.tooltip.formatter = (params) => {
  const data = params.data;
  // This string is built dynamically from the OODS trait
  return `<strong>${data.category}</strong><br/>Value: ${data.value}`;
};
chartInstance.setOption(eChartsOption);
3.3 OODS-to-Renderer Mapping Equivalence
Table 3 provides the summary mapping and identifies the specific points of friction that constitute Risk R-002 (Constraint 3).

Table 3: OODS-to-Renderer Mapping Equivalence

OODS Trait	Vega-Lite Mapping (Native)	ECharts Mapping (Adapter)	ECharts Gaps / Friction (R-002)
select: {type: 'point'}	params: [{select: 'point'}]	myChart.on('click',...) + dispatchAction('highlight')	Imperative. Requires adapter. State must be managed by the adapter.
select: {type: 'interval'}	params: [{select: 'interval'}]	dataZoom or brush component.	
Components must be pre-configured. dataZoom is the most robust implementation for filtering.[44, 52]

rule: {bindTo: 'visual'}	encoding: {condition:...}	dispatchAction('highlight') / dispatchAction('downplay')	
highlight is a pre-defined state.[41, 42] Arbitrary visual rules (e.g., binding a selection to symbolSize) are not supported. This is a gap.

rule: {bindTo: 'filter'}	transform: [{filter:...}]	
dataZoom component with filterMode: 'filter'.[46]

dataZoom is an axis filter. Filtering on non-axis encodings (e.g., a categorical legend) is not supported by this component. This is a gap.
rule: {bindTo: 'tooltip'}	encoding: {tooltip:...}	option.tooltip.formatter =...	
Imperative. Requires adapter to generate the formatter function.[51]

Linked View (Composite)	Shared param name.	Manual chartA.on(...) -> chartB.dispatchAction(...)	
echarts.connect() is too coarse and unreliable.[49, 50] Manual adapter logic is required for every link. This is a major implementation gap.

IV. Accessibility and Portability Playbook
This section provides the compliance guide (Deliverable 3) for ensuring all interactions defined by this model adhere to dv-4 accessibility mandates (Constraint 4). These rules are non-negotiable for all OODS renderers and adapters.

4.1 Rule 1: The Portability Mandate (Static Equivalence)
Information must never be exclusively available via interaction. All interactive visualizations must degrade gracefully to a static, portable, and accessible equivalent.   

Rule 1a (Text Summary): All charts must be accompanied by a text-based summary (e.g., in an adjacent paragraph) that describes the key insights, trends, and conclusions. This serves as the primary information channel for users who cannot or choose not to interact with the chart.   

Rule 1b (Data Table): All charts must provide an accessible, semantically-correct data table (<table>) of the source data. This is the "conformant alternate version"  that provides full data equivalence.   

Rule 1c (No Color-Only): Meaning must not be conveyed by color alone. Secondary indicators (patterns, labels, symbols) must be used. ECharts 5's "decal patterns"  are a recommended implementation.   

4.2 Rule 2: The Keyboard Mandate (Operability)
All functionality available via mouse must be available via keyboard (WCAG 2.1).   

Rule 2a (Focus Order): The chart container must be focusable (e.g., tabindex="0"). A logical focus order must be maintained.   

Rule 2b (Navigation): Tab / Shift+Tab navigates into and out of the chart container. Arrow Keys (Up/Down/Left/Right) must be used to navigate between individual data points (e.g., bars, scatter points) inside the chart. Tab must not be used to navigate data points, as this creates a "keyboard trap" for users with large datasets.   

Rule 2c (Activation): Enter or Space must activate the primary interaction (e.g., "Highlight" or "Filter") on the currently focused data point.   

Rule 2d (Tooltips): Tooltips must be triggered on keyboard focus of a data point, not just hover.   

Rule 2e (Clear): The Esc key must clear the current selection, filter, or brush and return the chart to its default state.   

4.3 Rule 3: The Narration Mandate (Perceivability)
All interactions and state changes must be clearly narrated by screen readers.

Rule 3a (Static Narration): The chart container must have an appropriate ARIA role (e.g., role="graphics-document") and a descriptive aria-label  summarizing its purpose (e.g., "Bar chart showing sales over time"). It should use aria-describedby  to link to the static summary (from Rule 1a).   

Rule 3b (Element Narration): Each interactive data point (bar, dot) must have a role (e.g., role="graphics-symbol" or role="button") and a dynamic aria-label providing its full context. For example: "Bar. 2018. Sales. $1,500. Press Enter to select."   

Rule 3c (Live Narration): The most critical accessibility requirement for interaction is narrating state changes that are not inherently obvious to a screen reader user. The OODS renderer must manage a hidden aria-live="polite" region. When an interaction (like a filter or brush) is completed, the adapter must inject a text summary of the change into this region.   

Example (Filter): User applies a brush. The aria-live region is populated with: "Chart updated. Now showing 5 of 20 items."

Example (Highlight): User highlights a bar. The aria-live region is populated with: "Item selected. 2018. Sales. $1,500."

Implementation: This aria-live update is a core requirement for the ECharts adapter, to be triggered alongside the dispatchAction call. ECharts' built-in aria module  must be evaluated against this rule; if it is insufficient, the adapter must override it.   

4.4 Interaction Equivalence Checklist
This checklist (Success Criterion 3) provides the definitive compliance test for developers and quality assurance, unifying the rules from this playbook.

Table 4: Accessibility Equivalence Checklist

Interaction Trait	Keyboard Flow	Screen Reader Narration (Focus)	Screen Reader Narration (State Change)	Static Fallback (Portability)
Tooltip	Tab to chart, Arrows to item. Tooltip appears on focus.	aria-label on item read (e.g., "Bar. 2018. $1500"). Tooltip content is read.	N/A (state is transient).	Data table contains all tooltip-level data.
Highlight	Tab to chart, Arrows to item. Enter/Space to select.	aria-label on item read. State is announced (e.g., "Selected").	aria-live region announces: "Item highlighted. 2018. $1500."	Data table. Text summary highlights the same data point if it is a key insight.
Focus	(Same as Highlight)	(Same as Highlight)	(Same as Highlight)	(Same as Highlight)
Filter (Brush)	Tab to chart. Alt+D (or similar) to enter "Brush Mode". Arrow keys move brush. Enter applies. Esc clears.	aria-label on chart. Instructions for brushing announced on focus.	aria-live region announces result: "Filter applied. Now showing 12 of 50 items." Esc press announces "Filter cleared."	Data table. Text summary describes the default unfiltered view.
Linked View	(Same as Filter)	(Same as Filter)	aria-live region announces change in both charts: "Filter applied on Chart 1. Chart 2 updated. Now showing 8 of 20 items."	Separate data tables and summaries for all charts. Summary text must describe the relationship.
V. Mission Closure: Mitigation for Risk R-002
This section provides the final update to Risk R-002, per Success Criterion 4.

Risk ID: R-002, "Semantic gap" between trait-driven intent and imperative library implementations.

Status: Mitigated.

Justification: This mission has successfully mitigated R-002 by delivering two key artifacts:

A Formal Model: The InteractionTrait specification (Section 1.3) formalizes the "trait-driven intent" (highlight, filter) into a declarative, machine-readable, and renderer-agnostic grammar.

A Mitigation Plan: The OODS-ECharts-Adapter pattern (Section 3.2) provides the concrete implementation plan for bridging the declarative model to the "imperative implementations" (ECharts) that R-002 cites.

The "semantic gap" is closed by this adapter, which programmatically translates the declarative intent (the InteractionTrait spec) into the required imperative code (dispatchAction, myChart.on, tooltip.formatter). The identified gaps in Table 3 define the precise scope of this adapter's responsibilities.

Mitigation Plan and Implementation Backlog:

**** Integrate the InteractionTrait TypeScript definition and JSON Schema (Section 1.3) into the OODS normalized visualization specification.

**** Implement the native Schema-to-Spec translation layer for Vega-Lite (Section 3.1). This will serve as the reference implementation.

**** Develop the imperative OODS-ECharts-Adapter (Section 3.2). This is the highest implementation priority for closing the gap. This task must include:

The dispatchAction mapping for Highlight, Filter, and Linked Views.

The tooltip.formatter generator.

The manual linking logic to bypass echarts.connect.

[Accessibility - P0] Implement the aria-live region controller (Section 4.3) within the base renderer adapter, as this is a critical, non-negotiable compliance requirement.

[Compliance - P1] Mandate the "Accessibility and Portability Playbook" (Section IV) and its "Equivalence Checklist" (Table 4) as part of the formal "Definition of Done" for all OODS visualization components.

Scoped Deferral:

Full predicate logic (e.g., (A and B) or C) is deferred. The current model supports single point or interval predicates.

Advanced gesture-based interactions (e.g., multi-touch, pan, zoom) are deferred and will be addressed in a future mission. The InteractionTrait model is extensible to support them by adding new select types.


researchgate.net
Bridging the Semantic Gap: Visualizing Transition Graphs with User-Defined Diagrams | Request PDF - ResearchGate
Opens in a new window

research.tue.nl
Bridging the semantic gap : visualizing transition graphs with user-defined diagrams - Research portal Eindhoven University of Technology
Opens in a new window

idl.uw.edu
Declarative Interaction Design for Data Visualization
Opens in a new window

purl.stanford.edu
The reactive vega stack : declarative interaction design for data visualization | Stanford Digital Repository
Opens in a new window

idl.cs.washington.edu
Declarative Interaction Design for Data Visualization
Opens in a new window

vis.csail.mit.edu
Declarative Interaction Design for Data Visualization - MIT Visualization Group
Opens in a new window

leapcell.io
Building Predictable and Robust UI Components with State Machines | Leapcell
Opens in a new window

carloscuesta.me
Composing UIs with Finite State Machines - Carlos Cuesta
Opens in a new window

ibm.com
What Is Event-Driven Architecture? - IBM
Opens in a new window

servicenow.com
Define map events - ServiceNow
Opens in a new window

architect.salesforce.com
Event-Driven Architecture - Architects | Salesforce
Opens in a new window

typescriptlang.org
Documentation - Type Declarations - TypeScript
Opens in a new window

medium.com
More Clean and Declarative Code with Typescript Utility Types | by livemehere - Medium
Opens in a new window

json-schema.org
A Media Type for Describing JSON Documents - JSON Schema
Opens in a new window

json-schema.org
JSON Schema
Opens in a new window

json-schema.org
Specification [#section] - JSON Schema
Opens in a new window

yellowfinbi.com
Highlighting important data in charts - Yellowfin
Opens in a new window

polymersearch.com
What is Filtering Data? - Polymer Search
Opens in a new window

tableau.com
Enhancing Visual Analysis by Linking Multiple Views of Data - Tableau
Opens in a new window

uxtweak.com
Tooltip - UXtweak
Opens in a new window

uxpin.com
What is a Tooltip? Definition, Types, and Best Practices - UXPin
Opens in a new window

learn.microsoft.com
Customizing tooltips in Power BI Desktop - Microsoft Learn
Opens in a new window

learn.microsoft.com
Change how visuals interact in a Power BI report - Microsoft Learn
Opens in a new window

techietory.com
Interactive Data Visualization: Adding Filters and Interactivity - Techietory.com
Opens in a new window

observablehq.com
Use linked brushing to explore patterns across dimensions, space, and time - Observable
Opens in a new window

infovis-wiki.net
Linking and Brushing - InfoVis:Wiki
Opens in a new window

dev3lop.com
Interactive Brushing and Linking in Multi-View Dashboards - Dev3lop
Opens in a new window

vega.github.io
Vega-Lite View Specification | Vega-Lite
Opens in a new window

vega.github.io
Selection Parameters | Vega-Lite
Opens in a new window

vega.github.io
Dynamic Behaviors with Parameters | Vega-Lite
Opens in a new window

vega.github.io
Bar Chart with Highlighting on Hover and Selection on Click | Vega ...
Opens in a new window

vega.github.io
Filter Transform - Vega-Lite
Opens in a new window

vega.github.io
Crossfilter (Filter) | Vega-Lite
Opens in a new window

vega.github.io
Tooltip | Vega-Lite
Opens in a new window

vega.github.io
Tooltip | Vega-Lite
Opens in a new window

vega.github.io
Tooltip | Vega-Lite
Opens in a new window

github.com
Tooltip Plugin for Vega-Lite - GitHub
Opens in a new window

chinavis.org
ECharts: A Declarative Framework for Rapid Construction of Web-based Visualization$
Opens in a new window

apache.github.io
Event and Action - Concepts - Handbook - Apache ECharts
Opens in a new window

stackoverflow.com
Apache Echart - Heatmap and highlight action on event : how to hightlight data for a specific value of X? - Stack Overflow
Opens in a new window

echarts.apache.org
5.3 - What's New - Basics - Handbook - Apache ECharts
Opens in a new window

echarts.apache.org
Migration from v4 to v5 - What's New - Basics - Handbook - Apache ECharts
Opens in a new window

echarts.apache.org
Features - Apache ECharts
Opens in a new window

stackoverflow.com
Apache ECharts - Brush with line chart range selection - Stack Overflow
Opens in a new window

echarts.apache.org
Basic Line Chart - Examples - Apache ECharts
Opens in a new window

github.com
[Bug] Error when using dataZoom with filterMode: 'filter' in official example · Issue #16694 · apache/echarts - GitHub
Opens in a new window

echarts.apache.org
Documentation - Apache ECharts
Opens in a new window

echarts.apache.org
Documentation - Apache ECharts
Opens in a new window

github.com
[Feature] Adding what to connect in echarts.connect · Issue #17504 - GitHub
Opens in a new window

stackoverflow.com
echarts.connect is broken when a chart with multiple series is linked with a chart with single series - Stack Overflow
Opens in a new window

stackoverflow.com
ECharts line series to custom tooltip to group some lines together and show tooltip data accordingly? - Stack Overflow
Opens in a new window

stackoverflow.com
ECharts - How to zoom in to programmatically selected data? - Stack Overflow
Opens in a new window

fossheim.io
An intro to designing accessible data visualizations by Sarah L. Fossheim
Opens in a new window

highcharts.com
10 Guidelines for DataViz Accessibility – Highcharts Blog
Opens in a new window

accessibility.blog.gov.uk
Text descriptions for data visualisations - Accessibility in government
Opens in a new window

urban.org
Do No Harm Guide: Centering Accessibility in Data ... - Urban Institute
Opens in a new window

web.accessibility.duke.edu
Data visualization | Web Accessibility - Duke University
Opens in a new window

tpgi.com
Making data visualizations accessible - TPGi — a Vispero company
Opens in a new window

a11y-collective.com
The Ultimate Checklist for Accessible Data Visualisations - The A11Y Collective
Opens in a new window

deque.com
How to make interactive charts accessible | Deque
Opens in a new window

digitalaccessibility.uchicago.edu
Data Visualization - Center for Digital Accessibility - The University of Chicago
Opens in a new window

echarts.apache.org
Aria - Best Practices - Handbook - Apache ECharts
Opens in a new window

w3.org
Understanding Guideline 2.1: Keyboard Accessible | WAI - W3C
Opens in a new window

mn.gov
Data Visualization with WCAG 2.1: Content on Hover or Focus, and Pointer Gestures - Minnesota.gov
Opens in a new window

developer.mozilla.org
ARIA: aria-label attribute - MDN Web Docs
Opens in a new window

digidop.com
ARIA Labels 2025: Complete Guide for Web Accessibility and WCAG Compliance - Digidop
Opens in a new window

w3.org
Complex Images | Web Accessibility Initiative (WAI) - W3C
Opens in a new window

vis.csail.mit.edu
Rich Screen Reader Experiences for Accessible Data Visualization
Opens in a new window

w3c.github.io
Accessible Rich Internet Applications (WAI-ARIA) 1.3 - W3C on GitHub
Opens in a new window

w3.org
WAI-ARIA Overview | Web Accessibility Initiative (WAI) - W3C
