import { promises as fs } from 'node:fs';
import path from 'node:path';

export interface DtcgToken {
  path: string[];
  type: string;
  value: string | number;
  description?: string;
  source: string;
}

interface LoadOptions {
  extensions?: string[];
}

interface CollectState {
  tokens: DtcgToken[];
  filePath: string;
}

type DtcgNode = Record<string, unknown>;

const DEFAULT_EXTENSIONS = ['.json'];
const IGNORED_DIRECTORIES = new Set(['maps']);
const MAX_DEPTH = 32;
const REFERENCE_PATTERN = /^\{([^}]+)\}$/;

export async function loadDtcgTokens(rootPath: string, options: LoadOptions = {}): Promise<DtcgToken[]> {
  const extensions = options.extensions ?? DEFAULT_EXTENSIONS;
  const stats = await fs.stat(rootPath);
  let searchRoot = rootPath;
  let files: string[] = [];

  if (stats.isDirectory()) {
    files = await collectFiles(rootPath, extensions);
  } else if (stats.isFile()) {
    if (!extensions.includes(path.extname(rootPath))) {
      throw new Error(`Unsupported token file extension for ${rootPath}`);
    }
    files = [rootPath];
    searchRoot = path.dirname(rootPath);
  } else {
    throw new Error(`DTCG root must be a directory or JSON file: ${rootPath}`);
  }

  const tokens: DtcgToken[] = [];

  for (const filePath of files) {
    const content = await fs.readFile(filePath, 'utf8');
    let parsed: unknown;

    try {
      parsed = JSON.parse(content);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(`Invalid JSON in ${relativePath(searchRoot, filePath)}: ${message}`);
    }

    if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
      throw new Error(`Expected JSON object in ${relativePath(searchRoot, filePath)}`);
    }

    const state: CollectState = {
      tokens,
      filePath,
    };

    collectTokens(parsed as DtcgNode, [], state);
  }

  if (tokens.length === 0) {
    throw new Error(`No design tokens found under ${rootPath}`);
  }

  return tokens;
}

export function compileCss(tokens: readonly DtcgToken[]): { css: string; tokensCount: number } {
  if (tokens.length === 0) {
    throw new Error('No tokens provided for CSS compilation');
  }

  const sorted = [...tokens].sort((a, b) => {
    const aKey = a.path.join('.');
    const bKey = b.path.join('.');
    return aKey.localeCompare(bKey);
  });

  const tokenMap = new Map(sorted.map((token) => [token.path.join('.'), token]));
  const lines: string[] = [];

  lines.push('/* Auto-generated by scripts/tokens/transform.ts. Do not edit manually. */');
  lines.push(':root {');

  for (const token of sorted) {
    const cssVar = buildCssVariableName(token.path);
    const cssValue = toCssValue(token, tokenMap);
    const description = token.description ? ` /* ${token.description.trim()} */` : '';
    lines.push(`  ${cssVar}: ${cssValue};${description}`);
  }

  lines.push('}');
  lines.push('');

  return { css: lines.join('\n'), tokensCount: sorted.length };
}

export function buildCssVariableName(pathSegments: readonly string[]): string {
  if (pathSegments.length === 0) {
    throw new Error('Cannot build CSS variable name for empty path');
  }

  const slug = pathSegments
    .map((segment) => segment.replace(/\s+/g, '-'))
    .join('-')
    .replace(/--+/g, '-')
    .toLowerCase();

  return `--${slug}`;
}

export function toCssValue(token: DtcgToken, tokenMap: Map<string, DtcgToken>): string {
  if (typeof token.value === 'number') {
    return token.value.toString();
  }

  if (typeof token.value !== 'string') {
    throw new Error(`Unsupported token value type for ${token.path.join('.')}: ${typeof token.value}`);
  }

  const trimmed = token.value.trim();
  const referenceMatch = REFERENCE_PATTERN.exec(trimmed);

  if (referenceMatch) {
    const referencePath = referenceMatch[1];
    const resolved = tokenMap.get(referencePath);
    if (!resolved) {
      throw new Error(
        `Unresolved token reference "${referencePath}" in ${token.path.join('.')} (source: ${token.source})`,
      );
    }
    return `var(${buildCssVariableName(referencePath.split('.'))})`;
  }

  return trimmed;
}

async function collectFiles(rootDir: string, extensions: readonly string[]): Promise<string[]> {
  const entries = await fs.readdir(rootDir, { withFileTypes: true });
  const files: string[] = [];

  for (const entry of entries) {
    const entryPath = path.join(rootDir, entry.name);

    if (entry.isDirectory()) {
      if (IGNORED_DIRECTORIES.has(entry.name)) {
        continue;
      }
      const nested = await collectFiles(entryPath, extensions);
      files.push(...nested);
    } else if (entry.isFile() && extensions.includes(path.extname(entry.name))) {
      files.push(entryPath);
    }
  }

  files.sort();
  return files;
}

function collectTokens(node: DtcgNode, trail: string[], state: CollectState, depth = 0): void {
  if (depth > MAX_DEPTH) {
    throw new Error(`Exceeded maximum token nesting depth (${MAX_DEPTH}) in ${state.filePath}`);
  }

  for (const [key, rawValue] of Object.entries(node)) {
    if (key.startsWith('$')) {
      continue;
    }

    if (rawValue && typeof rawValue === 'object' && !Array.isArray(rawValue)) {
      const nested = rawValue as Record<string, unknown>;

      if (isTokenLeaf(nested)) {
        validateToken(nested, [...trail, key], state.filePath);
        const tokenType = nested.$type as string;
        const tokenValue = nested.$value as string | number;
        const description =
          typeof nested.$description === 'string' ? nested.$description : undefined;
        state.tokens.push({
          path: [...trail, key],
          type: tokenType,
          value: tokenValue,
          description,
          source: state.filePath,
        });
      } else {
        collectTokens(nested as DtcgNode, [...trail, key], state, depth + 1);
      }
    } else {
      throw new Error(
        `Encountered unsupported token branch "${[...trail, key].join('.')}" in ${state.filePath}. ` +
          'Token groups must be objects containing nested tokens.',
      );
    }
  }
}

function validateToken(token: TokenLeaf, pathSegments: string[], filePath: string): void {
  const pathString = pathSegments.join('.');

  if (typeof token.$type !== 'string' || token.$type.trim().length === 0) {
    throw new Error(`Token "${pathString}" in ${filePath} is missing a non-empty "$type"`);
  }

  if (!('$value' in token)) {
    throw new Error(`Token "${pathString}" in ${filePath} is missing a "$value"`);
  }

  if (
    typeof token.$value !== 'string' &&
    typeof token.$value !== 'number'
  ) {
    throw new Error(
      `Token "${pathString}" in ${filePath} must provide a string or number "$value", received ${typeof token.$value}`,
    );
  }
}

interface TokenLeaf {
  $type?: unknown;
  $value?: unknown;
  $description?: unknown;
  [key: string]: unknown;
}

function isTokenLeaf(node: Record<string, unknown>): node is TokenLeaf {
  return '$value' in node || '$type' in node;
}

function relativePath(rootDir: string, filePath: string): string {
  return path.relative(rootDir, filePath) || path.basename(filePath);
}
