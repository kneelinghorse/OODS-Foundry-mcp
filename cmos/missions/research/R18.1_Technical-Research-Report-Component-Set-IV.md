Technical Research Report: Component Set IV
I. Executive Summary of Findings & Recommendations
This report presents an exhaustive analysis of six enterprise-grade user interface components—Progress/Stepper, Tabs, Pagination, Breadcrumbs, Empty States, and Toast Queues—to establish canonical patterns for Sprint 18 build work. The investigation synthesizes evidence from leading design systems, including IBM Carbon, Google Material Design, Microsoft Fluent UI, Atlassian Design System, and Salesforce Lightning, to define standards for user experience (UX) patterns, multi-brand theming architecture, and non-negotiable accessibility mandates.

Key Findings Summary
Progression Components (Progress, Stepper): A strong industry consensus exists for the state models of progression components. Progress indicators universally adopt determinate and indeterminate states to communicate quantifiable and unquantifiable wait times, respectively. Stepper components, used for multi-step workflows, employ a canonical set of step statuses: completed, current, incomplete, error, and disabled. The primary divergence among systems is not in the states themselves, but in the visual execution and the explicit support for non-linear user flows.

Navigational Components (Tabs, Pagination, Breadcrumbs): Responsive design and density management are the foremost concerns for navigational elements. To handle overflow, two primary strategies emerge: horizontal scrolling and collapsing excess items into an overflow menu. Theming for these components is highly dependent on a concise set of semantic design tokens that govern the appearance of interactive states such as selected, hover, and focus, ensuring usability across light, dark, and high-contrast modes.

Contextual Components (Empty State, Toast): The design and behavior of contextual feedback components are dictated by their status and intent. A canonical anatomy for Empty States includes an optional illustration, a headline, descriptive text, and a call-to-action. Toast notifications are defined by their intent (info, success, warning, error), which must be visually and semantically aligned with the design system's established Statusables/Usage token vocabulary to create a cohesive and predictable user feedback language.

Strategic Recommendations
Adopt a Hybrid Progression Model: The build plan should distinguish between two separate progression components. A foundational Progress component (with linear and circular variants) will serve simple loading and status indications. A more complex Stepper component will be architected for guided, multi-step user workflows. This separation prevents API bloat and aligns with the distinct use cases identified across mature design systems.

Standardize on Overflow Menus for Responsive Navigation: For components like Tabs and Breadcrumbs, collapsing excess items into an overflow menu provides a more scalable and accessible solution than horizontal scrolling, particularly within enterprise applications characterized by long labels and deep information hierarchies. This pattern offers superior discoverability and is the consensus approach for breadcrumbs.

Enforce Strict Status Token Mapping: To ensure visual and semantic consistency across the entire product ecosystem, all stateful components—especially Toasts, Empty States, and the status variants of Progress indicators—must derive their colors exclusively from the established Statusables token set (e.g., color.background.success, color.icon.danger). This is a non-negotiable requirement for maintaining cross-brand thematic integrity and accessibility.

Mandate Component-Level Accessibility Checklists: Each component build mission must incorporate a dedicated accessibility checklist as part of its definition of done. This checklist, derived from the findings in Section V, will detail the required ARIA (Accessible Rich Internet Applications) attributes, keyboard interaction models, and focus management behaviors, ensuring compliance with WCAG (Web Content Accessibility Guidelines) 2.1 AA standards from inception.

II. Analysis of Progression Components (Progress & Stepper)
This section addresses the research question: "What canonical states and transitions exist for Progress/Stepper components in multi-brand enterprise systems?" It provides a detailed analysis of components designed to guide users through a process or indicate the status of a system operation. The evidence shows a clear need to distinguish between simple progress indicators and complex, multi-step stepper components.

Progress Indicators (Bar & Circular)
Progress indicators provide real-time feedback for linear, predictable operations and are fundamental for managing user expectations during wait times.   

Canonical Variants
The analysis confirms two primary visual forms that serve different layout contexts:

Linear: A horizontal or vertical bar that fills to show progress. This is the most common variant, supported by all major systems analyzed.   

Circular: A ring or circle that animates to show progress. It is ideal for compact spaces or for indicating loading within a specific component like a button. Material Design and Fluent UI provide explicit circular variants.   

Core States: Determinate vs. Indeterminate
This is the most critical behavioral distinction for progress indicators:

Determinate: This state is used when progress is quantifiable, typically on a scale of 0 to 100. It visually represents how much of a task has been completed and is the preferred state whenever possible, as it offers a superior user experience by communicating status clearly. All leading systems provide robust support for determinate progress.   

Indeterminate: This state is used for unspecified wait times where the duration of an operation cannot be calculated. It signals to the user that a process is ongoing without providing a specific percentage. The visualization typically involves a continuous animation along the track. IBM Carbon specifies that its indeterminate bar moves repeatably from left to right, reserving back-and-forth motion for skeleton loaders. This pattern is consistent with implementations in Material Design and Atlassian's Design System.   

Status-Driven States: Success & Error
To provide comprehensive feedback, progress indicators must also reflect the final outcome of the operation they are tracking.

IBM Carbon provides explicit success (a full-width green bar with a checkmark icon) and error (a full-width red bar with a failed icon) statuses. This pattern ensures that the user receives clear, contextual validation or error feedback directly within the component.   

Microsoft Fluent UI similarly supports success, error, and warning states, which are controlled via a color prop, allowing the component's appearance to align with semantic status colors.   

Atlassian offers a distinct success appearance for its progress bar to indicate completion.   

A notable point of divergence is the Salesforce Lightning Design System (SLDS), which explicitly states that its Progress Bar component does not have a built-in error state. Instead, it recommends using other components like Inline Text or Toast notifications to communicate failures. This approach separates the progress visualization from the outcome notification, which contrasts with the more integrated feedback model of other systems.   

Theming & Customization Hooks
To support multi-brand and multi-theme requirements, the Progress component requires specific token hooks:

Size/Thickness: The ability to control the height of the progress bar is a standard feature. Carbon offers big (8px) and small (4px) sizes. SLDS provides four thickness options (x-small, small, medium, large). Fluent UI has medium and large variants. This necessitates a size or thickness property linked to a set of size tokens.   

Shape/Radius: The shape of the bar and its track is another key customization point. SLDS has a circular radius modifier , and Fluent UI offers rounded (default) and square shapes. This points to a required shape or borderRadius token hook.   

Color: Color is the primary means of conveying state and status. The component must expose token hooks for the track background color, the active indicator color, and the semantic colors for success, error, and warning states. These must be mapped directly to the system's global Statusables tokens.

Motion: Material Design 3 introduces expressive motion concepts, such as a wavy shape for the active indicator, designed to make longer processes feel less static and more engaging. This suggests the value of exposing motion tokens to control animation curves, durations, and easing for state transitions.   

Stepper / Progress Tracker
This component provides a "wizard-like workflow," guiding users through a sequence of logical and numbered steps. While terminology varies—Stepper in Material Design , Progress Indicator in Carbon and SLDS , and Progress Tracker in Atlassian —the fundamental structure and purpose are consistent across systems.   

Canonical Step States
There is a strong industry consensus on the discrete states that an individual step within a stepper can occupy:

Completed: The user has successfully finished the step. This is typically visualized with a checkmark icon, as seen in Carbon and Atlassian implementations.   

Current/Active: This is the step the user is currently interacting with. It is highlighted visually, often with a filled-in or distinctly colored icon and bolded label.   

Incomplete/Not Started/Unvisited: A future step that the user has not yet reached. It is typically styled in a muted or outlined fashion to indicate it is not yet active.   

Error/Invalid: The step contains invalid user input or has encountered a server-side error that prevents progression. This state is universally represented with an error icon and a semantic error color.   

Disabled: The step is not interactive and cannot be accessed by the user. Atlassian demonstrates a disabled state. Carbon notes that this state is intentionally inaccessible (not focusable or read by screen readers) and should be used with caution when information does not need to be conveyed to assistive technologies.   

Optional: A step that is not required for completion and can be skipped by the user. Material Design explicitly defines this state, which adds flexibility to complex workflows.   

Variants & Behavior
Orientation: Both horizontal and vertical layouts are standard and essential for adapting to different screen sizes and layout contexts. Material Design and Carbon both provide this option.   

Linear vs. Non-Linear: This is a critical behavioral distinction championed by Material Design.   

Linear: Enforces a sequential workflow, requiring the user to complete each step before proceeding to the next. This is suitable for tightly controlled processes.

Non-Linear: Allows the user to navigate to and complete steps in any order. This is a crucial feature for enterprise applications, such as complex configuration forms where a user may need to jump between sections.

Editable: Material Design also specifies an editable property, which allows users to return to previously completed steps to review or change their input. This is another vital feature for complex enterprise tasks.   

The clear distinction between a simple Progress component for system tasks and a complex, multi-state Stepper for user-driven workflows is a foundational finding. Systems like Microsoft Fluent UI appear to offer only the former, lacking a dedicated stepper component. This reinforces the need to architect these as two distinct components. A single component attempting to serve both use cases would result in an overly complex and confusing API. The build plan for Sprint 18 must therefore separate these into two discrete missions to ensure each component is purpose-built and adheres to its respective canonical patterns.   

Table 1: Progression Component State & Variant Matrix
Feature/State	Google Material Design	IBM Carbon	Atlassian Design System	Salesforce Lightning	Canonical Pattern Recommendation
Progress Variants	
Linear, Circular 

Linear 

Linear 

Linear, Vertical 

Support both linear and circular variants.
Progress States	
Determinate, Indeterminate 

Determinate, Indeterminate 

Determinate, Indeterminate 

Determinate 

Support determinate and indeterminate states.
Progress Statuses	(Implicit via color)	
Active, Success, Error 

Default, Success, Inverse 

No built-in error state 

Support active, success, error, and warning statuses via a dedicated prop.
Stepper Variants	
Horizontal, Vertical, Linear, Non-Linear 

Horizontal, Vertical 

Horizontal 

Horizontal, Vertical 

Support horizontal and vertical orientation, and linear and non-linear behavior.
Stepper Step States	
Active, Completed, Disabled, Error, Optional 

Current, Complete, Incomplete, Invalid, Disabled 

Current, Visited, Unvisited, Disabled 

Current, Completed, Incomplete, Error 

Support current, completed, incomplete, error, disabled, and optional states for each step.
  
III. Analysis of Navigational Components (Tabs, Pagination, Breadcrumbs)
This section addresses the research question: "How do Tabs, Pagination, and Breadcrumbs handle density, responsive behavior, and high-contrast theming across brands?" It examines components that facilitate user movement within a single view or across a site's information architecture, with a focus on robust and accessible implementation.

Tabs
Tabs are used to organize and switch between different sections of related content within a single view, reducing cognitive load by grouping information into distinct categories.   

Responsive & Overflow Behavior
Handling a large number of tabs or long tab labels on smaller viewports is a primary challenge. The research identifies three main strategies, with two being predominant:

Horizontal Scrolling: This is the most common and recommended pattern for enterprise systems. IBM Carbon explicitly advises that horizontal tabs should become scrollable when they exceed the available space, with scroll buttons appearing to aid navigation. Material Design's "Scrollable tabs" also implement this behavior, allowing for an unlimited number of tabs in a single row.   

Overflow Menu: An alternative approach is to collapse tabs that do not fit into a dropdown menu, often represented by an ellipsis or "More" button. Atlassian's older AUI framework supported this via a responsive attribute , and Microsoft Fluent UI recommends an overflow menu button as its primary solution. While scrolling is simpler, an overflow menu provides better discoverability for a large number of hidden tabs, which is a significant advantage in complex enterprise applications.   

Label Wrapping: A direct contradiction exists in how systems handle long labels. Material Design specifies that long labels will automatically wrap to a second line. In contrast, Microsoft Fluent UI explicitly states that tab labels will never wrap, relying instead on the overflow mechanism. For enterprise UIs where labels can be dynamic and verbose, forbidding wrapping in favor of a predictable overflow behavior (truncation with a tooltip, or an overflow menu) leads to a cleaner and more stable layout.   

Density & Sizing
To accommodate different layout contexts, from dense dashboards to spacious pages, leading systems provide size variants for tabs:

Salesforce Lightning offers Default, Medium, and Large sizes, noting that the large size is particularly well-suited for touch devices due to its increased tap target size.   

Microsoft Fluent UI provides small, medium, and large size options that affect the padding and font size of the tabs. This consensus indicates the necessity of a size property, backed by spacing and typography design tokens, to allow for flexible density control.   

Theming & High-Contrast (HC) Modes
Theming for tabs is centered on communicating their interactive states, which are universally defined as selected/active, unselected, hover, focus, and disabled.   

The active tab is consistently demarcated by a change in text color and a prominent visual indicator, most commonly an underline. The color of this indicator is a critical token hook (e.g., IBM Carbon's $border-interactive) that must be themable.   

For High-Contrast (HC) themes, components must not rely on background color changes alone, as these are often overridden by the operating system. Microsoft Fluent UI's documentation provides a crucial technical blueprint, detailing the use of the forced-colors CSS media feature. This feature allows the component to use system-defined color keywords like ButtonText, Highlight, and ButtonFace to ensure visibility. In this mode, borders, outlines, and the active tab indicator become the primary visual affordances. The implementation must ensure that focus indicators and the selected state indicator are rendered using properties like border-color or outline that respect these system colors.   

Pagination
Pagination components divide large datasets into discrete pages, providing controls for navigation. This is essential for performance and usability when dealing with extensive lists or tables.   

Anatomy & Variants
A standard pagination component includes previous/next navigation buttons, direct links to specific page numbers, and often a control for selecting the number of items per page. IBM Carbon makes a useful distinction between a full Pagination component, typically used with data tables, and a more streamlined Pagination Nav variant for general on-page content.   

Responsive & Truncation Behavior
When the total number of pages is too large to display all at once, the list of page numbers must be truncated:

The canonical pattern is to replace the middle page numbers with an ellipsis (...). Atlassian's documentation clearly illustrates this, noting that "double truncation" (ellipses near both the start and end) is used when the current page is far from both ends of the range.   

Material UI provides a highly flexible API for this, exposing siblingCount and boundaryCount props. These allow developers to programmatically define how many page numbers appear on either side of the current page and adjacent to the first and last pages, offering precise control over density and responsive behavior.   

On the smallest screens, IBM Carbon's Pagination Nav variant collapses the page numbers into an ellipsis button that opens a menu of pages, providing a mobile-friendly pattern.   

Theming & HC
Pagination styling is typically minimal, focusing on the interactive states of its buttons and links (current, default, disabled, hover).

The current page must be visually distinct from other page links, usually accomplished with a different background color, border, or font weight.   

For accessibility and HC theming, it is critical to use the aria-current="page" attribute on the link or element representing the current page. This provides a semantic hook for both assistive technologies and CSS selectors targeting HC mode, where a simple background color change would be insufficient.   

The implementation of pagination extends beyond a simple UI component. Documentation from Salesforce and community discussions around Fluent UI highlight the critical importance of the underlying logic, such as client-side versus server-side data fetching and the use of database queries with LIMIT and OFFSET. This indicates that an enterprise-grade solution must separate the presentational component from its state management logic. Material UI's usePagination() hook exemplifies this best practice by providing the core logic (calculating pages, handling truncation) in a headless, reusable function. This empowers developers to build a consistent pagination UX for a wide variety of data-fetching strategies, a necessity for a scalable design system.   

Breadcrumbs
Breadcrumbs are a secondary navigation aid that reveals the user's location within a hierarchical site structure, allowing for easy navigation to parent pages.   

Responsive & Overflow Behavior
There is a very strong industry consensus on how to handle long breadcrumb trails that exceed the available horizontal space:

The middle items of the breadcrumb trail are collapsed into an overflow menu, typically represented by an ellipsis icon.

The first item (the root or home level) and the last one or two items (the current page and its immediate parent) remain visible to preserve context. This pattern is explicitly documented and implemented by Salesforce Lightning, Atlassian, Microsoft Fluent UI, and IBM Carbon. Atlassian's component allows for customization of this behavior via a maxItems prop.   

Density & Theming
Breadcrumbs are intentionally designed to be visually unobtrusive.

Theming is minimal, typically limited to the color of the links, the separator icon (usually a chevron), and standard hover and focus states.   

The final item in the trail, representing the current page, is rendered as plain text and is not an interactive link.   

In HC modes, the component relies on the browser's default styling for links, which ensures they meet system-level contrast requirements. As with other components, a visible focus indicator is the most critical element for keyboard accessibility.

Table 2: Responsive Behavior Comparison Matrix
Component	Responsive Strategy	Atlassian Design System	IBM Carbon	Microsoft Fluent UI	Salesforce Lightning	Canonical Pattern Recommendation
Tabs	Overflow Handling	
Overflow Menu (AUI) 

Horizontal Scrolling 

Overflow Menu 

Overflow Menu 

Implement an Overflow Menu as the primary strategy for its superior discoverability in complex UIs.
Label Handling	
Wrap 

Truncate (Vertical) 

No Wrap 

No Truncate 

Forbid wrapping. Truncate long labels with a tooltip to maintain a stable, single-line layout.
Pagination	Page List Truncation	
Ellipsis (double) 

Ellipsis Menu (mobile) 

(No native component)	(Pattern-based)	Use an Ellipsis to truncate the page list, with an API similar to Material UI's siblingCount for control.
Breadcrumbs	Path Collapsing	
Overflow Menu 

Overflow Menu 

Overflow Menu 

Overflow Menu 

Implement an Overflow Menu to collapse middle items, keeping the first and last items visible.
  
IV. Analysis of Contextual & Transient Components (Empty States & Toasts)
This section addresses the research question: "What token hooks (spacing, typography, color, motion) are required to keep Empty-states and Toast queues aligned with Statusables/Usage tokens?" It focuses on components that provide contextual feedback to users, either persistently within a container or transiently as a notification.

Empty State Kits
Empty states are moments in an application where there is no data to display. Far from being a dead end, they represent a critical opportunity to guide, educate, and engage the user.   

Canonical Anatomy
Across design systems, there is a strong consensus on the compositional structure of an effective empty state:

Illustration/Image (Optional): A non-interactive visual element that provides context, reinforces the brand, and can make the interface feel more engaging. Both Salesforce and IBM Carbon emphasize the use of relevant and thoughtfully chosen illustrations.   

Headline/Title: A concise, scannable title that clearly explains the reason for the empty state. Salesforce recommends starting the headline with a verb to be more action-oriented.   

Body/Description: A short block of text that provides additional detail, explains why the area is empty, and sets expectations.   

Action(s): A primary call-to-action (CTA), typically a button or link, that provides the user with a logical next step to populate the empty state or move forward in their workflow.   

Usage Contexts
Empty states are versatile and apply to multiple scenarios beyond simply having "no data":

First-Time Use (Onboarding): When a user first encounters a feature and has not yet created any content. Atlassian makes a useful distinction, calling this a "blank slate" message, which focuses on encouraging users to try something new.   

Zero Search/Filter Results: When a user's query returns no matches.   

Task Completion: A positive empty state that appears when a user has cleared all items from a list (e.g., "Inbox Zero").   

Error or No Access: When data fails to load or the user lacks the necessary permissions to view it.   

The component itself is often a simple layout container for an image, text, and a button. The true value is derived from the content strategy applied to it. Guidance from Atlassian and Salesforce focuses heavily on the voice, tone, and clarity of the messaging. This suggests that while a reusable EmptyState component is necessary, the more critical deliverable is establishing clear usage guidelines and content templates within Storybook to ensure designers and developers can apply the pattern effectively and consistently across different scenarios.   

Token Hooks & Alignment with Statusables
To ensure visual consistency and theming capability, the EmptyState component requires the following token hooks:

Spacing: Layout tokens are needed to manage the vertical and horizontal spacing between the illustration, headline, body text, and CTA. This includes tokens for the overall padding of the container.

Typography: The headline and body text must be mapped to the system's typographic tokens, such as font.heading.medium and font.body.default.

Color: Text colors should map to standard tokens like color.text.primary for the headline and color.text.secondary for the body. The CTA will be an instance of the system's Button or Link component and will inherit its own token mappings. For empty states related to an error or success status, the headline or an accompanying icon should be able to hook into Statusables color tokens (e.g., color.text.danger).

Illustration: The illustrations are assets rather than tokens. The component should accept a reference to an illustration (e.g., a name or path), similar to how Salesforce's component accepts an illustration prop like 'road' or 'access'.   

Toast Queues / Snackbars
Toasts (also known as Snackbars in Material Design) are transient, non-modal notifications used to provide brief feedback on an operation without interrupting the user's workflow.   

Canonical Intents & Status Alignment
The most critical aspect of toasts for system consistency is their direct alignment with status. They are a primary vehicle for communicating the outcome of user actions. The canonical intents are:

Success: Indicates the successful completion of an action. Universally styled with a green background/accent and a checkmark icon. This maps directly to Statusables tokens like color.background.success and color.icon.success.   

Error: Informs the user of a failure. Universally styled with a red background/accent and an error icon. This maps to color.background.danger and color.icon.danger.   

Warning: Alerts the user to a potential issue or a non-critical problem. Universally styled with a yellow/amber background/accent and a warning icon. This maps to color.background.warning and color.icon.warning.   

Info: Provides neutral, general information. Often styled with a blue or gray background/accent and an info icon. This maps to color.background.info and color.icon.info.   

Behavior & Queuing
Placement: Toasts should appear in a consistent location on the screen to be predictable. The top-right and bottom-right corners are the most common placements. An application should use only one position to avoid disorienting users.   

Dismissal: Toasts can be dismissed in two ways: automatically after a timeout or manually via a close button. Salesforce Lightning specifies a default timeout of 4.8 seconds, which extends to 9.6 seconds if the toast contains a link, giving the user more time to interact with it. Important messages may be "sticky" and require manual dismissal.   

Queuing and Stacking: When multiple toasts are triggered in quick succession, they should not overlap. Instead, they should be placed in a queue and displayed one after another, or stacked vertically. IBM Carbon specifies that new toasts should appear at the top of the stack, pushing older ones down. Fluent UI notes that new toasts appear at the edge of the layout, pushing older ones toward the center. The system must manage this queue to ensure all notifications are displayed without overwhelming the UI.   

Token Hooks
Color: This is the most vital token category for toasts. The component's API must allow specifying an intent or status that maps to a full set of Statusables tokens for background-color, icon-color, text-color, and border-color.

Spacing: Padding tokens are required to define the internal layout of the toast content. Margin tokens are needed for the spacing between stacked toasts.

Typography: Tokens for the title and message text are necessary.

Motion: Tokens to control the entrance and exit animations (e.g., slide-in, fade-out) are essential for a polished user experience. Material Design specifies an upward animation from the bottom of the screen.   

Elevation/Shadow: A shadow or elevation token is required to ensure the toast visually appears on a layer above the main page content.

V. Universal Requirements for Accessibility and Test Automation
This section consolidates the non-negotiable accessibility heuristics and testing best practices applicable to all components in this set. It addresses the research questions: "What accessibility heuristics (focus order, ARIA attributes, keyboard support) are considered non-negotiable for these components?" and "How do leading design systems instrument VR/a11y testing coverage for these navigation components?"

Non-Negotiable Accessibility Heuristics
Adherence to these heuristics is mandatory for achieving WCAG 2.1 AA compliance and ensuring products are usable by everyone, including those who rely on assistive technologies.   

Keyboard Navigation
Tabs: The tab list must be navigable using the arrow keys (Left/Right for horizontal tabs, Up/Down for vertical). The WAI-ARIA Authoring Practices describe two models: "Automatic Activation," where focus change also activates the tab, and "Manual Activation," where Enter or Space is required to activate the focused tab. The chosen model should be consistent.   

Pagination & Breadcrumbs: All interactive elements (page links, previous/next buttons, overflow menus) must be included in the standard tab order and be activatable with Enter or Space.   

Stepper: If step headers are interactive (as in a non-linear stepper), they must be focusable and part of the tab order.

Toast: Any actionable controls within a toast (e.g., an "Undo" link or a close button) must be focusable. Microsoft Fluent UI recommends implementing a keyboard shortcut (e.g., CTRL+M) to programmatically move focus to the most recent toast, which is a best practice for accessibility.   

ARIA Attributes
Correct use of ARIA roles, states, and properties is essential for conveying the purpose and state of components to screen readers.

Progress Bar: Must use role="progressbar". For determinate progress, aria-valuenow, aria-valuemin, and aria-valuemax are required to communicate the current percentage. For indeterminate progress, these attributes should be omitted. An aria-label should describe the process (e.g., "Page refresh progress").   

Tabs: The tab container must have role="tablist". Each tab element must have role="tab" and be associated with its panel via aria-controls. Each content panel must have role="tabpanel". The currently active tab must have aria-selected="true".

Breadcrumbs: The entire component should be wrapped in a <nav> element with an aria-label="breadcrumb" to identify it as a navigation landmark. The link for the current page is not interactive and must have aria-current="page" to announce it as the current location.   

Toast/Snackbar: The toast container should have a live region role, such as role="alert" for urgent messages or role="status" for polite announcements, to ensure its content is automatically read by screen readers upon appearing.   

Focus Management
Tabs: Upon selecting a tab, focus should either remain on the tab (for manual activation) or move to the first focusable element within the associated tabpanel (for automatic activation).

Navigation: When a user navigates to a new page via a Pagination or Breadcrumb link, focus must be programmatically moved to the top of the new page content, typically the main heading (<h1>), to ensure the screen reader announces the new context.

High Contrast: All components must be tested in a high-contrast environment (e.g., Windows High Contrast Mode). Focus indicators, selection states, and borders must remain clearly visible and not rely on background-color changes that are stripped out by the OS.   

Best Practices for VR and A11y Test Instrumentation
Integrating automated testing into the development workflow is a hallmark of mature design systems, enabling teams to "shift left" and catch issues early.   

Automated Accessibility Testing
Tooling: The industry standard for automated accessibility checking is Axe-core, the engine behind tools from Deque Systems. Other valuable tools include the Stark plugin for Figma, mentioned by IBM Carbon for design-time checks , and the IBM Equal Access Toolkit.   

Integration: These tools must be integrated at multiple points in the development lifecycle. Linting rules should run in the developer's local environment. Automated checks must be a required step in the CI/CD pipeline for every pull request. Finally, accessibility checks should be integrated into the Storybook environment, allowing for component-level validation during development and review. The U.S. Web Design System's model of component-based accessibility tests is an excellent pattern to emulate.   

Visual Regression (VR) Testing
Instrumentation: Storybook serves as the ideal platform for implementing VR testing, as it isolates components and allows for the definition of all their states and variants as individual stories. Services like Chromatic or Percy integrate with Storybook to capture pixel-perfect snapshots of every story and compare them against a baseline on each code change, flagging unintended visual modifications.   

Coverage: Comprehensive VR test coverage is non-negotiable. For each component, snapshots must be captured for all props, variants, and interactive states (e.g., hover, focus, disabled). Furthermore, these snapshots must be generated for all supported themes, including light, dark, and high-contrast modes. This ensures that a change to a single design token does not introduce regressions across the component library.

Table 3: ARIA Attribute & Keyboard Navigation Checklist
Component	ARIA Role(s)	Required ARIA Attributes	Keyboard Interaction Model
Progress Bar	progressbar	aria-valuenow, aria-valuemin, aria-valuemax (for determinate); aria-label	Not interactive.
Stepper	(List of steps)	aria-current="step" on the current step's container.	Tab to navigate between interactive steps (if non-linear). Enter/Space to activate.
Tabs	tablist, tab, tabpanel	aria-selected, aria-controls, aria-labelledby	Left/Right arrow keys to move focus between tabs. Enter/Space to select (if manual activation). Tab moves focus out of the tablist.
Pagination	navigation	aria-label="Pagination", aria-current="page" on the current page link.	Tab to navigate between all interactive elements (links, buttons). Enter/Space to activate.
Breadcrumbs	navigation	aria-label="breadcrumb", aria-current="page" on the current page item.	Tab to navigate between links. Enter/Space to activate.
Toast	alert or status	aria-live="assertive" or aria-live="polite"	Tab to focus actionable elements inside. Optional shortcut to focus the toast region.
VI. Identified Contradictions, Gaps, and Recommendations
During the course of this investigation, several contradictions in patterns, gaps in component offerings, and areas of uncertainty were identified. This section documents these findings and provides actionable recommendations for resolution.

Contradiction: Tab Label Wrapping Behavior

Finding: Material Design's documentation indicates that long tab labels should wrap to a second line , whereas Microsoft Fluent UI's guidelines explicitly forbid wrapping, favoring an overflow menu instead.   

Recommendation: For enterprise UIs, where labels can be dynamic and verbose, layout stability is paramount. The system should forbid wrapping and standardize on a predictable overflow behavior. Long labels should be truncated with an ellipsis, with the full text available via a tooltip on hover. For an entire set of tabs that overflows its container, the overflow menu pattern should be used.

Contradiction: Progress Bar Error State Handling

Finding: IBM Carbon and Microsoft Fluent UI provide a built-in error state for their progress bar components, using color and an icon to provide direct, contextual feedback. In contrast, Salesforce Lightning explicitly omits this state, recommending that errors be communicated via separate components like Toasts or inline text.   

Recommendation: An integrated error state provides a more immediate and contextual user experience. The system should adopt the integrated error state pattern. The Progress component will include an error status variant that aligns visually with the Statusables error tokens (color.background.danger, etc.).

Gap: Microsoft Fluent UI Stepper Component

Finding: The investigation found no evidence of a dedicated, multi-step Stepper component within the Microsoft Fluent UI library, which contrasts with the robust offerings in Material Design, Carbon, and Salesforce. Fluent UI provides only a basic Progress component.   

Implication: This gap reinforces the recommendation to treat Progress and Stepper as distinct components with different purposes. When defining the canonical patterns for the Stepper, the implementation should draw more heavily from the detailed specifications provided by Material Design and IBM Carbon.

Gap: Atlassian Design System Empty State Component

Finding: While the Atlassian Design System provides excellent and detailed content guidelines for writing effective empty state messages , it does not appear to document a discrete, reusable EmptyState component in its component library in the same way it does for Tabs or Pagination.   

Recommendation: This finding supports the conclusion that Empty State is primarily a content and layout pattern rather than a complex, interactive component. The build plan should proceed with creating a simple EmptyState layout component (containing slots for an image, title, body, and actions) and prioritize the creation of comprehensive usage and content strategy guidelines in its Storybook documentation.

Recommendation for Follow-up Spike: Server-Side Pagination Integration

Finding: The logic for implementing efficient server-side pagination is complex, involving API design, database querying (LIMIT/OFFSET), and state management that goes beyond the scope of a simple UI component.   

Recommendation: While the Sprint 18 build will deliver the Pagination UI component and a headless usePagination hook for state management, a follow-up spike investigation should be scheduled. This spike will focus on building a fully-wired, production-grade example that connects the Pagination component to a mock API, demonstrating best practices for data fetching, caching, and handling loading/error states. This will serve as an invaluable reference implementation for product teams.

VII. Build Implications for Sprint 18
This section translates the preceding research into a set of actionable requirements for the development team. It is structured by component to facilitate the creation of build missions and user stories.

Component: Progress
Description: A component to indicate the status of a system operation.

Props:

value: number (Optional): A number from 0 to 100 to indicate determinate progress. If omitted, the component is indeterminate.

variant: 'linear' | 'circular' (Default: 'linear'): The visual style of the indicator.

status: 'active' | 'success' | 'error' | 'warning' (Default: 'active'): The semantic state of the indicator.

size: 'sm' | 'md' | 'lg' (Default: 'md'): The thickness of the indicator.

label: string: Accessible label for the progress bar, announced by screen readers.

isIndeterminate: boolean (Optional): Explicitly sets the indeterminate state. Overrides value if present.

Token Dependencies:

Color: color.background.interactive (active), color.background.success (success), color.background.danger (error), color.background.warning (warning), color.background.neutral.subtle (track).

Sizing: size.height.progress.[sm|md|lg].

Shape: shape.borderRadius.pill (for rounded ends).

Storybook Proofs:

A story for each variant (linear, circular).

A story for each status (active, success, error, warning).

A story for each size.

A story demonstrating the indeterminate state for both variants.

An interactive story that transitions from indeterminate to a determinate value.

Component: Stepper
Description: A component to guide users through a multi-step, wizard-like workflow.

Props:

steps: Array<{id: string, label: string, description?: string, status: 'incomplete' | 'current' | 'completed' | 'error', isDisabled?: boolean, isOptional?: boolean}>: An array of objects defining each step.

activeStepId: string: The id of the currently active step.

orientation: 'horizontal' | 'vertical' (Default: 'horizontal').

isLinear: boolean (Default: true): If true, users cannot navigate to future steps.

onStepClick?: (stepId: string) => void: Callback for when a step is clicked (only active for isLinear={false}).

Token Dependencies:

Color: color.icon.interactive, color.icon.disabled, color.icon.success, color.icon.danger, color.text.primary, color.text.secondary, color.text.disabled, color.border.interactive (active line), color.border.subtle (inactive line).

Typography: font.label.default, font.body.small.

Storybook Proofs:

Stories for horizontal and vertical orientations.

Stories demonstrating linear (non-clickable future steps) and non-linear (all steps clickable) behavior.

Stories showing each step status (current, completed, error, disabled, optional).

Component: Tabs
Description: A component for organizing related content into separate, switchable views.

Props:

items: Array<{id: string, label: string, panel: React.ReactNode, isDisabled?: boolean}>: An array defining each tab and its corresponding panel content.

defaultSelectedId?: string: The id of the tab to be selected on initial render.

size: 'sm' | 'md' | 'lg' (Default: 'md'): Controls the density of the tabs.

Behavior: Must handle overflow by collapsing excess tabs into a dropdown overflow menu. Long labels must truncate with a tooltip.

Token Dependencies:

Color: color.text.selected, color.text.primary, color.text.disabled, color.border.interactive (for the active indicator), color.background.hover.

Typography: font.label.[sm|md|lg].

Spacing: space.inset.squish.md (padding), space.stack.sm (gap).

Storybook Proofs:

A story demonstrating the overflow menu behavior at various container widths.

Stories for each size variant.

Stories for all interactive states: hover, focus, and disabled.

A story with a long label to demonstrate truncation and tooltip.

Component: Pagination
Description: A component for navigating through paginated content.

Props:

page: number: The current active page number (1-based index).

count: number: The total number of pages.

onChange: (page: number) => void: Callback fired when the page is changed.

siblingCount: number (Default: 1): Number of page links to show on each side of the current page.

boundaryCount: number (Default: 1): Number of page links to show at the beginning and end.

Deliverables: Must include both the presentational Pagination component and a headless usePagination hook that returns the calculated pagination items ({ type: 'page' | 'ellipsis' | 'next',... }).

Token Dependencies:

Color: color.background.selected, color.text.on-selected, color.background.hover, color.text.primary, color.text.disabled.

Shape: shape.borderRadius.medium.

Storybook Proofs:

A story with a small number of pages (no truncation).

A story with a large number of pages demonstrating single and double ellipsis truncation.

An interactive story demonstrating the onChange callback.

A story showing the disabled state of previous/next buttons at the boundaries.

Component: Breadcrumbs
Description: A secondary navigation component showing the user's location in a hierarchy.

Props:

items: Array<{label: string, href: string}>: An ordered array of breadcrumb items, from the root to the parent of the current page.

currentPageLabel: string: The label for the current page (will be rendered as non-interactive text).

Behavior: Must handle overflow by collapsing middle items into an overflow menu, always showing the first and last items.

Token Dependencies:

Color: color.text.link, color.text.link.hover, color.text.secondary (current page and separators).

Typography: font.body.default.

Spacing: space.inline.xs (gap between items).

Storybook Proofs:

A story with a short path (no collapsing).

A story with a long path demonstrating the overflow menu behavior.

An interactive story showing the hover state on links.

Component: EmptyState
Description: A layout component for when there is no data to display.

Props:

illustration: React.ReactNode: A slot for an SVG illustration.

headline: string: The main title text.

body?: string: The secondary descriptive text.

actions?: React.ReactNode: A slot for one or more action buttons or links.

Token Dependencies:

Color: color.text.primary, color.text.secondary.

Typography: font.heading.large, font.body.default.

Spacing: space.stack.lg, space.stack.md.

Storybook Proofs:

A story for a basic empty state with headline and body.

A story including an illustration.

A story including a primary action button.

Stories with content guidelines for different scenarios (e.g., "No Search Results," "First-Time Use," "Task Complete").

Component: Toast
Description: A transient, non-modal notification for providing feedback on an operation.

API: Must be an imperative API (e.g., toast.show({ intent: 'success',... })). The system must manage a queue.

Props (for toast.show method):

intent: 'info' | 'success' | 'warning' | 'error' (Default: 'info').

title: string: The main message of the toast.

isDismissible: boolean (Default: true): Whether to show a close button.

duration: number (Default: 5000): Auto-dismiss timeout in ms. Set to 0 for a sticky toast.

action?: { label: string, onClick: () => void }: An optional action link/button.

Token Dependencies:

Color: Must use the full set of Statusables tokens for each intent (e.g., color.background.success, color.icon.on-success, color.text.on-success).

Elevation: shadow.overlay.

Motion: motion.duration.moderate, motion.easing.productive.

Storybook Proofs:

An interactive story with buttons to trigger a toast for each intent.

A story to demonstrate the queuing/stacking behavior when multiple toasts are fired.

A story for a sticky toast (duration={0}).

A story demonstrating a toast with a custom action.


lightningdesignsystem.com
Progress Bar · Lightning Design System 2
Opens in a new window

m3.material.io
Progress indicators – Material Design 3
Opens in a new window

fluent2.microsoft.design
React Progress Bar - Fluent 2 Design System
Opens in a new window

design-system-site-summer-21.herokuapp.com
Progress Bar - Lightning Design System - Heroku
Opens in a new window

carbondesignsystem.com
Progress bar - Carbon Design System
Opens in a new window

developer.atlassian.com
Progress bar - Developer, Atlassian
Opens in a new window

m2.material.io
Linear progress indicator - Material Design
Opens in a new window

learn.microsoft.com
fluent-progress-ring - Microsoft Learn
Opens in a new window

v10.carbondesignsystem.com
Progress bar - Carbon Design System
Opens in a new window

svelte.carbondesignsystem.com
ProgressBar - Carbon Components Svelte
Opens in a new window

storybooks.fluentui.dev
Components / ProgressBar - Docs ⋅ Storybook - Fluent UI React v9
Opens in a new window

carbondesignsystem.com
Progress bar - Carbon Design System
Opens in a new window

design-system-react-site.herokuapp.com
Progress Bars - Salesforce Lightning Design System | React
Opens in a new window

m3.material.io
Material Design 3 - Google's latest open source design system
Opens in a new window

material.angular.dev
Stepper • Angular Material
Opens in a new window

mui.com
React Stepper component - Material UI - MUI
Opens in a new window

lightningdesignsystem.com
Progress Indicator · Lightning Design System 2
Opens in a new window

carbondesignsystem.com
Progress indicator - Carbon Design System
Opens in a new window

developer.atlassian.com
Progress tracker - Developer, Atlassian
Opens in a new window

v10.carbondesignsystem.com
Progress indicator - Carbon Design System
Opens in a new window

atlassian.design
Progress tracker - Examples - Components - Atlassian Design System
Opens in a new window

m1.material.io
Steppers - Components - Material Design
Opens in a new window

learn.microsoft.com
fluent-progress - Microsoft Learn
Opens in a new window

design-system-react-site.herokuapp.com
Progress Indicators - Salesforce Lightning Design System | React
Opens in a new window

mdui.org
Tabs - Components - Material Design 1 - mdui
Opens in a new window

carbondesignsystem.com
Tabs - Carbon Design System
Opens in a new window

aui.atlassian.com
Tabs - AUI - Documentation - Atlassian
Opens in a new window

fluent2.microsoft.design
React Tablist - Fluent 2 Design System
Opens in a new window

mui.com
React Tabs component - Material UI
Opens in a new window

lightningdesignsystem.com
Tabs · Lightning Design System 2
Opens in a new window

storybooks.fluentui.dev
Components / TabList - Docs ⋅ Storybook - Fluent UI React v9
Opens in a new window

learn.microsoft.com
Windows High contrast mode | Microsoft Learn
Opens in a new window

designsystems.surf
Pagination UI Component - Design Systems Surf
Opens in a new window

apexhours.com
Pagination in Lightning Web Components (LWC) - Apex Hours
Opens in a new window

m2.material.io
Data tables - Material Design 2
Opens in a new window

carbondesignsystem.com
Pagination usage - Carbon Design System
Opens in a new window

v10.carbondesignsystem.com
Pagination - Carbon Design System
Opens in a new window

atlassian.design
Pagination - Examples - Components - Atlassian Design System
Opens in a new window

mui.com
React Pagination component - Material UI
Opens in a new window

materialstyle.github.io
Pagination · Material Style v3.0
Opens in a new window

component.gallery
Pagination - The Component Gallery
Opens in a new window

reddit.com
Microsoft.FluentUI.AspNetCore.Components - Pagination with an API with pagination : r/Blazor - Reddit
Opens in a new window

mstsolutions.com
Pagination Using Lightning Components - MST Solutions
Opens in a new window

lightningdesignsystem.com
Breadcrumbs · Lightning Design System 2
Opens in a new window

v10.carbondesignsystem.com
Breadcrumb - Carbon Design System
Opens in a new window

designsystems.surf
Breadcrumbs UI Design Component - Design Systems Surf
Opens in a new window

fluent2.microsoft.design
React Breadcrumb - Fluent 2 Design System
Opens in a new window

atlassian.design
Breadcrumbs - Examples - Components - Atlassian Design System
Opens in a new window

mui.com
React Breadcrumbs component - Material UI
Opens in a new window

atlassian.design
Tabs - Examples - Components - Atlassian Design System
Opens in a new window

carbondesignsystem.com
Empty states - Carbon Design System
Opens in a new window

lightningdesignsystem.com
Empty State · Lightning Design System 2
Opens in a new window

medium.com
Mastering Salesforce UI - Empty State | by Mario Pavicic | Bootcamp - Medium
Opens in a new window

uiguideline.com
Empty State component - UI Guideline
Opens in a new window

atlassian.design
Overview - Empty state - Atlassian Design System
Opens in a new window

mobbin.com
Toast UI Design: Best practices, Design variants & Examples - Mobbin
Opens in a new window

mui.com
React Snackbar component - Material UI
Opens in a new window

m1.material.io
Snackbars & toasts - Components - Material Design
Opens in a new window

storybooks.fluentui.dev
Components / Toast - Docs ⋅ Storybook - Fluent UI React v9
Opens in a new window

lightningdesignsystem.com
Toast · Lightning Design System 2
Opens in a new window

carbondesignsystem.com
Notification - Carbon Design System
Opens in a new window

fluent2.microsoft.design
Toast - Fluent 2 Design System
Opens in a new window

door3.com
Enterprise Design System: All the Basics You Need to Know - DOOR3
Opens in a new window

carbondesignsystem.com
IBM accessibility standards - Carbon Design System
Opens in a new window

atlassian.design
Overview - Accessibility - Atlassian Design System
Opens in a new window

material-web.dev
Progress indicators - Material Web
Opens in a new window

v10.carbondesignsystem.com
Breadcrumb - Carbon Design System
Opens in a new window

svelte.carbondesignsystem.com
ToastNotification - Carbon Components Svelte
Opens in a new window

uxdesign.cc
Design systems and accessibility—a 2024 retrospective | by Matheus Cervo | UX Collective
Opens in a new window

designsystems.surf
Salesforce Lightning Design System (SLDS), UI Components
Opens in a new window

designsystems.surf
IBM - Carbon - Design Systems Surf
Opens in a new window

designsystems.surf
Atlassian - Jira, Confluence UI guidelines - Design Systems Surf
Opens in a new window

telerik.com
Blazor Stepper Component | Telerik UI for Blazor
Opens in a new window

storybooks.fluentui.dev
Storybook - Fluent UI React v9
Opens in a new window

developer.microsoft.com
Fluent UI - Get started - Microsoft Developer