Figma-to-Repository Handshake Recipe: A Zero-Drift Workflow for Design Token Management
I. Executive Summary & Workflow Principles
This document specifies the authoritative workflow for integrating Figma into a design system ecosystem where a Git repository, adhering to the Design Token Community Group (DTCG) specification, serves as the single source of truth (SoT). The primary objective is to establish a high-fidelity, zero-drift operational model that leverages Figma exclusively for design exploration and the formal proposal of token changes, while preserving the integrity and authority of the Git repository.

Core Principles
This recipe is founded on a set of non-negotiable principles that ensure system stability, scalability, and clear governance between design and engineering disciplines. Adherence to these principles is mandatory for the success of the workflow.

Git is the Immutable SoT: All design token definitions, including their names, values, and structural organization (namespaces), originate and are finalized within the designated Git repository. Figma's role is strictly that of a consumer and a proposal-generation tool; it is never the source of record for design tokens.   

Read-Only by Default: To prevent unintentional divergence and configuration drift, the primary data flow from the repository's main branch into Figma is configured as strictly read-only. This is enforced through technical controls, specifically the use of read-only Git credentials for day-to-day design work.   

Proposals via Branches: All proposed modifications to the token system, whether additions, deletions, or value changes, must be conducted in isolated Git branches. These branches are initiated from within the Figma environment but materialize as formal Pull Requests (PRs) in the Git repository, subjecting design changes to the same rigor as code contributions.   

Figma as a High-Context Specification: The culmination of design exploration within Figma is not merely a set of new token values. It is a comprehensive, high-context artifact referred to as an "annotated diff." This visual specification must include before-and-after comparisons of affected components, explicit justifications for each change, and empirical evidence of validation, such as accessibility compliance proofs.

Required Tooling
The successful implementation of this workflow is contingent upon the use of Tokens Studio for Figma with a Pro License. The free version of the plugin lacks features that are critical to this recipe. The Pro license is mandated for its support of:

Multi-file Sync: Essential for managing complex token systems with themes, as it allows each token set to be stored in a separate JSON file, mirroring the structure consumed by downstream build tools.   

Git Branch Switching: The ability to create and switch between Git branches directly within the Figma plugin is the cornerstone of the proposal workflow, enabling designers to safely explore changes without impacting the main branch.   

Adopting this workflow represents a significant procedural and cultural shift. It formalizes the designer's role in the evolution of the design system, transitioning them from a direct author to a "proposer." This model enforces a structured review, validation, and approval process analogous to a standard engineering Git workflow. Consequently, design decisions must be as defensible, well-documented, and rigorously tested as code changes, elevating the overall quality and stability of the design system.

II. Phase 1: Establishing the Read-Only Bridge (Repo → Figma)
This initial phase details the foundational setup required to connect Figma to the Git repository in a secure, read-only manner. This ensures that designers are always working with the most current, authoritative set of design tokens from the main branch.

2.1. Prerequisite: Git Repository Structure
The target Git repository must be correctly structured before any connection is attempted. The Tokens Studio plugin has specific requirements for initialization and organization.

Initialized Repository: The plugin cannot sync to a completely empty repository. The repository must be initialized with at least one file, typically a README.md.   

Dedicated Token Directory: To leverage the mandatory multi-file sync feature, all token *.json files must be located within a dedicated directory in the repository (e.g., /tokens or /src/tokens). This organizational structure is a critical architectural decision. It keeps token sets logically separated (e.g., global.json, light-theme.json, dark-theme.json), which is essential for build tools like Style Dictionary to correctly parse and apply themes during the transformation process. A single-file approach conflates all token sets, rendering them incompatible with scalable theming logic and creating significant technical debt.   

2.2. Creating a Read-Only GitHub Personal Access Token (PAT)
To enforce the "Read-Only by Default" principle, a specific type of Personal Access Token (PAT) must be generated for designers' daily use. This token grants permission to pull tokens from the repository but explicitly denies permission to push changes directly to the main branch.

Step-by-Step Guide:

Navigate to GitHub Settings > Developer settings > Personal access tokens > Fine-grained tokens.

Click "Generate new token".

Token name: Provide a descriptive name, such as Figma Tokens Studio Read-Only.

Expiration: Set an appropriate expiration policy as required by organizational security standards.

Repository access: Select "Only select repositories" and choose the specific design tokens repository.

Permissions: Under "Repository permissions," locate the Contents permission and set it to Read-only. This is the most critical step. It allows the plugin to fetch token data but will cause any push attempt to the protected branch to fail.   

Click "Generate token" and securely store the generated token string. It will not be shown again.

2.3. Configuring the Tokens Studio Sync Provider
With the read-only PAT, the connection can now be configured within the Tokens Studio plugin in Figma.

Step-by-Step Guide:

In Figma, open the Tokens Studio plugin.

Navigate to the Settings tab (gear icon).

Under the "Sync providers" section, click "Add new" and select GitHub.   

Complete the configuration form with the following details:

Name: A descriptive identifier for this connection, e.g., Design System SoT (main).

Personal access token: Paste the read-only PAT generated in the previous step.

Repository: Enter the full repository path in the format owner/repository-name (e.g., acme-corp/design-tokens).

Branch: Specify the primary production branch, typically main.

File Path: Enter the name of the directory where tokens are stored (e.g., tokens). Do not specify a .json file extension. This action configures the plugin for multi-file sync.   

Click "Save".

2.4. Performing the Initial Pull
Upon saving the new sync provider configuration, Tokens Studio will detect that the local Figma file's token state is different from the remote repository. It will present a modal with options to Push or Pull.

The correct action is to select "Pull from GitHub". This will fetch all *.json files from the specified directory and branch in the repository and load them into the plugin. This action is destructive to any pre-existing tokens in the Figma file, effectively overwriting them with the authoritative set from the SoT. This initial pull completes the establishment of the read-only bridge, ensuring the Figma environment is a precise mirror of the design system's source of truth.   

III. Phase 2: Translating Code to Canvas (Mapping Tokens to Styles)
Once the tokens are ingested from the repository, the next phase is to translate them into native Figma constructs that designers can use intuitively. This process focuses on using Tokens Studio as a management layer for Figma Styles, rather than as a direct application tool.

3.1. The Mapping Strategy: Tokens as the Engine for Figma Styles
The core strategy is to leverage native Figma Styles (Color, Text, and Effect Styles) for all design work. This provides designers with a familiar workflow using Figma's native Style Picker. Tokens Studio's role is to programmatically create and manage the values of these styles, ensuring they remain perfectly synchronized with the Git SoT. Applying tokens directly to layers via the plugin is discouraged for this workflow, as it can lead to less manageable designs and fragile connections, especially when working with remote libraries.   

3.2. Naming Convention: Mirroring the Namespace
A strict, unambiguous naming convention is the bedrock of a maintainable token-to-style mapping. The convention must ensure that the name of a Figma Style is directly and predictably derived from the token's namespace. This creates a "human-readable API" within Figma's UI.

Conversion Rule: The dot (.) character used to denote hierarchy in token names must be converted to a forward slash (/) in Figma Style names.

Effect: This convention leverages Figma's native UI, which automatically groups styles based on the / delimiter, creating a folder-like structure in the Style Picker that mirrors the token's hierarchical organization.   

Examples:

Token: color.background.surface.base → Figma Style: Color/Background/Surface/Base

Token: font.body.regular → Figma Style: Font/Body/Regular

Token: effect.shadow.xl → Figma Style: Effect/Shadow/XL

3.3. Generating Styles with Tokens Studio
Tokens Studio provides a dedicated feature to automate the creation and updating of Figma Styles based on the ingested tokens.

Step-by-Step Guide:

In the Tokens Studio plugin, navigate to the main Tokens tab.

Click the "Styles & Variables" button in the header.

From the dropdown menu, select "Export styles & variables".   

In the configuration modal, apply the following settings:

Export as: Check Styles. (While Variables can also be exported, Styles offer more robust support for composite types like shadows and are more universally adopted in existing design workflows).

Style specific settings: Enable Create styles with variable references. This provides a more flexible and modern foundation, linking styles to underlying Figma variables where possible.

Update specific settings: Enable Remove styles and variables no longer connected to a token. This is a crucial housekeeping feature that automatically purges deprecated styles from the Figma file whenever tokens are removed from the SoT, preventing style library bloat and confusion.

Click "Export". The plugin will now iterate through the loaded token sets and generate corresponding Color, Text, and Effect styles in the local Figma file, adhering to the specified naming convention.

Table: Token-to-Style Mapping Convention
The following table, which forms the basis for the appendix deliverable /missions/research/appendix/r5.3_mapping-table-figma-styles.csv, provides a definitive reference for the translation of token namespaces into Figma Style names.

Token Namespace (DTCG)	Token Type	Figma Style Name	Figma Style Type	Example Resolved Value
color.text.primary	color	Color/Text/Primary	Color	#1A1A1A
color.interactive.primary.default	color	Color/Interactive/Primary/Default	Color	#0052CC
font.body.regular	typography	Font/Body/Regular	Text	font-family: Inter, font-weight: 400, font-size: 16px,...
font.heading.h1	typography	Font/Heading/H1	Text	font-family: Inter, font-weight: 700, font-size: 32px,...
effect.shadow.medium	boxShadow	Effect/Shadow/Medium	Effect	type: dropShadow, x: 0, y: 4, blur: 8, spread: 0, color: #0000001A
grid.layout.desktop	composition	Grid/Layout/Desktop	Layout Grid	columns: 12, margin: 64, gutter: 24
dimension.radius.large	borderRadius	Dimension/Radius/Large	(Not a Style)	12px
dimension.spacing.xl	spacing	Dimension/Spacing/XL	(Not a Style)	32px

Export to Sheets
IV. Deconstructing Composite Tokens: Typography, Shadows, and Borders
Composite tokens are a powerful feature for bundling multiple related style properties into a single, semantic token. However, their structure in JSON is specific and must be correctly authored in the SoT to be properly interpreted by Tokens Studio and mapped to a single Figma Style.

4.1. The Composite Token Model in Tokens Studio
A fundamental concept to grasp is that composite tokens (typography, boxShadow, border) are not monolithic objects containing raw values. Instead, they function as aggregators. A single composite token's value is an object composed of references (aliases) to more granular "particle" tokens that define its individual properties.   

For example, a font.heading.h1 typography token does not directly contain values like 700 or 32px. Its value is a structured object of aliases:
{ "fontFamily": "{font.family.sans}", "fontWeight": "{font.weight.bold}", "fontSize": "{font.size.xxl}", "lineHeight": "{font.lineheight.tight}" }

This "particle and composite" model enforces an atomic, bottom-up architecture for the design system. It is not possible to create a one-off, inconsistent composite style; its constituent parts must first be defined as independent, reusable tokens. This architectural constraint, imposed by the tooling, is a powerful mechanism for ensuring system-wide consistency.

4.2. Typography Tokens (typography)
JSON Structure: A token with $type: "typography" has a $value that is an object. The keys of this object correspond to typographic properties (fontFamily, fontWeight, fontSize, lineHeight, letterSpacing, paragraphSpacing, textCase, textDecoration), and their values are typically references to particle tokens.   

Particle Tokens: This structure necessitates the pre-existence of granular tokens for each property. A key nuance in Tokens Studio's syntax is that the $type of a standalone particle token is plural (e.g., fontFamilies, fontWeights), while the key used to reference it inside the composite is singular (e.g., fontFamily, fontWeight).   

Figma Mapping: During the "Export styles & variables" process, Tokens Studio intelligently resolves these references and bundles the properties into a single, native Figma Text Style.   

4.3. Shadow Tokens (boxShadow)
JSON Structure: A token with $type: "boxShadow" has a $value that can be a single object for one shadow layer, or an array of objects for multiple shadow layers applied as a single effect. Each object contains keys for x, y, blur, spread, and color. The values for these keys can be raw dimension or color values, but are more robust when they reference other dimension and color tokens.   

Figma Mapping: Tokens Studio maps a boxShadow token to a single Figma Effect Style. The plugin correctly interprets both single-object and array-of-object values to create the corresponding shadow effects in Figma's UI.   

4.4. Border Tokens (border)
JSON Structure: A token with $type: "border" has a $value object containing keys for color, width, and style (e.g., "solid").   

Figma Mapping Limitation: This is a notable area where a direct one-to-one mapping is challenging. Figma does not have a concept of a reusable "Border Style" in the same way it has Color or Effect Styles. While the border token is a valid construct for code, in Figma it is typically deconstructed. Designers apply a stroke to a layer and then apply a token-driven Color Style to the stroke color and use a token-driven dimension value for the stroke width. The token exists to inform these choices, but it does not manifest as a single, applicable style in the Figma UI. This limitation must be clearly communicated to the design team.

Table: Composite Token JSON Structure & Mapping
This table provides a technical reference for authoring composite tokens in the JSON SoT. It illustrates the expected structure and the relationship between composite and particle tokens.

Composite Type	JSON Key	Property	Expected Particle Token Type	Example JSON Structure (W3C DTCG Format)
Typography	font.heading.h1	fontFamily	fontFamily	{"font.heading.h1": {"$type": "typography", "$value": {"fontFamily": "{font.family.sans}", "fontWeight": "{font.weight.bold}", "fontSize": "{font.size.xxl}"}}}
fontWeight	fontWeight	
fontSize	fontSize	
lineHeight	lineHeight	
Box Shadow	effect.shadow.xl	x	dimension	{"effect.shadow.xl": {"$type": "boxShadow", "$value": {"x": "{dimension.spacing.0}", "y": "{dimension.spacing.m}", "blur": "{dimension.spacing.xl}", "spread": "{dimension.spacing.0}", "color": "{color.shadow.default}"}}}
y	dimension	
blur	dimension	
spread	dimension	
color	color	
Border	border.interactive	color	color	{"border.interactive": {"$type": "border", "$value": {"color": "{color.border.interactive}", "width": "{dimension.border.1}", "style": "solid"}}}
width	borderWidth	
style	(string literal)	

Export to Sheets
V. Phase 3: Building Verifiable Specimen Sheets
Specimen sheets are dedicated pages or frames within Figma that serve as the primary canvas for validating token application and communicating proposed changes. They are not merely documentation but are functional, "living" artifacts integrated into the workflow.

5.1. Purpose of Specimen Sheets
Visual Regression & Validation: They provide a controlled environment to visually inspect the impact of token changes across a core set of UI components, ensuring that modifications have the intended effect without introducing unintended side effects.

Theme Previews: They are essential for demonstrating how tokens render across different contexts or themes (e.g., light vs. dark mode, compact vs. comfortable density, different brand regions), facilitating rapid stakeholder review and approval.

5.2. Automated Generation with Tokens Studio (Pro Feature)
Manually creating and maintaining comprehensive documentation is a significant source of overhead and is prone to becoming outdated. Tokens Studio's Generate documentation feature offers a powerful method for semi-automating this process.   

Template-Based Generation: The feature operates on a template model. A designer can create a master component for a token specimen (e.g., a color swatch component). Within this component, specific layer names act as hooks for the plugin :   

A text layer named __tokenName will be populated with the token's name.

A text layer named __tokenValue will be populated with the token's resolved value.   

A shape layer whose fill property should be set can be named __fill.

Execution: By selecting this template component and running Tools > Generate documentation, the plugin will duplicate the template for every token that matches a specified prefix (e.g., color.background.), automatically populating the hooked layers. This transforms a tedious manual task into a repeatable, scriptable action.

5.3. Structuring for Region/Context Models
To effectively validate themes, the specimen sheets must be organized logically.

Create a new page in the Figma file named "Theme Validation" or "Token Specimens."

On this page, create top-level frames for each theme or context that needs to be validated (e.g., a frame for "Light Theme" and another for "Dark Theme").

Within each theme frame, construct a small, representative set of core UI components (such as Buttons, Inputs, Cards, Avatars) built exclusively using the token-driven Figma Styles generated in Phase 2. This curated set of components serves as the "test suite" for the theme.

5.4. Theme Switching for Validation
The combination of token themes in the plugin and the structured specimen sheet enables an extremely fast validation loop.

Open the Tokens Studio plugin and navigate to the Themes tab.

Select the desired theme to preview (e.g., switch from the "Light" to the "Dark" theme).

Navigate back to the Tokens tab and re-run the Export styles & variables process from Phase 2.

This action updates all native Figma Styles in the document to reflect the values of the newly active theme.

The components on the specimen sheet, which are built from these styles, will update instantly and automatically. This provides an immediate, high-fidelity preview of the entire theme applied across the test suite, allowing designers and stakeholders to approve a full theme's implementation in minutes, not hours.

VI. Phase 4: The Proposal Workflow (Figma → Repo PR)
This phase outlines the precise, step-by-step process for a designer to propose changes to the design token SoT. This workflow is designed to be safe, auditable, and rich in context, ensuring that all changes are deliberate and well-understood by all stakeholders.

6.1. Step 1: Create a New Branch
All exploratory work and proposed changes must be isolated from the main branch. This is the fundamental principle of safe contribution, mirroring standard Git-based development workflows.

Within the Tokens Studio plugin, navigate to the Settings tab and locate the active sync provider.

Click on the branch dropdown menu (which should currently show main).

From this menu, a new branch can be created directly within the plugin's UI.   

Provide a descriptive branch name that follows established conventions (e.g., feat/update-interactive-colors, fix/incorrect-red-500-value). The plugin will switch to this new branch, creating a safe sandbox for modifications.

6.2. Step 2: Explore and Modify Tokens
With the new branch active, the designer can now safely edit token values, create new tokens, or remove obsolete ones using the Tokens Studio UI. As changes are made, they should be immediately applied to a duplicated "After" version of the relevant specimen sheet components to visualize their impact in real-time.

6.3. Step 3: Construct the Annotated Diff
A raw JSON diff in a PR lacks the visual and logical context necessary for effective design review. The "annotated diff" is a curated artifact created in Figma that serves as the comprehensive specification for the proposed change.

On the specimen page, create two frames side-by-side:

"Before": A frame containing the UI components rendered with the original tokens from the main branch.

"After": A frame containing the same components rendered with the new, modified tokens from the feature branch.

Annotation: Use Figma's native text, shape, and arrow tools to meticulously call out every specific change in the "After" frame. Each annotation must be accompanied by a clear, concise note explaining the rationale for the change (e.g., "Increased text-to-background contrast from 3.5:1 to 4.6:1 to meet WCAG AA standards," or "Updated primary action color to align with Q3 brand refresh").

6.4. Step 4: Provide Proof of Validation
Assertions made in the rationale must be backed by evidence. This proof is embedded directly into the Figma canvas alongside the annotated diff, creating a self-contained validation package.

Contrast Proof: For any change to a color token that affects text or essential UI elements, use an accessibility plugin like Stark  or Figma's native color contrast checker  to verify compliance with target standards (e.g., WCAG AA). A screenshot of the passing result from the tool must be captured and placed on the canvas next to the relevant component in the "After" frame.   

Visual Regression Proof: The "Before" and "After" frames themselves constitute the visual regression proof. While tools like Pixelay exist for comparing Figma designs to live websites post-development, they are not suited for this pre-development proposal stage. The visual diff is a manually, but carefully, curated artifact.   

6.5. Step 5: Push Changes and Initiate PR
Once the token modifications are finalized and the annotated diff is complete, the changes can be pushed to the remote repository to initiate a formal review.

In Tokens Studio, click the "Push to GitHub" button.   

A modal will appear prompting for a commit message. Write a clear, imperative message that summarizes the change (e.g., "Feat: Adjust interactive blue for accessibility"). This action pushes the modified *.json token files to the remote feature branch.

Navigate to the Git repository in the browser and open a new Pull Request, targeting the main branch from the feature branch.

The PR description is the critical link that ties the code change to the design context. It must contain a direct, shareable link to the specific Figma frame that houses the annotated diff. This allows reviewers—whether they are engineers, product managers, or other designers—to instantly access the full visual context, rationale, and validation proof for the proposed token changes, dramatically reducing ambiguity and accelerating the approval process.

VII. Mitigating Divergence: The Zero-Drift Checklist & Governance
Even with a robust workflow, the potential for drift between the Figma environment and the Git SoT exists. This section identifies common sources of divergence and provides a procedural checklist and governance model to mitigate them.

7.1. Understanding the Sources of Drift
Fragile Connections: The link between a token and its corresponding Figma Style is not always persistent. If a style is deleted from a library or detached by a user, Tokens Studio may not be able to automatically re-establish the connection, leading to that element no longer receiving updates.   

Manual Style Overrides: A designer manually changing a color hex or font weight on a styled element breaks the link to the token-managed style. This is a primary source of inconsistency.

Forbidden Naming Conventions: The use of reserved characters in token names—specifically /, $, {}, ``, and ()—can cause silent failures during the sync or style export process. The / is particularly problematic as it is used by Figma for style grouping and will conflict with the plugin's dot-to-slash conversion.   

Procedural Errors: The most common source of drift is human error, such as a designer forgetting to Pull the latest changes from main before starting work, or failing to Push their changes to a feature branch before creating a PR.

7.2. The Round-Trip Checklist
To enforce procedural correctness, designers must follow this checklist for every token-related task. This checklist forms the basis of the appendix deliverable /missions/research/appendix/r5.3_checklist-roundtrip.md.

Before Starting Work:
[ ] Open the Tokens Studio plugin and verify the active sync provider is connected to the main branch.

[ ] Execute a "Pull from GitHub" to ensure the local environment is fully synchronized with the latest version of the SoT.

[ ] Create a new, descriptively named branch for the task directly within the plugin.

During Exploration & Proposal:
[ ] Confirm that all token modifications are being made on the newly created feature branch, not main.

[ ] Adhere strictly to the established naming conventions and avoid all forbidden characters in new token names.   

[ ] Prioritize updating existing tokens over creating new ones to prevent token bloat. A new token should only be created when a new semantic concept is being introduced.

[ ] Document every proposed change on the specimen sheet with a clear "Before/After" visual, written rationale, and validation proof.

After Proposing Changes:
[ ] Execute a "Push to GitHub" to commit the modified token files to the remote feature branch.

[ ] Open a Pull Request in GitHub, targeting the main branch.

[ ] Paste the Figma link to the annotated diff frame into the PR description.

[ ] Once the PR is reviewed, approved, and merged by the code owners, switch back to the main branch in Tokens Studio and execute a final "Pull from GitHub" to sync the local environment with the newly updated SoT.

7.3. Sync Cadence and Governance
Sync Cadence: The workflow is event-driven, not time-based. The cadence is defined by the checklist: Always pull before starting work, and always push to a feature branch to propose a change.

Scheduled Audits: To catch latent drift, a quarterly audit should be instituted. A designated Design Technologist or System Maintainer will be responsible for reviewing the primary Figma design system library to identify detached styles, manual overrides, or other inconsistencies that have deviated from the token SoT.

Table: Known Limitations & Recommended Workarounds
This workflow, while robust, is subject to certain limitations of the tooling. Proactively understanding and planning for these limitations is key to long-term success.

Limitation	Description	Impact	Recommended Workaround / Mitigation
Fragile Style Connections 

The connection between a token and a Figma Style can break if the style is deleted or if components are moved between libraries. The plugin cannot always automatically repair this link.	Medium: Can lead to components or styles not receiving updates from the SoT, causing silent visual drift.	Periodically (e.g., after every major token update) re-run the Export styles & variables command with the "Remove styles... no longer connected" option enabled. This cleans up broken links and reinforces existing ones. For critical, widely-used library components, consider a hybrid approach where core styles are managed by tokens, but application is verified manually during audits.
Variable Import Nuances 

When importing variables from Figma into Tokens Studio, the process has limitations. It does not support Figma's "scoping" (hide from publishing), and all number variables are converted with the same unit settings (e.g., all to px or all to rem), which can be problematic for mixed-unit systems.	Low: Can create organizational noise in the token sets and require manual correction.	After importing variables, manually organize the resulting tokens into appropriate sets (e.g., primitive, semantic) within the plugin. For mixed units, perform the import in batches: import rem-based variables first, delete them from the import confirmation list, then change settings and import px-based variables.
Forbidden Characters in Names 

Using characters like /, $, or {} in token names can cause the sync or style export process to fail without a clear error message, or create unintended style groupings in Figma.	High: Can break the sync process entirely or lead to a disorganized and unusable style library.	Enforce a strict linting rule on the token repository to reject any PRs containing forbidden characters in token names. Educate all contributors on the naming conventions via the provided mapping table and checklist.
Remote Style Application 

When a token-managed style is part of a remote (published) Figma library, the plugin may have difficulty updating it in consuming files. In some cases, it may apply a raw hex value instead of the library style.	Medium: Can break the "single source of truth" principle for styles within Figma, leading to detached instances.	The primary mitigation is to always accept library updates in consuming files promptly after the token SoT has been updated. The "tokens as a style manager" approach is more robust than applying tokens directly, but this limitation persists. Regular library audits can help identify detached instances.
  

Sources used in the report

smallstep.com
How We Cut UI Development Time in Half with Figma and Token Studio - Smallstep
Opens in a new window

help.figma.com
Update 1: Tokens, variables, and styles – Figma Learn - Help Center
Opens in a new window

matthewrea.com
Design token automation from Figma to Storybook | Blog
Opens in a new window

docs.tokens.studio
GitHub - Git Sync Provider | Tokens Studio for Figma
Opens in a new window

emulsify.info
Connecting Figma to a Github repository • Emulsify Docs
Opens in a new window

tokens.studio
Stop Fixing Outdated Docs. Plus Keeps Them in Sync. | Tokens Studio
Opens in a new window

docs.tokens.studio
Remote Token Storage Integrations | Tokens Studio for Figma
Opens in a new window

docs.tokens.studio
Bitbucket - Git Sync Provider | Tokens Studio for Figma
Opens in a new window

github.com
Official repository of the plugin 'Tokens Studio for Figma' (Figma Tokens) - GitHub
Opens in a new window

github.com
futurice/figma-tokens: Official Repo of the Figma Plugin 'Figma Tokens' - GitHub
Opens in a new window

docs.tokens.studio
Token Name Technical Specs | Tokens Studio for Figma
Opens in a new window

docs.tokens.studio
Export to Figma Guide | Tokens Studio for Figma
Opens in a new window

docs.tokens.studio
Token Types - Tokens Studio for Figma
Opens in a new window

docs.tokens.studio
Token Values with References | Tokens Studio for Figma
Opens in a new window

docs.tokens.studio
Typography - Composite - Tokens Studio for Figma
Opens in a new window

docs.tokens.studio
Font Family | Tokens Studio for Figma
Opens in a new window

studiobuizert.com
Building a Basic Typography Token Set: A Must-Have for Every Design System
Opens in a new window

docs.tokens.studio
Import Styles from Figma | Tokens Studio for Figma
Opens in a new window

docs.tokens.studio
Box Shadow - Composite - Tokens Studio for Figma
Opens in a new window

intodesignsystems.medium.com
Design Tokens Workflow in Figma — A practical guide | by Into Design Systems - Medium
Opens in a new window

docs.tokens.studio
Generate documentation - Tokens Studio for Figma
Opens in a new window

docs.tokens.studio
Documentation Tokens - Tokens Studio for Figma
Opens in a new window

getstark.co
Stark for Figma
Opens in a new window

youtube.com
Checking color contrast for accessibility in Figma - YouTube
Opens in a new window

chromewebstore.google.com
Pixelay for Figma - Chrome Web Store - Google
Opens in a new window

hypermatic.com
Stop QA surprises. Compare your Figma designs with real websites, pixel-perfectly. | Pixelay for Figma - Hypermatic
Opens in a new window

reddit.com
Automating design tokens from Figma to company's private Gitlab - Reddit
Opens in a new window

feedback.tokens.studio
Tokens applied as variables or styles are Fragile
Opens in a new window

docs.tokens.studio
Import Variables from Figma | Tokens Studio for Figma