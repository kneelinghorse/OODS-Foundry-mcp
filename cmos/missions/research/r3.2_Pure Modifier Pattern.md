Architectural Specification for the Pure Modifier Pattern in the OODS View Engine
The Imperative for Deterministic Composition
Introduction: The Challenge of Scalability in Modern UI Engineering
The development of large-scale, interactive user interfaces presents a significant engineering challenge. As applications grow in complexity, managing state, handling asynchronous events, and preventing unintended side effects become increasingly difficult. When application state is maintained in disparate locations, including both the Document Object Model (DOM) and JavaScript memory, the cognitive overhead for developers escalates, leading to a system that is difficult to reason about, test, and refactor. This complexity often manifests as unpredictable behavior, non-deterministic rendering, and a high long-term maintenance burden.   

The OODS (Object-Oriented Design System) View Engine is architected to address these challenges directly. Its core mission is to provide a robust, scalable, and predictable framework for UI development. A central tenet of this mission is the establishment of clear, enforceable contracts that govern how components are composed and modified. This document introduces and specifies the "Pure Modifier Pattern," a foundational architectural standard designed to ensure that component composition within the OODS View Engine is deterministic, side-effect-free, and fundamentally reliable. By mandating that modifiers operate as pure functions, the system guarantees that the process of transforming a component's properties is as predictable and verifiable as a mathematical formula. This specification will define the pattern, ground it in an analysis of industry best practices, and provide a concrete blueprint for its implementation, governance, and testing.

Foundational Principles: Purity and Referential Transparency in the Context of React
To understand the Pure Modifier Pattern, it is essential to first establish a rigorous definition of the functional programming principles upon which it is built. These concepts, particularly function purity and referential transparency, are not merely academic; they form the philosophical bedrock of modern React development and are critical for building predictable systems.

Defining Purity
A function is considered pure if it adheres to two strict conditions:

Determinism: Given the same set of inputs, the function must always return the same output. Its result is determined exclusively by its input values and its internal algorithm.   

No Side Effects: The function must not produce any observable effects beyond computing its return value. It cannot mutate its input arguments, modify any external state (such as global variables or objects that existed before the function was called), perform I/O operations (like network requests or logging to the console), or interact with the DOM.   

Consider the following simple JavaScript functions:

JavaScript

// Pure function: Deterministic and no side effects
function sum(a, b) {
  return a + b;
}

// Impure function: Relies on and mutates external state
let total = 0;
function addToTotal(value) {
  total += value; // Side effect: mutates external variable 'total'
  return total;
}
The sum function is pure. A call to sum(2, 3) will always return 5, regardless of when or how many times it is called. The addToTotal function is impure; its output depends on the history of previous calls, and it modifies state outside of its own scope.

React's Philosophy on Purity
The React library is built on the fundamental assumption that every component behaves as a pure function during its render phase. This means that a React component, when rendering, must only perform a calculation to transform its inputs—props, state, and context—into a JSX description of the UI. It must not change any objects or variables that existed before the render began.   

This principle is the key to unlocking many of React's powerful features, including performance optimizations (skipping re-renders for unchanged inputs), server-side rendering, and the capabilities of Concurrent Mode, which can safely interrupt and resume rendering because it knows the process is a pure calculation without side effects.   

It is crucial to distinguish between the render phase and other parts of a component's lifecycle. React acknowledges that side effects are necessary for any useful application—data must be fetched, the DOM must be updated, and animations must run. However, React's architecture strictly mandates that these side effects must be managed outside of the render path, typically within event handlers (which run in response to user interaction) or useEffect hooks (which run after the render has been committed to the DOM). The Pure Modifier Pattern in OODS adopts this same strict separation: modifiers are part of the pure "render" calculation, while all side effects must be encapsulated in other constructs.   

Referential Transparency
A direct and powerful consequence of function purity is referential transparency. An expression is referentially transparent if it can be replaced with its corresponding value without changing the program's overall behavior. For example, because the expression sum(2, 3) is pure and always evaluates to 5, every instance of sum(2, 3) in a program could be replaced with the literal value 5 without any functional consequence.   

This property is what makes pure functions so easy to reason about, test, and debug. One can analyze a function call in complete isolation, confident that its behavior is not influenced by hidden state or external factors. Referential transparency also enables critical compiler and runtime optimizations, such as memoization (caching the results of expensive function calls) and parallelization, because the order of execution for pure, independent functions does not matter. The OODS View Engine is designed to leverage this property, allowing for potential future optimizations in its composition pipeline.   

Idempotency vs. Purity
The official React documentation also uses the term idempotency to describe the required behavior of render logic. In functional programming, an idempotent operation is one that can be applied multiple times without changing the result beyond the initial application. While related to purity, it is a slightly more relaxed constraint. React's render logic must be idempotent because React may choose to render a component multiple times before committing the result. Adhering to the stricter rules of purity is the most direct and reliable way to guarantee idempotency. Therefore, for the purposes of this specification, the OODS Pure Modifier Pattern will enforce the rules of purity to ensure it satisfies React's core requirement of idempotent rendering.   

Navigating the "Purity Spectrum"
A comprehensive review of the React ecosystem reveals that the concept of "purity" has evolved and has often been a source of confusion. Early React documentation and community discussions frequently equated functional components with pure components, operating under the assumption that because they lacked state and lifecycle methods, they were inherently pure. This perspective was prevalent in the pre-hooks era, where functional components were primarily used for simple, stateless presentation ("dumb components").   

The introduction of React Hooks in version 16.8 fundamentally changed this paradigm. Hooks allow functional components to manage local state (useState), perform side effects (useEffect), and tap into context (useContext), making them just as powerful as class components. This evolution rendered the old definition obsolete; a functional component is no longer guaranteed to be pure simply by virtue of being a function. An impure functional component can now be easily written:   

JavaScript

// An impure functional component using hooks
function ImpureTimeDisplay() {
  const = useState(new Date()); // Internal state

  useEffect(() => {
    // Side effect: interacts with browser APIs
    const timerId = setInterval(() => setTime(new Date()), 1000);
    return () => clearInterval(timerId);
  },);

  return <div>Current Time: {time.toLocaleTimeString()}</div>;
}
This historical shift from a simple stateless/stateful dichotomy to a more nuanced model of pure rendering logic versus managed side effects is critical context. The official React documentation now provides the authoritative clarification: it is the render phase that must be pure, not necessarily the component as a whole across its entire lifecycle.   

This maturation of the concept within the React community necessitates that the OODS specification be exceptionally precise in its definitions. The Pure Modifier Pattern is not merely adopting a common practice; it is adopting a strict and modern interpretation of React's core architectural intent. The governance and documentation for this pattern must actively counter the lingering, less accurate definitions of purity to establish a clear, unambiguous standard. This ensures that all developers working within the OODS ecosystem share a common, correct understanding, which is essential for maintaining the long-term architectural integrity of the View Engine.

A Comparative Analysis of Composition Models in Modern Design Systems
To establish a robust and defensible standard, the OODS Pure Modifier Pattern is grounded in a thorough analysis of the architectural patterns employed by leading production-grade UI libraries. This analysis reveals a convergence on principles of composition, separation of concerns, and the isolation of side effects. The OODS architecture represents a deliberate synthesis of the most effective patterns observed in the industry.

The Prop Transformer Model: Radix UI and shadcn/ui
Radix UI has established itself as a foundational layer for modern design systems by providing a library of unstyled, accessible, low-level UI primitives. Its core philosophy is to decouple complex behavior and accessibility from visual presentation, giving developers complete control over the final DOM structure and styling. This is achieved through a powerful composition model.   

Composition via Component Parts
Radix components are not monolithic. Instead, they are exposed as a collection of granular parts (e.g., Accordion.Root, Accordion.Trigger, Accordion.Content). This approach provides an explicit, declarative API that enforces a correct and accessible structure while allowing developers to style and arrange each individual element as needed. Under the hood, these parts communicate and share state via React Context, which eliminates the need for prop drilling and enables the components to function as a cohesive unit.   

Composition via asChild
The most significant composition primitive in the Radix ecosystem is the asChild prop. This boolean prop, when passed to a Radix part, instructs it not to render its default DOM element. Instead, it clones its immediate child element and merges its own required props—including event handlers, ARIA attributes, and data attributes—onto that child.   

This mechanism is a perfect example of a pure prop transformation. The Radix component acts as a function that takes its child's props and returns a new set of enhanced props. For this to work correctly, the child component must adhere to two contracts: it must spread the incoming props onto its underlying DOM node, and it must forward its ref using React.forwardRef so that Radix can interact with the element if needed.   

The asChild pattern is powerful because it allows for the composition of behavior without introducing extraneous wrapper div elements, leading to cleaner DOM output and preventing styling conflicts. It is the canonical implementation of the (props) => newProps model that the OODS Pure Modifier Pattern seeks to formalize.

shadcn/ui as a Distillation
The popular shadcn/ui is not a traditional component library but rather a curated collection of reusable components built upon Radix UI and Tailwind CSS. Its novel approach is that it is not installed as a dependency. Instead, a CLI tool copies the component's source code directly into the user's project. This philosophy of "owning your components" is a strong endorsement of the Radix composition model. By providing the full source code, shadcn/ui encourages developers to understand, customize, and extend the underlying Radix primitives, reinforcing the pattern of composing functionality through prop transformation and direct manipulation of unstyled building blocks.   

The Hooks-Based Separation of Concerns Model: React Aria
React Aria, developed by Adobe, presents a different but equally powerful architectural model based on a rigorous separation of concerns, enabled by React Hooks. This architecture is explicitly designed for maximum reusability, allowing the same core logic to be shared across disparate design systems and even different platforms (e.g., web and React Native). The architecture is divided into three distinct layers.   

Layer 1: State Hooks (react-stately)
At the foundation lies react-stately. This library provides hooks that are responsible for all state management logic for a component. These hooks are entirely platform-agnostic; they contain no knowledge of the DOM or any specific rendering environment. They accept props related to the component's state (e.g., value, onChange, isOpen) and return an interface object for reading and updating that state. This layer represents the "pure" core of a component's logic, handling complex state transitions in a predictable and testable manner.   

Layer 2: Behavior Hooks (react-aria)
The middle layer is react-aria. These hooks are platform-specific (in this case, for the web and the DOM). A behavior hook consumes the state interface provided by its corresponding react-stately hook and implements all the interaction logic. This includes handling keyboard events, mouse and touch interactions, focus management, and applying all necessary accessibility attributes (WAI-ARIA roles and properties). This layer is the designated home for side effects and platform-specific APIs. The output of a react-aria hook is a set of props that are intended to be spread directly onto the rendered DOM elements.   

Layer 3: The Component (The Design System)
The top layer is the component itself, which is implemented by the end developer within their own design system. This component is responsible for rendering the actual DOM structure and applying styles. It calls the state and behavior hooks, uses the state to drive its visual appearance (e.g., showing an element as selected), and spreads the props from the behavior hook onto the appropriate DOM nodes to make them interactive and accessible. This gives the developer complete control over the final markup and styling.   

The Architectural Schism and Synthesis
The approaches of Radix UI and React Aria, while different, are not mutually exclusive; they represent two sides of the same coin, solving different aspects of component composition. Radix UI has perfected the model of structural composition. Its primitives like component parts and the asChild prop provide a powerful, declarative way to define the structure, styling, and visual attributes of a component. The asChild prop, in particular, is a pure prop transformation function, directly aligning with the goals of the OODS Pure Modifier Pattern. It answers the question, "What should this component look like and what DOM should it render?"

Conversely, React Aria has perfected the model of behavioral composition. Its strict architectural separation of pure, platform-agnostic state (react-stately) from impure, platform-specific interactions (react-aria) provides an unparalleled model for creating reusable, stateful logic. It answers the question, "How should this component behave in response to user input and other events?"

The OODS View Engine architecture is a deliberate and conscious synthesis of these two industry-leading patterns. It recognizes that a truly robust system requires excellence in both structural and behavioral composition. By defining "Pure Modifiers" in the style of Radix's prop transformers, OODS establishes a predictable, deterministic way to manipulate a component's visual and structural properties. Simultaneously, by creating a separate category of "Behavioral Traits" that are analogous to React Aria's behavior hooks, OODS creates a designated, architecturally-sound location for all stateful logic and side effects, such as animations, data fetching, or analytics.

This hybrid approach is not a novel invention but rather a formalization of a convergent evolution in modern UI engineering. It provides a powerful justification for the OODS design choices and creates a clear, teachable mental model for developers. Pure Modifiers handle the (props) => newProps transformation, while Behavioral Traits handle everything else. This clear separation is the key to the system's scalability and maintainability.

Comparative Framework Table
The following table provides a high-level summary of the architectural approaches of the key libraries analyzed. It highlights the differences in their primary abstractions and how they manage purity and side effects, providing context for the synthesized approach adopted by the OODS View Engine.

Feature	Radix UI / shadcn/ui	React Aria	Framer Motion	Remix
Primary Abstraction	Composable Component Parts	State & Behavior Hooks	Motion Components	Route Modules
Composition Style	Prop Transformation (asChild)	Hook Composition	Declarative Props (layout)	Data Injection via useLoaderData
Purity Enforcement	Convention-based	Architectural Separation	Encapsulation of Side Effects	Architectural Separation
State Management	React Context	react-stately Hooks	Internal Motion Values	Server-managed via loaders
Side-Effect Domain	Event Handlers	react-aria Hooks	Animation Engine	loader/action functions

Export to Sheets
Defining the OODS Pure Modifier Pattern
Based on the foundational principles of functional programming and the analysis of industry-leading practices, this section provides the formal specification for the Pure Modifier Pattern within the OODS View Engine. Adherence to this specification is mandatory for all modifiers.

Canonical Signature and Contract
A Pure Modifier is a standard JavaScript function that conforms to the following TypeScript signature:

TypeScript

type Modifier<P extends object, C extends object = {}> = (props: P, context?: C) => Partial<P>;
Where:

P represents the props object of the component being modified.

C represents an optional context object providing additional, read-only information.

The function must return a Partial<P>, an object containing the properties to be added or overridden.

The contract for any function implementing this signature includes the following inviolable rules:

Immutability of Inputs: The function must not, under any circumstances, mutate the props or context objects it receives. These arguments must be treated as immutable and read-only. To transform properties, the function must create and return a new object containing the desired changes.

INCORRECT (Mutates Input):

JavaScript

// FORBIDDEN: This modifier directly mutates the input props object.
const withDangerStyle_INCORRECT = (props) => {
  props.className = `${props.className |

| ''} text-red-500`; // Mutation!
return props;
};
```

**CORRECT (Returns New Object):**
```javascript
// CORRECT: This modifier returns a new object with the transformed property.
const withDangerStyle_CORRECT = (props) => {
  const newClassName = `${props.className |
| ''} text-red-500`;
return { className: newClassName };
};
```
This rule is critical for preventing unpredictable side effects that can be notoriously difficult to debug in a complex component tree.   

Return Value: The function must always return an object. If no modifications are needed, it should return an empty object ({}). The OODS View Engine's compositor will perform a shallow merge of the returned object with the original props to produce the final props for the component.

The Determinism Mandate
A Pure Modifier must be deterministic. This means that for an identical props object and an identical context object, the modifier must always produce an identical output object. This property ensures that the composition process is predictable and repeatable, which is essential for reliable rendering and effective testing.   

To guarantee determinism, the following operations are strictly prohibited within the body of a Pure Modifier:

No Randomness: Calls to non-deterministic functions like Math.random() or any other pseudo-random number generators are forbidden.

No Time-Dependency: Calls to time-sensitive APIs such as Date.now(), new Date(), or performance.now() are forbidden. The output of a modifier cannot depend on the time at which it is executed.

No External State: The function must not read from or depend on any external or global state. This includes global variables (e.g., window, document), environment variables, or any state that is not explicitly passed in through the props or context arguments.

No I/O Operations: The function must not perform any form of Input/Output. This includes, but is not limited to, network requests (fetch, XMLHttpRequest), file system access, database queries, or writing to localStorage or sessionStorage.

Forbidden Anti-Patterns
To provide absolute clarity for trait authors, this section enumerates specific anti-patterns that violate the pure modifier contract. Any modifier containing these patterns will be rejected by the system's governance mechanisms.

Direct DOM Mutation
Modifiers operate exclusively on the props object, which is a JavaScript representation of a component's configuration. They must not interact with the DOM in any way. This is a side effect that violates purity and breaks React's declarative model.   

FORBIDDEN:

JavaScript

constsetTitle_ANTI_PATTERN = (props) => {
  // Side effect: Direct DOM manipulation
  document.title = props.pageTitle |

| 'Default Title';
  return {};
};
Inline Prop Mutation
As detailed in Section 3.1, modifying the input props object directly is a severe violation of the immutability contract. This can lead to unpredictable behavior in other parts of the system that may hold a reference to the same object.

FORBIDDEN:

JavaScript

const withActiveState_ANTI_PATTERN = (props) => {
  if (props.isActive) {
    props.className += ' active'; // Mutation!
  }
  return props;
};
Context Writes
While a modifier is permitted to read values from the context object passed to it, it is strictly forbidden from attempting to write to or modify a React context. Modifying context is a side effect that should be handled by state management logic within a component or a Behavioral Trait, typically via a state setter function provided by the context.

Invoking React Hooks
This is a critical architectural rule. Pure Modifiers are plain JavaScript functions that are executed by the OODS View Engine during its composition phase. They are not React components or custom React Hooks. Therefore, calling any function that begins with use (e.g., useState, useEffect, useContext, useRef) inside a modifier is illegal. This violates the "Rules of Hooks," which state that hooks can only be called from the top level of a React function component or another custom hook. An attempt to do so will result in a runtime error from React.   

FORBIDDEN:

JavaScript

import { useState } from 'react';

const withInternalState_ANTI_PATTERN = (props) => {
  // Illegal hook call: Modifiers are not React components.
  const [value, setValue] = useState(props.initialValue);
  return { value };
};
Logging and Analytics
Any call that performs an I/O operation is a side effect. This includes logging to the console (console.log, console.error, etc.) or dispatching events to an analytics service. While useful for debugging, these calls must be removed from production modifier code. Such side effects should be encapsulated within Behavioral Traits and triggered by user interactions or component lifecycle events.

FORBIDDEN:

JavaScript

const withLogging_ANTI_PATTERN = (props) => {
  // Side effect: Console I/O
  console.log('Rendering component with props:', props);
  return {};
};
Architectural Segregation of Side Effects
A core principle of the OODS View Engine architecture is the strict separation of pure logic from impure side effects. This separation is not merely a convention but a "firewall" that contains complexity, enhances testability, and makes the entire system more robust and easier to reason about. This is achieved by clearly delineating the responsibilities of Pure Modifiers and Behavioral Traits.

The "Firewall": Modifiers vs. Behavioral Traits
The system defines two distinct categories of composable logic, each with a clear and mutually exclusive responsibility:

Pure Modifiers: As defined exhaustively in Section 3, the sole responsibility of a Pure Modifier is the synchronous, deterministic, and side-effect-free transformation of a component's properties. Modifiers answer the question: "Given these current props, what should the final props look like before rendering?" They are pure calculations that operate on data.

Behavioral Traits: The responsibility of a Behavioral Trait is to encapsulate all logic that is inherently stateful or involves side effects. This includes any operation that needs to interact with the outside world, manage state over time, or respond to events asynchronously. Behavioral Traits answer questions like: "How should this component animate when it appears?", "What analytics event should be fired when this button is clicked?", or "What data needs to be fetched from the server for this component to render?"

This architectural division ensures that the most common and critical path—the calculation of component props—remains simple, predictable, and highly optimized. The more complex, unpredictable, and harder-to-test logic involving side effects is isolated into a separate, well-defined construct.

Case Study: Animation with Framer Motion
Animation provides a quintessential example of why this architectural firewall is necessary. By its very definition, animation is a side effect. It involves the direct, timed manipulation of DOM element properties (such as transform, opacity, and height) to create the illusion of motion over a duration. This process is stateful (tracking the animation's progress) and inherently impure (directly mutating the DOM). It is fundamentally incompatible with the contract of a Pure Modifier.   

Framer Motion, a leading animation library for React, provides a best-in-class example of how to manage this complexity. It encapsulates the imperative, side-effect-driven logic of its animation engine behind a simple, declarative API. A developer does not manually write a setInterval loop to update an element's style. Instead, they declare their intent to animate by adding props like layout, animate, or exit to a motion component.   

JavaScript

<motion.div
  layout
  initial={{ opacity: 0, scale: 0.5 }}
  animate={{ opacity: 1, scale: 1 }}
  transition={{ duration: 0.5 }}
/>
The Framer Motion library then takes over, handling the complex, stateful DOM manipulation internally. The fact that layout animations can sometimes be complex and lead to unexpected visual bugs further reinforces the need for this encapsulation. Isolating this potent but potentially volatile logic within a dedicated Behavioral Trait prevents its complexity from "leaking" into and contaminating the simple, predictable world of Pure Modifiers. This case study validates the decision to classify animation as a behavior that is explicitly outside the scope of modifiers.   

Case Study: Data Loading with Remix
The Remix web framework offers another powerful example of architectural separation, this time for the side effect of data fetching. Remix's architecture strictly isolates data loading and mutation logic from the rendering logic of React components.   

In Remix, each route can export a loader function, which runs exclusively on the server. This function is responsible for all data-fetching side effects, such as querying a database or calling an external API. The data returned from the loader is then made available to the route's component via the useLoaderData hook.   

The React component itself remains pure with respect to data fetching. It does not contain any fetch calls or data-loading logic. It simply receives the data as a prop and renders the UI accordingly. This architectural pattern creates a clear boundary: the server-side loader is the domain of I/O side effects, while the client-side component is the domain of pure rendering logic.

The Remix model provides further validation for the OODS architecture. Just as Remix isolates data I/O in loader functions, the OODS View Engine isolates all forms of side effects—be they data fetching, analytics, or complex user interactions—within Behavioral Traits. This consistent pattern of separating pure calculations from impure actions is a hallmark of robust and scalable front-end architectures.

Governance and Implementation Blueprint
To ensure the long-term integrity of the Pure Modifier Pattern, a robust governance strategy is required. This strategy moves beyond mere documentation and convention to include automated, enforceable checks at both the testing and static analysis stages. This section provides a blueprint for the tools and processes that will guarantee compliance.

The Purity Harness: A Testing Utility for Referential Transparency
A testing utility, validateModifierPurity, will be created and made available to all trait authors. This "purity harness" is designed to programmatically verify that a given modifier function adheres to the core tenets of the purity contract. It will be located at /compositor/tests/purityHarness.ts.

Specification for validateModifierPurity(modifierFn)
The utility will be a higher-order function used within a testing framework like Jest. Its implementation will follow these steps:

Input Guarding with deepFreeze: The harness will accept the modifier function under test, a sample props object, and an optional context object. Before executing the modifier, the harness will perform a deep, recursive freeze on the input props and context objects. This is achieved using a deepFreeze utility that traverses the object graph and applies Object.freeze() to all nested objects and arrays.   

JavaScript

// Simplified deepFreeze implementation
function deepFreeze(object) {
  if (object && typeof object === 'object') {
    Object.freeze(object);
    Object.getOwnPropertyNames(object).forEach(prop => {
      deepFreeze(object[prop]);
    });
  }
  return object;
}
By freezing the inputs, the harness creates an immutable guard. If the modifier attempts to mutate any property of its inputs, JavaScript will throw a TypeError in strict mode, which will be caught by the test runner and cause the test to fail immediately. This provides an automated, foolproof test for the "no input mutation" rule.   

Determinism Verification: After freezing the inputs, the harness will invoke the modifier function twice in succession with the exact same frozen input objects.

Output Comparison: The harness will then perform a deep equality comparison between the two resulting output objects. If the two outputs are not deeply equal, it proves the function is not deterministic, and the test will fail with a clear error message.

Snapshot Testing Integration: For a valid, pure modifier, the harness will return the first valid output. This allows developers to easily integrate with Jest's snapshot testing feature, ensuring that the modifier's output remains consistent across code changes.

An example of its usage in a test file would be:

JavaScript

import { validateModifierPurity } from '/compositor/tests/purityHarness';
import { withVariant } from './withVariant.modifier';

describe('withVariant modifier', () => {
  it('should be a pure function', () => {
    const initialProps = { variant: 'primary', className: 'base-button' };
    
    const result = validateModifierPurity(withVariant, initialProps);

    // Optional: Assert against a snapshot for regression testing
    expect(result).toMatchSnapshot();
  });
});
Transforming an Abstract Concept into a CI/CD Gate
The creation of the validateModifierPurity harness is a critical step in translating an abstract architectural principle into a concrete engineering contract. The concept of "referential transparency" is academic and difficult to enforce through code reviews alone. The harness operationalizes this concept by breaking it down into its testable constituent properties: determinism and the absence of side effects (specifically, input mutation).   

The process is as follows:

The abstract goal is referential transparency.   

This is broken down into two testable properties: a) the function must not mutate its inputs, and b) it must be deterministic.   

Property (a) is tested by making the inputs immutable at runtime using deepFreeze. Any attempt at mutation results in a thrown error, providing a clear test failure.   

Property (b) is tested by calling the function multiple times with identical, value-based inputs and asserting that the outputs are also identical in value.

By combining these techniques into a single, easy-to-use utility, the system provides a powerful tool that can be mandated for all new modifiers. Integrating these tests into the project's continuous integration and deployment (CI/CD) pipeline transforms the architectural guideline from a suggestion into a gatekeeper. No modifier that fails this purity check can be merged into the main codebase, thus ensuring the long-term health and predictability of the OODS View Engine.

Static Enforcement with Custom Linting
While runtime tests provide the ultimate guarantee of correctness, static analysis offers immediate feedback to developers within their Integrated Development Environment (IDE), preventing errors at the source. To this end, a custom ESLint rule will be developed to forbid the most severe violation of the modifier contract: calling React Hooks.

ESLint Rule Specification: oods/no-hooks-in-modifiers
Rule ID: oods/no-hooks-in-modifiers

Target Files: The rule will be configured to run exclusively on files that match the modifier naming convention, e.g., *.modifier.ts or files within a /modifiers/ directory.

Logic: The rule will traverse the Abstract Syntax Tree (AST) of the targeted files. It will implement a visitor method for CallExpression nodes. Inside the visitor, it will inspect the callee of the function call. If the callee is an Identifier whose name property begins with the string "use", the rule will report an error at that node's location. This will catch calls to useState, useEffect, useCustomHook, etc.   

Error Message: The reported error message will be clear and actionable, for example: "React Hooks cannot be called inside OODS Pure Modifiers. Encapsulate stateful logic or side effects in a Behavioral Trait."

This ESLint rule will be added to the project's core ESLint configuration, ensuring that developers receive instant feedback if they attempt to misuse hooks within a modifier, thereby enforcing the architectural boundary between pure functions and React's stateful logic. Resources for building custom ESLint rules are readily available and provide a clear path for implementation.   

Documentation and Onboarding for Trait Authors
Finally, clear and accessible documentation is essential for ensuring developer adoption and compliance. A canonical document will be created at docs/patterns/modifier-purity.md. This document will serve as the single source of truth for trait authors. The template for this document is as follows:

Title: The Pure Modifier Pattern

1. Overview

A Pure Modifier is a simple, synchronous JavaScript function responsible for transforming a component's props. It must be a pure function, meaning it is deterministic and has no side effects. Its sole purpose is to calculate a new set of props based on the props it receives.

2. Canonical Signature

TypeScript

type Modifier<P extends object, C extends object = {}> = (props: P, context?: C) => Partial<P>;
3. Golden Path Example

Here is an example of a correctly implemented modifier that adds a CSS class based on a size prop.

TypeScript

// src/modifiers/withSize.modifier.ts

const sizeMap = {
  sm: 'button-sm',
  md: 'button-md',
  lg: 'button-lg',
};

export const withSize = (props) => {
  const sizeClass = sizeMap[props.size] |

| sizeMap.md;
  const newClassName = `${props.className |

| ''} ${sizeClass}`.trim();
  
  return { className: newClassName };
};
4. Developer Checklist

Before submitting a modifier for review, ensure it meets the following criteria:

[ ] Does the function always return the same output for the same input?

[ ] Does the function avoid mutating its props or context arguments?

[ ] Does the function return a new object?

[ ] Does the function avoid all side effects (no Math.random, new Date(), fetch, console.log, etc.)?

[ ] Does the function avoid calling any React Hooks (e.g., useState, useEffect)?

[ ] Have you added a unit test using the validateModifierPurity harness?

5. Forbidden Anti-Patterns

The following patterns are strictly forbidden. Code containing them will fail CI checks.

Direct DOM Mutation: document.title = '...';

Input Prop Mutation: props.className += '...';

Calling Hooks: const = useState(...);

External State: if (window.innerWidth > 600) {... }

Non-Determinism: const id = Math.random();

6. When to Use a Behavioral Trait

If your logic requires any of the following, it does not belong in a Pure Modifier. You must implement it as a Behavioral Trait instead:

Managing state (useState, useReducer)

Performing side effects after render (useEffect)

Handling user interactions that cause side effects (e.g., analytics calls on click)

Animation

Data fetching

7. Testing Your Modifier

All modifiers must include a unit test that uses the validateModifierPurity harness to verify correctness.

JavaScript

// src/modifiers/withSize.modifier.test.ts
import { validateModifierPurity } from '/compositor/tests/purityHarness';
import { withSize } from './withSize.modifier';

it('should be a pure function', () => {
  const initialProps = { size: 'lg', className: 'base' };
  const result = validateModifierPurity(withSize, initialProps);
  expect(result.className).toBe('base button-lg');
});

Sources used in the report

reddit.com
Whats so wrong with direct DOM manipulation? : r/javascript - Reddit
Opens in a new window

blog.logrocket.com
Pure components in React: Using PureComponent and React.memo - LogRocket Blog
Opens in a new window

kindafunctional.com
A Guide on Functional Programming - Referential Transparency
Opens in a new window

medium.com
Master the JavaScript Interview: What is a Pure Function? | by Eric Elliott - Medium
Opens in a new window

freecodecamp.org
What Is a Pure Function in JavaScript? - freeCodeCamp
Opens in a new window

johnkavanagh.co.uk
Pure Functions in JavaScript, by John Kavanagh
Opens in a new window

react.dev
Components and Hooks must be pure – React
Opens in a new window

react.dev
Keeping Components Pure - React
Opens in a new window

blog.thesshguy.com
Pure Functions in React: Why and How-to - Blog - Sai Hari
Opens in a new window

sitepoint.com
What Is Referential Transparency? — SitePoint
Opens in a new window

medium.com
Referential transparency - Medium
Opens in a new window

dev.to
Function purity and referential transparency - DEV Community
Opens in a new window

educative.io
What's purity in React? - Educative.io
Opens in a new window

reddit.com
Are functional components pure components ? : r/reactjs - Reddit
Opens in a new window

radix-ui.com
Introduction – Radix Primitives
Opens in a new window

alexkondov.com
Building Low Level Components the Radix Way | Alex Kondov - Software Engineer
Opens in a new window

dev.to
Implementing Composition Pattern in React Applications with RadixSlot - DEV Community
Opens in a new window

dev.to
How To Write Material UI Components Like Radix UI And Why Component Composition Matters? - DEV Community
Opens in a new window

radix-ui.com
Composition – Radix Primitives
Opens in a new window

ui.shadcn.com
Introduction - Shadcn UI
Opens in a new window

shadcn.io
Shadcn UI React Components
Opens in a new window

react-spectrum.adobe.com
Architecture – React Spectrum
Opens in a new window

react-spectrum.adobe.com
Why React Aria?
Opens in a new window

reactspectrum.blob.core.windows.net
Getting Started – React Aria - NET
Opens in a new window

react-spectrum.adobe.com
Getting Started – React Aria
Opens in a new window

dmitripavlutin.com
Pure Functions in JavaScript: A Beginner's Guide - Dmitri Pavlutin
Opens in a new window

react.dev
Rules of Hooks – React
Opens in a new window

motion.dev
Layout Animation — React FLIP & Shared Element | Motion
Opens in a new window

developer.mozilla.org
DOM scripting introduction - Learn web development | MDN - Mozilla
Opens in a new window

motion.dev
Motion component - React
Opens in a new window

reddit.com
Thoughts about Framer Motion : r/reactjs - Reddit
Opens in a new window

v2.remix.run
loader - Remix
Opens in a new window

github.com
How to fully benefit from server rendering; organizing loader & action functions? · remix-run remix · Discussion #2599 - GitHub
Opens in a new window

v2.remix.run
Data Loading - Remix
Opens in a new window

developer.mozilla.org
Object.freeze() - JavaScript | MDN
Opens in a new window

docs.vultr.com
JavaScript Object freeze() - Make Object Immutable - Vultr Docs
Opens in a new window

geeksforgeeks.org
How to Deep-Freeze an Object in JavaScript? - GeeksforGeeks
Opens in a new window

glebbahmutov.com
Test if a function is pure revisited - Gleb Bahmutov
Opens in a new window

mariokandut.com
How to write a custom ESLint rule - Mario Kandut
Opens in a new window

developers.mews.com
How to write custom ESLint rules - Mews Developers
Opens in a new window

eslint.org
Custom Rule Tutorial - ESLint - Pluggable JavaScript Linter
Opens in a new window

eslint.org
Custom Rules - ESLint - Pluggable JavaScript Linter
Opens in a new window

dev.to
How to create your own Eslint rule with tests, boosting the DX, and code-review