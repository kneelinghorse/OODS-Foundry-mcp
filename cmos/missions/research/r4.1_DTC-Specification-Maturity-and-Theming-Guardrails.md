Mission TR-20251010-R4.1: DTCG Specification Maturity and Theming Guardrails
1.0 Executive Summary & DTCG Maturity Assessment (October 2025)
1.1 Overview of Findings
This report presents a technical assessment of the Design Tokens Community Group (DTCG) specification, with a focus on its suitability for implementing robust, multi-brand theming. The analysis concludes that the core DTCG Format Module is sufficiently mature and stable for enterprise adoption within the upcoming Sprint 04 development cycle. This adoption, however, is contingent upon the implementation of strict engineering guardrails designed to isolate the stable, standardized features of the specification from those that remain experimental or ambiguous. The foundational properties of a design token, namely $value, $type, and $description, are considered stable and have achieved first-class support in essential ecosystem tooling, most notably Style Dictionary version 4 and later. The primary risks to a successful implementation do not stem from the core specification itself, but rather from the deltas between the formal standard, the advanced features offered by authoring tools, and the lack of a standardized process for alias resolution across multiple files. This report provides a definitive set of guardrails to mitigate these risks.   

1.2 Stability Levels and Risk Assessment
A detailed risk assessment of the key concepts required for theming reveals varying levels of maturity:

Aliases (References): The fundamental syntax for referencing another token, {path.to.token}, is well-defined, stable, and documented in the current living draft of the specification. This feature is the cornerstone of effective theming, allowing for the creation of semantic layers that reference a primitive value set. The primary risks associated with aliases are not syntactic but algorithmic. The specification explicitly forbids circular dependencies, and the process for resolving references across different files is not defined by the DTCG but is instead a function of the chosen build tool. Without a rigorously defined build process, the resolution of cross-file references can become unpredictable.   

Groups: The use of nested JSON objects to create a hierarchical structure for tokens, known as groups, is a fundamental and stable concept. The resulting token path, formed by joining the nested keys with a period, is the mechanism by which aliases reference other tokens. The specification is unequivocal that groups serve a purely organizational purpose; build tools and parsers MUST NOT infer any semantic meaning or type information from a group's name. This principle is a critical constraint that simplifies implementation and prevents tool-specific logic from polluting the token data.   

The "Resolver": The mission brief's reference to a "proposed Resolver" and an associated "RFC" appears to be a misnomer. An exhaustive review of the DTCG's technical reports and community discussions, as well as broader RFC databases, confirms that no formal DTCG "Resolver" specification exists. Searches for such a document yield results pertaining exclusively to Domain Name System (DNS) resolvers, a wholly unrelated technology. Therefore, this report addresses this ambiguity by defining a "Safe Resolver Model" in Section 2.3. This model is not based on a non-existent specification but is instead a prescriptive algorithm derived from the documented, production-proven architecture of the Style Dictionary build system.   

1.3 Summary of Recommendations
To de-risk the adoption of the DTCG specification for theming, the following high-level recommendations should be implemented immediately:

Adopt the Strict Core: Mandate the use of the core DTCG properties ($value, $type, $description) for all design tokens. All tokens must possess these properties to be considered valid.

Allow Simple, Full-Value Aliases: Permit the use of the standard {path.to.token} syntax for aliasing. However, this should be restricted to cases where the alias constitutes the entire $value of a token. Complex patterns such as string interpolation are to be deferred.

Enforce Strict Naming and Structure Conventions: Implement an automated linting process to enforce strict rules for token and group naming, including character restrictions and casing conventions, based on the constraints outlined in the DTCG specification and expanded upon in this report for enterprise safety.

Defer Advanced and Experimental Features: Prohibit the use of features that are subjects of ongoing community discussion but are not yet formally specified. This includes nested references, alias fallbacks, and aliasing within arrays.   

Standardize the Build and Merge Process: The entire theming strategy depends on a predictable token file merge process. The build pipeline must be configured to use Style Dictionary's include and source arrays to establish a clear order of precedence, ensuring that theme-specific tokens correctly override base tokens.

2.0 Analysis of DTCG Concepts and Stability
2.1 Aliases (References): Syntax and Semantics
The concept of an alias, also referred to as a reference, is a cornerstone of modern design token architecture and is central to the DTCG specification. It provides the mechanism for creating layers of abstraction, enabling the creation of semantic and component-specific tokens that are decoupled from primitive values.

2.1.1 Core Syntax and Purpose
The DTCG Format Module living draft mandates a precise syntax for aliases. For a design token to reference another, its $value property MUST be a string that contains the period-separated path to the target token, enclosed in curly brackets ({}). This syntax is unambiguous and has been widely adopted by the tooling ecosystem, including authoring tools like Tokens Studio  and transformation engines like Style Dictionary.   

The primary purpose of aliasing is twofold. First, it enables the expression of design choices and intent. By creating a semantic token, such as color.background.interactive.default, and aliasing it to a primitive value like {color.brand.blue-500}, the system gains a layer of meaning. This shared language improves communication between design and engineering. Second, it adheres to the Don't Repeat Yourself (DRY) principle, eliminating the repetition of hard-coded values throughout the token files. This is critical for maintainability; a change to the primitive blue-500 value will automatically propagate to all semantic tokens that reference it, ensuring system-wide consistency.   

2.1.2 Stability and Community Discussion
The basic alias syntax is considered highly stable and safe for production use. However, its application in more complex scenarios is the subject of ongoing discussion within the DTCG community. Open issues in the community group's repository raise questions about the validity and desired behavior of references within array values (e.g., for multi-layered shadows) and the ability to alias individual properties within composite tokens. Furthermore, some tools have historically supported non-standard features like "nested references," a practice that Tokens Studio is now actively phasing out to improve alignment with the formal DTCG specification, which does not include it. This divergence between tool capabilities and formal standards represents a significant risk, which the guardrails in this report are designed to mitigate.   

2.2 Groups: Naming and Organization
Groups are the foundational organizational structure within a design token file. They provide the hierarchy that gives tokens their unique, addressable paths.

2.2.1 Definition and Purpose
In the context of the DTCG JSON format, a group is not a special type of entity but is simply an artifact of the file's structure. A group is formed by nesting JSON objects. The path to a token is constructed by joining the keys of these nested objects (the group names) with a period (.) as a separator.   

The specification is explicit and emphatic about the purpose of groups: they are for arbitrary and organizational purposes only. Tools that consume DTCG files MUST NOT attempt to infer the type, purpose, or any other semantic meaning from a group's name. For instance, a tool should not assume that all tokens within a group named color are of type color. This strict separation of organization from meaning is a crucial architectural principle that ensures the portability and longevity of the token data, preventing it from becoming coupled to the logic of a specific tool.   

Despite this constraint, a logical grouping structure is invaluable for human authors and for tooling that provides authoring assistance. Tools like Tokens Studio leverage the group structure to offer powerful workflows, such as the ability to rename, duplicate, or delete entire branches of the token tree in a single action, significantly improving the efficiency of maintaining large token sets.   

2.3 The "Safe Resolver Model": An Algorithmic Definition
As established, no formal DTCG specification for an alias "resolver" exists. To ensure a predictable, unambiguous, and performant build process, this report defines a "Safe Resolver Model." This model is a prescriptive, multi-step algorithm based on the documented architecture of the Style Dictionary transformation engine, which represents the industry standard for token processing. The objective is to define a minimal, future-compatible algorithm that guarantees correctness and operates with a computational complexity that does not exceed O(n), where n is the total number of tokens.   

The proposed algorithm consists of the following sequential steps:

Deep Merge of Token Files: The process begins by taking all token files specified in the build configuration (e.g., in Style Dictionary's include and source arrays) and performing a deep merge into a single, unified in-memory JSON object. The order of this merge is critical as it defines precedence; values from files merged later will overwrite values for the same token path from files merged earlier. This step is fundamental to how Style Dictionary operates and is the core mechanism that enables theming. After this step, the concept of "cross-file" references ceases to exist; all subsequent operations occur on this unified data structure.   

Graph Construction (Conceptual): The merged token object can be conceptualized as a directed graph. Each token is a node, and each alias ($value starting with {) is a directed edge from the aliasing token to the token it references.

Cycle Detection: Before any values are resolved, the graph must be traversed to detect circular dependencies. A cycle exists if any token's alias chain eventually leads back to itself (e.g., token-A references token-B, which in turn references token-A). The DTCG specification explicitly forbids circular references. If a cycle is detected, the build process MUST fail immediately with an error that clearly identifies the tokens involved in the cycle. This step is non-negotiable as it prevents infinite loops during the resolution phase and is essential for guaranteeing the O(n) performance target.   

Value Resolution: The final step is to traverse the unified token object. For each token, its $value is inspected. If the value is an alias, the resolver follows the path specified within the curly brackets to find the referenced token in the merged object. This process is repeated recursively until a token with a literal (non-alias) $value is found. This final literal value is then assigned as the resolved value of the original token.

It is critical to distinguish between a "group" and a "composite token" during this process. Both appear as nested objects in the JSON structure. However, a composite token is a single, addressable design token that has a $type property at its root (e.g., $type: "typography") and whose $value is an object containing a predefined set of sub-properties. A group, by contrast, is merely a container in the hierarchy, has no $type property of its own, and can contain other groups or tokens. The resolution algorithm must be able to alias a composite token (e.g., "$value": "{typography.style.heading-1}") but must fail if an attempt is made to alias an entire group (e.g., "$value": "{color.brand}"), as a group is not a token and has no single resolvable value.   

3.0 Guardrails for Immediate Implementation (Sprint 04)
The following set of rules and conventions must be adopted for all design token authoring, effective Sprint 04. These guardrails will be enforced through automated linting in the CI/CD pipeline to ensure stability, consistency, and forward-compatibility with the evolving DTCG specification.

3.1 Naming and Structure Rules
A consistent and predictable naming convention is the foundation of a scalable token system. The following rules apply to all token and group names (i.e., all keys within the token JSON files).

Allowed Characters: Token and group names must consist of alphanumeric characters and hyphens. To ensure consistency across the system, all names will adhere to kebab-case.

Disallowed Characters: In accordance with the DTCG specification, token and group names MUST NOT contain the following characters: { (left curly bracket), } (right curly bracket), or . (period). The period is a reserved character used by the resolver to delimit segments in an alias path. While authoring tools like Tokens Studio use a period in their UI to denote group creation, they correctly abstract this into a nested object structure in the underlying JSON output, which is the format our linter will validate.   

Reserved Prefixes: Token and group names MUST NOT begin with the $ character. This prefix is reserved exclusively for properties defined by the DTCG format specification (e.g., $value, $type, $description) and any future properties it may introduce.   

Case Sensitivity: The DTCG specification states that token names are case-sensitive, meaning font-size and Font-Size are technically distinct tokens. However, this can lead to severe and difficult-to-debug collisions in downstream platforms that are case-insensitive, such as Sass or CSS custom properties. To mitigate this risk and ensure enterprise-grade safety, our guardrails will be stricter than the specification: all token and group names MUST be authored in lowercase kebab-case. An automated linter will enforce this rule, preventing such collisions before they enter the system.   

These naming and character rules are summarized in the table below for quick reference.

Rule Category	Requirement	Rationale	Invalid Examples	Valid Example
Casing	Must use lowercase kebab-case.	Prevents collisions in case-insensitive platforms.	myToken, My-Token	my-token
Characters	Must not contain {, }, or ..	Reserved for alias syntax and path resolution.	token.name, {token}	token-name
Prefixes	Must not begin with $.	Reserved for DTCG specification properties.	$my-token	my-token

Export to Sheets
3.2 Reference (Alias) Semantics
The use of aliases is permitted and encouraged, but must adhere to the following strict semantic rules to ensure the stability of the Safe Resolver Model.

No Circular Dependencies: The build process must incorporate a robust cycle detection mechanism. Any alias chain that forms a closed loop (e.g., token-A references token-B, which references token-A) is invalid. The build MUST fail with a clear error message identifying the tokens in the cycle.   

Single, Full-Value Aliases Only: An alias can be used as the value of a token, but it must constitute the entire value. String interpolation or concatenation (e.g., "$value": "1px solid {color.border.default}") is forbidden in this initial implementation. This rule simplifies the resolution logic and avoids adopting a tool-specific implementation for a feature that is not yet standardized. While Style Dictionary provides utilities like resolveReferences that can handle such cases, this capability is explicitly deferred.   

No Fallbacks: The DTCG specification does not currently define a standard mechanism for providing fallback values for aliases. Community discussions have explored using arrays for this purpose (e.g., "$value": ["{color.theme.primary}", "#FF0000"]), but this pattern is highly experimental and unsupported. Therefore, all aliases must resolve to a valid token. The build process will fail on any unresolved reference; no fallback behavior will be implemented.   

Cross-File References: Referencing a token defined in a different file is permitted and is essential for theming. This is enabled by Style Dictionary's deep merge architecture, which combines all source files into a single object before alias resolution begins. An alias in dark-theme.json can therefore safely reference a token defined in global.json. The validity of such references is entirely dependent on the correct configuration of the build tool's merge strategy, as detailed in Section 5.1.   

3.3 Type System and Values
A strong type system is essential for enabling automated transformations and validations. All tokens must adhere to the official DTCG type system.

Official Types Only: Every token object MUST include a $type property. The value of this property MUST be one of the official token types defined in the DTCG specification. This includes types such as color, dimension, fontFamily, fontWeight, shadow, border, and typography.   

Mapping Unofficial Types: It is recognized that designer-focused authoring tools like Tokens Studio introduce "unofficial" token types to provide a more intuitive user experience. For example, Tokens Studio uses types like spacing, sizing, borderRadius, and borderWidth, which do not exist in the formal DTCG specification. These types are typically convenient abstractions over the official dimension type. To bridge this gap, the build process MUST include a pre-processing step. This step will use a library such as @tokens-studio/sd-transforms to parse the output from Tokens Studio and map these unofficial types to their official DTCG equivalents before any validation or transformation occurs. This ensures that the core Style Dictionary engine receives 100% spec-compliant token data.   

The following table provides the definitive mapping that must be implemented in the build pipeline's pre-processing step.

Tokens Studio Type	DTCG / Style Dictionary Type	Notes
spacing	dimension	Maps directly to the dimension type.
sizing	dimension	Maps directly to the dimension type.
borderRadius	dimension	Maps directly to the dimension type.
borderWidth	dimension	Maps directly to the dimension type.
letterSpacing	dimension	Maps directly to the dimension type.
paragraphSpacing	dimension	Maps directly to the dimension type.
boxShadow	shadow	The official DTCG type is shadow.
text	content	The official DTCG type is content.
asset	asset	Unofficial in DTCG, but supported by transforms.
boolean	boolean	Unofficial in DTCG, but supported by transforms.
other	other	Unofficial in DTCG, but supported by transforms.

Export to Sheets
4.0 Deferred & Experimental Features (Guard for Future)
To ensure long-term stability and avoid lock-in to tool-specific implementations, several powerful but non-standard features are explicitly deferred. These features are considered experimental, and their use in production token files is prohibited. The linter should be configured to emit warnings if these patterns are detected, alerting authors to their non-standard status. This approach prioritizes the portability and future-compatibility of our token assets over the immediate availability of advanced, non-standardized features.

4.1 Advanced Aliasing and String Interpolation
Description: This feature refers to the ability to embed one or more token aliases within a string value, which is particularly useful for composite properties. An example would be defining a border token as "$value": "solid {border.width.default} {color.border.default}".

Risk Analysis: While this is a highly desirable feature for creating complex, interconnected styles, it is not formally specified by the DTCG. The syntax for interpolation and the rules for resolution are not standardized. Transformation engines like Style Dictionary have developed their own implementations to meet user demand, offering utilities like resolveReferences to handle this pattern. However, adopting a tool-specific implementation introduces significant risk. It creates a dependency on that tool's specific logic and could lead to substantial refactoring efforts if a different standard emerges from the DTCG in the future.   

Guardrail: Forbid for production use. The linter will emit a warning if a {...} reference pattern is detected inside a string that is not a pure, full-value alias. The recommended alternative is to use a DTCG composite token type, such as border, which has distinct properties for width, style, and color.

4.2 Aliases within Arrays
Description: This pattern involves using an alias as one of the items in an array-based value. A common use case would be defining a multi-layered box shadow where one of the shadow layers references a shared color token.

Risk Analysis: The behavior and syntax for resolving aliases within arrays are undefined in the current specification. The DTCG's public issue tracker shows that this is an open topic of discussion (#241), indicating that no community consensus has been reached. Implementing this would require inventing a custom resolution logic, which would almost certainly be incompatible with a future standard.   

Guardrail: Forbid for production use. The linter will emit a warning if an alias syntax is detected as an element within a JSON array.

4.3 Value Fallbacks
Description: This refers to a mechanism for providing one or more fallback values in case an alias cannot be resolved or if the referenced token is not supported on a target platform. Community discussions on the DTCG GitHub repository have floated the idea of using an array for this purpose, where the first element is the preferred token reference and subsequent elements are fallback values (e.g., "$value": ["{color.interactive.default}", "#0066FF"]).   

Risk Analysis: This concept is purely theoretical at this stage. It has no formal specification, and its implementation would require a significant and entirely custom extension to the alias resolution logic. Adopting such a pattern would create a deeply non-standard token structure that would be difficult to migrate away from. The "Safe Resolver Model" is predicated on the principle that all references must be resolvable; an unresolvable reference is a build failure, not a trigger for fallback logic.

Guardrail: Forbid for production use. The build must be configured to fail on any unresolved alias. The linter will emit a warning if it detects an array value where the first element is an alias, as this is a likely indicator of an attempted fallback implementation.

5.0 Tooling Ecosystem: Contradictions and Build Implications
Successfully implementing a DTCG-based token system requires a deep understanding of the tooling ecosystem and, critically, how to resolve the inherent contradictions between different tools and the formal specification. The build pipeline is not merely a consumer of tokens; it is an active participant in defining their final, resolved meaning.

5.1 Tokens Studio vs. Style Dictionary: The Merge Precedence Problem
A significant point of friction exists between the conceptual model of token organization in an authoring tool like Tokens Studio and the operational model of a build tool like Style Dictionary.

The Contradiction: Tokens Studio organizes tokens into discrete "Token Sets," which are analogous to separate JSON files. Its Pro version allows users to group these sets into "Themes" and visually control the override order by dragging and dropping sets within a list; sets lower in the list take precedence over those higher up. Style Dictionary, conversely, has no knowledge of "Token Sets" or "Themes." It operates on a configuration that specifies arrays of file paths, include and source, and the order of files within these arrays dictates the merge precedence. There is no automatic mechanism to translate the visual order from Tokens Studio into the correct configuration for Style Dictionary.   

Deep Merge Precedence in Style Dictionary: The architecture of Style Dictionary is explicit and unambiguous on this point. It first processes all file globs in the include array, in order. It then processes all file globs in the source array, also in order. All files are combined via a deep merge, and in cases of conflicting keys, the value from the file processed later overwrites the value from the file processed earlier. This means that any token defined in a source file will always override an identically named token from an include file.   

Recommended Algorithm for Theming: This precedence order is not a limitation but is in fact the key to enabling robust theming. The following configuration strategy must be adopted for the build pipeline:

Base Tokens in include: All foundational or global token files (e.g., global.json, primitives.json, core.json) should be specified in the include array of the Style Dictionary configuration. These files represent the "base" theme or the default set of values.

Theme Overrides in source: All theme-specific token files (e.g., dark-theme.json, compact-theme.json, brand-b-theme.json) should be specified in the source array. These files should only contain the tokens that need to be overridden for that specific theme.

When this configuration is used, Style Dictionary will create a single, merged object where, for any given token path, the value from the theme file (source) will have replaced the value from the base file (include). When an alias like {color.text.primary} is subsequently resolved, it will correctly pick up the themed value if one was provided, or the base value if not.

The notion of "cross-file references" is, in this context, a helpful abstraction for authors but a technical misnomer for the build process. Once Style Dictionary performs its initial deep merge, all subsequent operations, including alias resolution, occur on a single, monolithic, in-memory object. The success of the entire system, therefore, hinges on the disciplined and explicit configuration of the file merge order.   

5.2 Handling Unofficial Types and Transformations
As identified in Section 3.3, a direct output from Tokens Studio is not immediately compliant with the strict DTCG type system due to its use of "unofficial" types. This requires a dedicated pre-processing step in the build pipeline. The @tokens-studio/sd-transforms package is an npm dependency designed specifically for this purpose. It provides a pre-processor for Style Dictionary that intercepts the token data, maps unofficial types like spacing and borderRadius to the official dimension type, and adjusts value structures to be compliant before passing the data to Style Dictionary's core transformation engine.   

Build Implication: The integration of @tokens-studio/sd-transforms is a non-negotiable dependency for any build pipeline that consumes tokens authored in Tokens Studio. It must be configured to run before any other transforms or validations.

6.0 Deliverables: Guardrails Note and Linter Configuration
This section contains the actionable deliverables for Mission TR-20251010-R4.1, intended for direct use by the Design System Engineering team.

6.1 docs/tokens/guardrails/dtcg-alias-resolver-guardrails.md
DTCG Theming Guardrails (v1.0 - Sprint 04)
Objective
This document outlines the engineering guardrails for authoring design tokens to ensure stability, maintainability, and forward-compatibility with the W3C Design Tokens Community Group (DTCG) specification. These rules are mandatory for all token contributions and will be enforced via automated linting.

Allowed Now (Sprint 04)
The following features and patterns are considered stable and are approved for immediate use.

Naming and Structure
Casing: All token and group names MUST use lowercase kebab-case (e.g., my-token-name).

Characters: Names MUST NOT contain periods (.), curly brackets ({}), or any other special characters besides hyphens.

Prefixes: Names MUST NOT begin with a dollar sign ($).

Rule Category	Requirement	Rationale	Invalid Examples	Valid Example
Casing	Must use lowercase kebab-case.	Prevents collisions in case-insensitive platforms.	myToken, My-Token	my-token
Characters	Must not contain {, }, or ..	Reserved for alias syntax and path resolution.	token.name, {token}	token-name
Prefixes	Must not begin with $.	Reserved for DTCG specification properties.	$my-token	my-token

Export to Sheets
Aliasing (References)
Syntax: Aliases MUST use the {path.to.token} syntax.

Full Value Only: An alias MUST constitute the entire $value of a token.

No Circular Dependencies: Alias chains that reference themselves are forbidden and will fail the build.

Cross-File References: References to tokens in other files are permitted, contingent on the build configuration.

Types and Values
Required Properties: All tokens MUST have a $value and a $type. A $description is strongly recommended.

Official Types: The $type MUST resolve to an official DTCG type (e.g., color, dimension, shadow). Unofficial types from authoring tools (e.g., spacing) will be mapped to official types during the build process.

Deferred / Experimental
The following features are NOT approved for use. They are not yet standardized by the DTCG, and using them would introduce significant technical debt and migration risk.

❌ Advanced Aliasing (String Interpolation): Embedding aliases within a string (e.g., "1px solid {color.border}") is forbidden. Use composite tokens instead.

❌ Aliases within Arrays: Using an alias as an element in an array (e.g., for multi-value shadows) is forbidden.

❌ Value Fallbacks: Providing a fallback value for an alias (e.g., using an array ["{token.ref}", "#FFF"]) is forbidden. Unresolved aliases MUST cause a build failure.

Tooling & Build Process
Theming Precedence: Theming is achieved through Style Dictionary's file merge order.

Base tokens (global, primitives) MUST be placed in the include array of the config.

Theme-specific overrides MUST be placed in the source array of the config.

Files in source will always override files in include.

6.2 tools/token-lint/dtcg-guardrails.config.yaml (Stub)
YAML

# DTCG Guardrails Configuration v1.0 (For Sprint 04)
# This configuration enforces a safe subset of the DTCG specification for enterprise use.
# It should be used in conjunction with a pre-processor that maps tool-specific
# types (e.g., from Tokens Studio) to official DTCG types before linting.

rules:
  # === Naming and Structure Rules (Section 3.1) ===
  dtcg/token-name-kebab-case:
    enabled: true
    level: "error"
    description: "Token and group names must use lowercase kebab-case."
    # Bad: { "myToken": {... } }
    # Bad: { "My-Token": {... } }
    # Good: { "my-token": {... } }

  dtcg/token-name-no-illegal-chars:
    enabled: true
    level: "error"
    description: "Token and group names must not contain '.', '{', or '}'."
    # Bad: { "token.with.dot": {... } }
    # Bad: { "{token}": {... } }

  dtcg/token-name-no-dollar-prefix:
    enabled: true
    level: "error"
    description: "Token and group names must not start with '$'."
    # Bad: { "$my-token": {... } }

  # === Reference (Alias) Semantics (Section 3.2) ===
  dtcg/alias-no-circular-references:
    enabled: true
    level: "error"
    description: "Alias chains must not contain cycles. This check is typically performed by the build tool."

  dtcg/alias-is-full-value:
    enabled: true
    level: "error"
    description: "An alias must be the entire '$value' of a token. No string interpolation."
    # Bad: { "$value": "1px solid {color.red}" }
    # Good: { "$value": "{color.red}" }

  # === Type System and Values (Section 3.3) ===
  dtcg/token-must-have-type:
    enabled: true
    level: "error"
    description: "All design tokens must have a '$type' property."
    # Bad: { "my-token": { "$value": "#FFF" } }

  dtcg/token-type-is-official:
    enabled: true
    level: "error"
    description: "The '$type' property must be an official DTCG type."
    # Note: This check runs *after* a pre-processing step maps unofficial types.
    allowedTypes:
      - "color"
      - "dimension"
      - "fontFamily"
      - "fontWeight"
      - "duration"
      - "cubicBezier"
      - "number"
      - "strokeStyle"
      - "border"
      - "transition"
      - "shadow"
      - "gradient"
      - "typography"
      - "content" # Added for unofficial 'text' type
      # Unofficial but common types that may pass through
      - "asset"
      - "boolean"
      - "other"

  # === Deferred / Experimental Rules (Section 4.0) ===
  dtcg/alias-no-string-interpolation:
    enabled: true
    level: "warn"
    description: "[Experimental] String interpolation with aliases is not yet standardized by DTCG."
    # Example: { "$value": "1px solid {color.red}" }

  dtcg/alias-no-in-array:
    enabled: true
    level: "warn"
    description: "[Experimental] Using aliases within an array is not yet standardized by DTCG."
    # Example: { "$value": ["{shadow.a}", "{shadow.b}"] }

  dtcg/alias-no-fallbacks:
    enabled: true
    level: "warn"
    description: "[Experimental] Alias fallbacks are not yet standardized by DTCG."
    # Example: { "$value": ["{color.primary}", "#FF0000"] }

Sources used in the report

designtokens.org
Design Tokens Community Group: Home
Opens in a new window

w3.org
Design Tokens Community Group - W3C
Opens in a new window

styledictionary.com
Design Tokens Community Group | Style Dictionary
Opens in a new window

designtokens.org
Design Tokens Technical Reports - Design Tokens Community Group
Opens in a new window

designtokens.org
Design Tokens Format Module
Opens in a new window

help.figma.com
Update 1: Tokens, variables, and styles – Figma Learn - Help Center
Opens in a new window

docs.tokens.studio
Token Name Technical Specs | Tokens Studio for Figma
Opens in a new window

docs.tokens.studio
Token Groups - Tokens Studio for Figma
Opens in a new window

designtokens.org
Opens in a new window

qifanz.com
ResolverFuzz: Automated Discovery of DNS Resolver Vulnerabilities with Query-Response Fuzzing - Qifan Zhang
Opens in a new window

codeguru.com
DNS Resolver RFC 1035 - CodeGuru
Opens in a new window

rfc-annotations.research.icann.org
RFC 1035 - icann
Opens in a new window

rfc-editor.org
RFC 9606: DNS Resolver Information
Opens in a new window

styledictionary.com
Architecture | Style Dictionary
Opens in a new window

github.com
GitHub · Where software is built
Opens in a new window

github.com
Shadow type feedback · Issue #100 · design-tokens/community-group - GitHub
Opens in a new window

docs.tokens.studio
Token Values with References | Tokens Studio for Figma
Opens in a new window

docs.tokens.studio
Token Values - Tokens Studio for Figma
Opens in a new window

styledictionary.com
Design Tokens - Style Dictionary
Opens in a new window

docs.tokens.studio
Token Names - Tokens Studio for Figma
Opens in a new window

spectrum.adobe.com
Design tokens - Spectrum, Adobe's design system
Opens in a new window

docs.tokens.studio
Token Types - Tokens Studio for Figma
Opens in a new window

styledictionary.com
References - Style Dictionary
Opens in a new window

github.com
style-dictionary/style-dictionary: A build system for creating cross-platform styles. - GitHub
Opens in a new window

docs.tokens.studio
Style Dictionary + SD Transforms - Tokens Studio for Figma
Opens in a new window

docs.tokens.studio
Token Sets - Tokens Studio for Figma
Opens in a new window

docs.tokens.studio
Manage Tokens in the Plugin - Tokens Studio for Figma
Opens in a new window

github.com
Order of precedence for inline tokens, include tokens, and source tokens · Issue #