export interface ObjectInterfaceTemplateField {
  readonly name: string;
  readonly type: string;
  readonly optional: boolean;
  readonly jsDoc: readonly string[];
}

export interface ObjectInterfaceTemplateOptions {
  readonly objectName: string;
  readonly interfaceName: string;
  readonly description?: string;
  readonly sourcePath?: string;
  readonly traits: readonly string[];
  readonly generatedAt?: Date;
  readonly fields: readonly ObjectInterfaceTemplateField[];
}

export function renderObjectInterfaceFile(options: ObjectInterfaceTemplateOptions): string {
  const { objectName, interfaceName, description, sourcePath, traits, generatedAt, fields } =
    options;

  const headerLines: string[] = [`Interface definitions for ${objectName}`];

  if (description && description.trim().length > 0) {
    headerLines.push(description.trim());
  }

  headerLines.push(
    '',
    'DO NOT EDIT - This file is auto-generated by the object type generator.'
  );
  
  if (sourcePath) {
    headerLines.push(`Source: ${sourcePath}`);
  }
  
  if (traits.length > 0) {
    headerLines.push(`Traits: ${traits.join(', ')}`);
  }
  
  if (generatedAt) {
    headerLines.push(`Generated at: ${generatedAt.toISOString()}`);
  }

  const filteredHeader = headerLines.filter(
    (line): line is string => line !== undefined && line !== null
  );

  const headerComment = renderJsDoc(filteredHeader);

  // Add StateTransition type definition if needed
  const needsStateTransition = fields.some(field => field.type.includes('StateTransition'));
  const stateTransitionType = needsStateTransition ? 
    `export interface StateTransition {
  readonly from_state: string;
  readonly to_state: string;
  readonly timestamp: string;
  readonly reason?: string;
  readonly actor_id?: string;
}

` : '';

  const interfaceLines: string[] = [];
  interfaceLines.push(`export interface ${interfaceName} {`);

  if (fields.length === 0) {
    interfaceLines.push('  // No schema fields were produced during composition.');
  } else {
    fields.forEach((field) => {
      const docBlock = renderJsDoc(field.jsDoc);
      const optionalFlag = field.optional ? '?' : '';
      const declaration = `${field.name}${optionalFlag}: ${field.type};`;

      if (docBlock) {
        interfaceLines.push(indent(docBlock.trimEnd(), 2));
      }
      interfaceLines.push(`  ${declaration}`);
      interfaceLines.push('');
    });

    if (interfaceLines[interfaceLines.length - 1] === '') {
      interfaceLines.pop();
    }
  }

  if (traits.includes('Authable')) {
    interfaceLines.push('');
    interfaceLines.push(...renderAuthableHelperMethods());
  }

  interfaceLines.push('}');

  return `${headerComment}${headerComment ? '\n' : ''}${stateTransitionType}${interfaceLines.join('\n')}\n`;
}

function renderJsDoc(lines: readonly string[]): string {
  const filtered = lines.filter((line) => line !== undefined && line !== null);
  if (filtered.length === 0) {
    return '';
  }

  const resolved = filtered.map((line) => line ?? '');
  const formatted = resolved
    .map((line) => (line.length > 0 ? ` * ${line}` : ' *'))
    .join('\n');

  return `/**\n${formatted}\n */`;
}

function indent(block: string, spaces: number): string {
  const prefix = ' '.repeat(spaces);
  return block
    .split('\n')
    .map((line) => (line.length > 0 ? `${prefix}${line}` : line))
    .join('\n');
}

function renderAuthableHelperMethods(): string[] {
  const lines: string[] = [];
  const helperDocs = [
    {
      doc: [
        'Return Authable roles scoped to the provided organization identifier.',
        '',
        'Source: Authable (trait helper)',
      ],
      signature: 'getRolesInOrg?(organizationId: string): AuthzRoleDocument[];',
    },
    {
      doc: [
        'Check whether the user has a permission (UUID or resource:action) in the specified organization.',
        '',
        'Source: Authable (trait helper)',
      ],
      signature: 'hasPermission?(organizationId: string, permission: string): boolean;',
    },
    {
      doc: [
        'Emit a normalized entitlement export for downstream IAM integrations.',
        '',
        'Source: Authable (trait helper)',
      ],
      signature:
        'exportEntitlements?(organizationId: string): { roles: AuthzRoleDocument[]; permissions: AuthzPermissionDocument[] };',
    },
  ];

  helperDocs.forEach((entry, index) => {
    const doc = renderJsDoc(entry.doc);
    if (doc) {
      lines.push(indent(doc.trimEnd(), 2));
    }
    lines.push(`  ${entry.signature}`);
    if (index < helperDocs.length - 1) {
      lines.push('');
    }
  });

  return lines;
}
